(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.browser.js
  var require_picocolors_browser = __commonJS({
    "node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.browser.js"(exports, module) {
      var x = String;
      var create = function() {
        return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x };
      };
      module.exports = create();
      module.exports.createColors = create;
    }
  });

  // (disabled):node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/terminal-highlight
  var require_terminal_highlight = __commonJS({
    "(disabled):node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/terminal-highlight"() {
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/css-syntax-error.js
  var require_css_syntax_error = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/css-syntax-error.js"(exports, module) {
      "use strict";
      var pico = require_picocolors_browser();
      var terminalHighlight = require_terminal_highlight();
      var CssSyntaxError2 = class _CssSyntaxError extends Error {
        constructor(message, line, column, source, file, plugin2) {
          super(message);
          this.name = "CssSyntaxError";
          this.reason = message;
          if (file) {
            this.file = file;
          }
          if (source) {
            this.source = source;
          }
          if (plugin2) {
            this.plugin = plugin2;
          }
          if (typeof line !== "undefined" && typeof column !== "undefined") {
            if (typeof line === "number") {
              this.line = line;
              this.column = column;
            } else {
              this.line = line.line;
              this.column = line.column;
              this.endLine = column.line;
              this.endColumn = column.column;
            }
          }
          this.setMessage();
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, _CssSyntaxError);
          }
        }
        setMessage() {
          this.message = this.plugin ? this.plugin + ": " : "";
          this.message += this.file ? this.file : "<css input>";
          if (typeof this.line !== "undefined") {
            this.message += ":" + this.line + ":" + this.column;
          }
          this.message += ": " + this.reason;
        }
        showSourceCode(color2) {
          if (!this.source)
            return "";
          let css = this.source;
          if (color2 == null)
            color2 = pico.isColorSupported;
          if (terminalHighlight) {
            if (color2)
              css = terminalHighlight(css);
          }
          let lines = css.split(/\r?\n/);
          let start = Math.max(this.line - 3, 0);
          let end = Math.min(this.line + 2, lines.length);
          let maxWidth = String(end).length;
          let mark, aside;
          if (color2) {
            let { bold, gray, red } = pico.createColors(true);
            mark = (text2) => bold(red(text2));
            aside = (text2) => gray(text2);
          } else {
            mark = aside = (str) => str;
          }
          return lines.slice(start, end).map((line, index2) => {
            let number2 = start + 1 + index2;
            let gutter = " " + (" " + number2).slice(-maxWidth) + " | ";
            if (number2 === this.line) {
              let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
              return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
            }
            return " " + aside(gutter) + line;
          }).join("\n");
        }
        toString() {
          let code = this.showSourceCode();
          if (code) {
            code = "\n\n" + code + "\n";
          }
          return this.name + ": " + this.message + code;
        }
      };
      module.exports = CssSyntaxError2;
      CssSyntaxError2.default = CssSyntaxError2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/symbols.js
  var require_symbols = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/symbols.js"(exports, module) {
      "use strict";
      module.exports.isClean = Symbol("isClean");
      module.exports.my = Symbol("my");
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/stringifier.js
  var require_stringifier = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/stringifier.js"(exports, module) {
      "use strict";
      var DEFAULT_RAW = {
        after: "\n",
        beforeClose: "\n",
        beforeComment: "\n",
        beforeDecl: "\n",
        beforeOpen: " ",
        beforeRule: "\n",
        colon: ": ",
        commentLeft: " ",
        commentRight: " ",
        emptyBody: "",
        indent: "    ",
        semicolon: false
      };
      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }
      var Stringifier = class {
        constructor(builder) {
          this.builder = builder;
        }
        atrule(node, semicolon) {
          let name = "@" + node.name;
          let params = node.params ? this.rawValue(node, "params") : "";
          if (typeof node.raws.afterName !== "undefined") {
            name += node.raws.afterName;
          } else if (params) {
            name += " ";
          }
          if (node.nodes) {
            this.block(node, name + params);
          } else {
            let end = (node.raws.between || "") + (semicolon ? ";" : "");
            this.builder(name + params + end, node);
          }
        }
        beforeAfter(node, detect) {
          let value2;
          if (node.type === "decl") {
            value2 = this.raw(node, null, "beforeDecl");
          } else if (node.type === "comment") {
            value2 = this.raw(node, null, "beforeComment");
          } else if (detect === "before") {
            value2 = this.raw(node, null, "beforeRule");
          } else {
            value2 = this.raw(node, null, "beforeClose");
          }
          let buf = node.parent;
          let depth = 0;
          while (buf && buf.type !== "root") {
            depth += 1;
            buf = buf.parent;
          }
          if (value2.includes("\n")) {
            let indent = this.raw(node, null, "indent");
            if (indent.length) {
              for (let step = 0; step < depth; step++)
                value2 += indent;
            }
          }
          return value2;
        }
        block(node, start) {
          let between = this.raw(node, "between", "beforeOpen");
          this.builder(start + between + "{", node, "start");
          let after;
          if (node.nodes && node.nodes.length) {
            this.body(node);
            after = this.raw(node, "after");
          } else {
            after = this.raw(node, "after", "emptyBody");
          }
          if (after)
            this.builder(after);
          this.builder("}", node, "end");
        }
        body(node) {
          let last = node.nodes.length - 1;
          while (last > 0) {
            if (node.nodes[last].type !== "comment")
              break;
            last -= 1;
          }
          let semicolon = this.raw(node, "semicolon");
          for (let i = 0; i < node.nodes.length; i++) {
            let child = node.nodes[i];
            let before = this.raw(child, "before");
            if (before)
              this.builder(before);
            this.stringify(child, last !== i || semicolon);
          }
        }
        comment(node) {
          let left = this.raw(node, "left", "commentLeft");
          let right = this.raw(node, "right", "commentRight");
          this.builder("/*" + left + node.text + right + "*/", node);
        }
        decl(node, semicolon) {
          let between = this.raw(node, "between", "colon");
          let string = node.prop + between + this.rawValue(node, "value");
          if (node.important) {
            string += node.raws.important || " !important";
          }
          if (semicolon)
            string += ";";
          this.builder(string, node);
        }
        document(node) {
          this.body(node);
        }
        raw(node, own, detect) {
          let value2;
          if (!detect)
            detect = own;
          if (own) {
            value2 = node.raws[own];
            if (typeof value2 !== "undefined")
              return value2;
          }
          let parent = node.parent;
          if (detect === "before") {
            if (!parent || parent.type === "root" && parent.first === node) {
              return "";
            }
            if (parent && parent.type === "document") {
              return "";
            }
          }
          if (!parent)
            return DEFAULT_RAW[detect];
          let root2 = node.root();
          if (!root2.rawCache)
            root2.rawCache = {};
          if (typeof root2.rawCache[detect] !== "undefined") {
            return root2.rawCache[detect];
          }
          if (detect === "before" || detect === "after") {
            return this.beforeAfter(node, detect);
          } else {
            let method = "raw" + capitalize(detect);
            if (this[method]) {
              value2 = this[method](root2, node);
            } else {
              root2.walk((i) => {
                value2 = i.raws[own];
                if (typeof value2 !== "undefined")
                  return false;
              });
            }
          }
          if (typeof value2 === "undefined")
            value2 = DEFAULT_RAW[detect];
          root2.rawCache[detect] = value2;
          return value2;
        }
        rawBeforeClose(root2) {
          let value2;
          root2.walk((i) => {
            if (i.nodes && i.nodes.length > 0) {
              if (typeof i.raws.after !== "undefined") {
                value2 = i.raws.after;
                if (value2.includes("\n")) {
                  value2 = value2.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value2)
            value2 = value2.replace(/\S/g, "");
          return value2;
        }
        rawBeforeComment(root2, node) {
          let value2;
          root2.walkComments((i) => {
            if (typeof i.raws.before !== "undefined") {
              value2 = i.raws.before;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value2 === "undefined") {
            value2 = this.raw(node, null, "beforeDecl");
          } else if (value2) {
            value2 = value2.replace(/\S/g, "");
          }
          return value2;
        }
        rawBeforeDecl(root2, node) {
          let value2;
          root2.walkDecls((i) => {
            if (typeof i.raws.before !== "undefined") {
              value2 = i.raws.before;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value2 === "undefined") {
            value2 = this.raw(node, null, "beforeRule");
          } else if (value2) {
            value2 = value2.replace(/\S/g, "");
          }
          return value2;
        }
        rawBeforeOpen(root2) {
          let value2;
          root2.walk((i) => {
            if (i.type !== "decl") {
              value2 = i.raws.between;
              if (typeof value2 !== "undefined")
                return false;
            }
          });
          return value2;
        }
        rawBeforeRule(root2) {
          let value2;
          root2.walk((i) => {
            if (i.nodes && (i.parent !== root2 || root2.first !== i)) {
              if (typeof i.raws.before !== "undefined") {
                value2 = i.raws.before;
                if (value2.includes("\n")) {
                  value2 = value2.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value2)
            value2 = value2.replace(/\S/g, "");
          return value2;
        }
        rawColon(root2) {
          let value2;
          root2.walkDecls((i) => {
            if (typeof i.raws.between !== "undefined") {
              value2 = i.raws.between.replace(/[^\s:]/g, "");
              return false;
            }
          });
          return value2;
        }
        rawEmptyBody(root2) {
          let value2;
          root2.walk((i) => {
            if (i.nodes && i.nodes.length === 0) {
              value2 = i.raws.after;
              if (typeof value2 !== "undefined")
                return false;
            }
          });
          return value2;
        }
        rawIndent(root2) {
          if (root2.raws.indent)
            return root2.raws.indent;
          let value2;
          root2.walk((i) => {
            let p2 = i.parent;
            if (p2 && p2 !== root2 && p2.parent && p2.parent === root2) {
              if (typeof i.raws.before !== "undefined") {
                let parts = i.raws.before.split("\n");
                value2 = parts[parts.length - 1];
                value2 = value2.replace(/\S/g, "");
                return false;
              }
            }
          });
          return value2;
        }
        rawSemicolon(root2) {
          let value2;
          root2.walk((i) => {
            if (i.nodes && i.nodes.length && i.last.type === "decl") {
              value2 = i.raws.semicolon;
              if (typeof value2 !== "undefined")
                return false;
            }
          });
          return value2;
        }
        rawValue(node, prop) {
          let value2 = node[prop];
          let raw = node.raws[prop];
          if (raw && raw.value === value2) {
            return raw.raw;
          }
          return value2;
        }
        root(node) {
          this.body(node);
          if (node.raws.after)
            this.builder(node.raws.after);
        }
        rule(node) {
          this.block(node, this.rawValue(node, "selector"));
          if (node.raws.ownSemicolon) {
            this.builder(node.raws.ownSemicolon, node, "end");
          }
        }
        stringify(node, semicolon) {
          if (!this[node.type]) {
            throw new Error(
              "Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier."
            );
          }
          this[node.type](node, semicolon);
        }
      };
      module.exports = Stringifier;
      Stringifier.default = Stringifier;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/stringify.js"(exports, module) {
      "use strict";
      var Stringifier = require_stringifier();
      function stringify2(node, builder) {
        let str = new Stringifier(builder);
        str.stringify(node);
      }
      module.exports = stringify2;
      stringify2.default = stringify2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/node.js
  var require_node = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/node.js"(exports, module) {
      "use strict";
      var { isClean, my } = require_symbols();
      var CssSyntaxError2 = require_css_syntax_error();
      var Stringifier = require_stringifier();
      var stringify2 = require_stringify();
      function cloneNode(obj, parent) {
        let cloned = new obj.constructor();
        for (let i in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, i)) {
            continue;
          }
          if (i === "proxyCache")
            continue;
          let value2 = obj[i];
          let type = typeof value2;
          if (i === "parent" && type === "object") {
            if (parent)
              cloned[i] = parent;
          } else if (i === "source") {
            cloned[i] = value2;
          } else if (Array.isArray(value2)) {
            cloned[i] = value2.map((j) => cloneNode(j, cloned));
          } else {
            if (type === "object" && value2 !== null)
              value2 = cloneNode(value2);
            cloned[i] = value2;
          }
        }
        return cloned;
      }
      var Node3 = class {
        constructor(defaults3 = {}) {
          this.raws = {};
          this[isClean] = false;
          this[my] = true;
          for (let name in defaults3) {
            if (name === "nodes") {
              this.nodes = [];
              for (let node of defaults3[name]) {
                if (typeof node.clone === "function") {
                  this.append(node.clone());
                } else {
                  this.append(node);
                }
              }
            } else {
              this[name] = defaults3[name];
            }
          }
        }
        addToError(error) {
          error.postcssNode = this;
          if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
            let s2 = this.source;
            error.stack = error.stack.replace(
              /\n\s{4}at /,
              `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
            );
          }
          return error;
        }
        after(add) {
          this.parent.insertAfter(this, add);
          return this;
        }
        assign(overrides = {}) {
          for (let name in overrides) {
            this[name] = overrides[name];
          }
          return this;
        }
        before(add) {
          this.parent.insertBefore(this, add);
          return this;
        }
        cleanRaws(keepBetween) {
          delete this.raws.before;
          delete this.raws.after;
          if (!keepBetween)
            delete this.raws.between;
        }
        clone(overrides = {}) {
          let cloned = cloneNode(this);
          for (let name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        }
        cloneAfter(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertAfter(this, cloned);
          return cloned;
        }
        cloneBefore(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertBefore(this, cloned);
          return cloned;
        }
        error(message, opts = {}) {
          if (this.source) {
            let { end, start } = this.rangeBy(opts);
            return this.source.input.error(
              message,
              { column: start.column, line: start.line },
              { column: end.column, line: end.line },
              opts
            );
          }
          return new CssSyntaxError2(message);
        }
        getProxyProcessor() {
          return {
            get(node, prop) {
              if (prop === "proxyOf") {
                return node;
              } else if (prop === "root") {
                return () => node.root().toProxy();
              } else {
                return node[prop];
              }
            },
            set(node, prop, value2) {
              if (node[prop] === value2)
                return true;
              node[prop] = value2;
              if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
              prop === "text") {
                node.markDirty();
              }
              return true;
            }
          };
        }
        markDirty() {
          if (this[isClean]) {
            this[isClean] = false;
            let next = this;
            while (next = next.parent) {
              next[isClean] = false;
            }
          }
        }
        next() {
          if (!this.parent)
            return void 0;
          let index2 = this.parent.index(this);
          return this.parent.nodes[index2 + 1];
        }
        positionBy(opts, stringRepresentation) {
          let pos = this.source.start;
          if (opts.index) {
            pos = this.positionInside(opts.index, stringRepresentation);
          } else if (opts.word) {
            stringRepresentation = this.toString();
            let index2 = stringRepresentation.indexOf(opts.word);
            if (index2 !== -1)
              pos = this.positionInside(index2, stringRepresentation);
          }
          return pos;
        }
        positionInside(index2, stringRepresentation) {
          let string = stringRepresentation || this.toString();
          let column = this.source.start.column;
          let line = this.source.start.line;
          for (let i = 0; i < index2; i++) {
            if (string[i] === "\n") {
              column = 1;
              line += 1;
            } else {
              column += 1;
            }
          }
          return { column, line };
        }
        prev() {
          if (!this.parent)
            return void 0;
          let index2 = this.parent.index(this);
          return this.parent.nodes[index2 - 1];
        }
        rangeBy(opts) {
          let start = {
            column: this.source.start.column,
            line: this.source.start.line
          };
          let end = this.source.end ? {
            column: this.source.end.column + 1,
            line: this.source.end.line
          } : {
            column: start.column + 1,
            line: start.line
          };
          if (opts.word) {
            let stringRepresentation = this.toString();
            let index2 = stringRepresentation.indexOf(opts.word);
            if (index2 !== -1) {
              start = this.positionInside(index2, stringRepresentation);
              end = this.positionInside(index2 + opts.word.length, stringRepresentation);
            }
          } else {
            if (opts.start) {
              start = {
                column: opts.start.column,
                line: opts.start.line
              };
            } else if (opts.index) {
              start = this.positionInside(opts.index);
            }
            if (opts.end) {
              end = {
                column: opts.end.column,
                line: opts.end.line
              };
            } else if (typeof opts.endIndex === "number") {
              end = this.positionInside(opts.endIndex);
            } else if (opts.index) {
              end = this.positionInside(opts.index + 1);
            }
          }
          if (end.line < start.line || end.line === start.line && end.column <= start.column) {
            end = { column: start.column + 1, line: start.line };
          }
          return { end, start };
        }
        raw(prop, defaultType) {
          let str = new Stringifier();
          return str.raw(this, prop, defaultType);
        }
        remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        }
        replaceWith(...nodes) {
          if (this.parent) {
            let bookmark = this;
            let foundSelf = false;
            for (let node of nodes) {
              if (node === this) {
                foundSelf = true;
              } else if (foundSelf) {
                this.parent.insertAfter(bookmark, node);
                bookmark = node;
              } else {
                this.parent.insertBefore(bookmark, node);
              }
            }
            if (!foundSelf) {
              this.remove();
            }
          }
          return this;
        }
        root() {
          let result = this;
          while (result.parent && result.parent.type !== "document") {
            result = result.parent;
          }
          return result;
        }
        toJSON(_, inputs) {
          let fixed = {};
          let emitInputs = inputs == null;
          inputs = inputs || /* @__PURE__ */ new Map();
          let inputsNextIndex = 0;
          for (let name in this) {
            if (!Object.prototype.hasOwnProperty.call(this, name)) {
              continue;
            }
            if (name === "parent" || name === "proxyCache")
              continue;
            let value2 = this[name];
            if (Array.isArray(value2)) {
              fixed[name] = value2.map((i) => {
                if (typeof i === "object" && i.toJSON) {
                  return i.toJSON(null, inputs);
                } else {
                  return i;
                }
              });
            } else if (typeof value2 === "object" && value2.toJSON) {
              fixed[name] = value2.toJSON(null, inputs);
            } else if (name === "source") {
              let inputId = inputs.get(value2.input);
              if (inputId == null) {
                inputId = inputsNextIndex;
                inputs.set(value2.input, inputsNextIndex);
                inputsNextIndex++;
              }
              fixed[name] = {
                end: value2.end,
                inputId,
                start: value2.start
              };
            } else {
              fixed[name] = value2;
            }
          }
          if (emitInputs) {
            fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
          }
          return fixed;
        }
        toProxy() {
          if (!this.proxyCache) {
            this.proxyCache = new Proxy(this, this.getProxyProcessor());
          }
          return this.proxyCache;
        }
        toString(stringifier = stringify2) {
          if (stringifier.stringify)
            stringifier = stringifier.stringify;
          let result = "";
          stringifier(this, (i) => {
            result += i;
          });
          return result;
        }
        warn(result, text2, opts) {
          let data = { node: this };
          for (let i in opts)
            data[i] = opts[i];
          return result.warn(text2, data);
        }
        get proxyOf() {
          return this;
        }
      };
      module.exports = Node3;
      Node3.default = Node3;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/declaration.js
  var require_declaration = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/declaration.js"(exports, module) {
      "use strict";
      var Node3 = require_node();
      var Declaration2 = class extends Node3 {
        constructor(defaults3) {
          if (defaults3 && typeof defaults3.value !== "undefined" && typeof defaults3.value !== "string") {
            defaults3 = { ...defaults3, value: String(defaults3.value) };
          }
          super(defaults3);
          this.type = "decl";
        }
        get variable() {
          return this.prop.startsWith("--") || this.prop[0] === "$";
        }
      };
      module.exports = Declaration2;
      Declaration2.default = Declaration2;
    }
  });

  // (disabled):node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/source-map.js
  var require_source_map = __commonJS({
    "(disabled):node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/source-map.js"() {
    }
  });

  // (disabled):path
  var require_path = __commonJS({
    "(disabled):path"() {
    }
  });

  // (disabled):url
  var require_url = __commonJS({
    "(disabled):url"() {
    }
  });

  // node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/non-secure/index.cjs
  var require_non_secure = __commonJS({
    "node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/non-secure/index.cjs"(exports, module) {
      var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      var customAlphabet = (alphabet, defaultSize = 21) => {
        return (size = defaultSize) => {
          let id = "";
          let i = size;
          while (i--) {
            id += alphabet[Math.random() * alphabet.length | 0];
          }
          return id;
        };
      };
      var nanoid = (size = 21) => {
        let id = "";
        let i = size;
        while (i--) {
          id += urlAlphabet[Math.random() * 64 | 0];
        }
        return id;
      };
      module.exports = { nanoid, customAlphabet };
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/previous-map.js
  var require_previous_map = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/previous-map.js"(exports, module) {
      "use strict";
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { existsSync, readFileSync } = require_fs();
      var { dirname: dirname2, join: join2 } = require_path();
      function fromBase64(str) {
        if (Buffer) {
          return Buffer.from(str, "base64").toString();
        } else {
          return window.atob(str);
        }
      }
      var PreviousMap = class {
        constructor(css, opts) {
          if (opts.map === false)
            return;
          this.loadAnnotation(css);
          this.inline = this.startWith(this.annotation, "data:");
          let prev = opts.map ? opts.map.prev : void 0;
          let text2 = this.loadMap(opts.from, prev);
          if (!this.mapFile && opts.from) {
            this.mapFile = opts.from;
          }
          if (this.mapFile)
            this.root = dirname2(this.mapFile);
          if (text2)
            this.text = text2;
        }
        consumer() {
          if (!this.consumerCache) {
            this.consumerCache = new SourceMapConsumer(this.text);
          }
          return this.consumerCache;
        }
        decodeInline(text2) {
          let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
          let baseUri = /^data:application\/json;base64,/;
          let charsetUri = /^data:application\/json;charset=utf-?8,/;
          let uri = /^data:application\/json,/;
          if (charsetUri.test(text2) || uri.test(text2)) {
            return decodeURIComponent(text2.substr(RegExp.lastMatch.length));
          }
          if (baseCharsetUri.test(text2) || baseUri.test(text2)) {
            return fromBase64(text2.substr(RegExp.lastMatch.length));
          }
          let encoding = text2.match(/data:application\/json;([^,]+),/)[1];
          throw new Error("Unsupported source map encoding " + encoding);
        }
        getAnnotationURL(sourceMapString) {
          return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
        }
        isMap(map) {
          if (typeof map !== "object")
            return false;
          return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
        }
        loadAnnotation(css) {
          let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
          if (!comments)
            return;
          let start = css.lastIndexOf(comments.pop());
          let end = css.indexOf("*/", start);
          if (start > -1 && end > -1) {
            this.annotation = this.getAnnotationURL(css.substring(start, end));
          }
        }
        loadFile(path) {
          this.root = dirname2(path);
          if (existsSync(path)) {
            this.mapFile = path;
            return readFileSync(path, "utf-8").toString().trim();
          }
        }
        loadMap(file, prev) {
          if (prev === false)
            return false;
          if (prev) {
            if (typeof prev === "string") {
              return prev;
            } else if (typeof prev === "function") {
              let prevPath = prev(file);
              if (prevPath) {
                let map = this.loadFile(prevPath);
                if (!map) {
                  throw new Error(
                    "Unable to load previous source map: " + prevPath.toString()
                  );
                }
                return map;
              }
            } else if (prev instanceof SourceMapConsumer) {
              return SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof SourceMapGenerator) {
              return prev.toString();
            } else if (this.isMap(prev)) {
              return JSON.stringify(prev);
            } else {
              throw new Error(
                "Unsupported previous source map format: " + prev.toString()
              );
            }
          } else if (this.inline) {
            return this.decodeInline(this.annotation);
          } else if (this.annotation) {
            let map = this.annotation;
            if (file)
              map = join2(dirname2(file), map);
            return this.loadFile(map);
          }
        }
        startWith(string, start) {
          if (!string)
            return false;
          return string.substr(0, start.length) === start;
        }
        withContent() {
          return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        }
      };
      module.exports = PreviousMap;
      PreviousMap.default = PreviousMap;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/input.js
  var require_input = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/input.js"(exports, module) {
      "use strict";
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { fileURLToPath, pathToFileURL } = require_url();
      var { isAbsolute, resolve: resolve2 } = require_path();
      var { nanoid } = require_non_secure();
      var terminalHighlight = require_terminal_highlight();
      var CssSyntaxError2 = require_css_syntax_error();
      var PreviousMap = require_previous_map();
      var fromOffsetCache = Symbol("fromOffsetCache");
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(resolve2 && isAbsolute);
      var Input2 = class {
        constructor(css, opts = {}) {
          if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
            throw new Error(`PostCSS received ${css} instead of CSS string`);
          }
          this.css = css.toString();
          if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
            this.hasBOM = true;
            this.css = this.css.slice(1);
          } else {
            this.hasBOM = false;
          }
          if (opts.from) {
            if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
              this.file = opts.from;
            } else {
              this.file = resolve2(opts.from);
            }
          }
          if (pathAvailable && sourceMapAvailable) {
            let map = new PreviousMap(this.css, opts);
            if (map.text) {
              this.map = map;
              let file = map.consumer().file;
              if (!this.file && file)
                this.file = this.mapResolve(file);
            }
          }
          if (!this.file) {
            this.id = "<input css " + nanoid(6) + ">";
          }
          if (this.map)
            this.map.file = this.from;
        }
        error(message, line, column, opts = {}) {
          let result, endLine, endColumn;
          if (line && typeof line === "object") {
            let start = line;
            let end = column;
            if (typeof start.offset === "number") {
              let pos = this.fromOffset(start.offset);
              line = pos.line;
              column = pos.col;
            } else {
              line = start.line;
              column = start.column;
            }
            if (typeof end.offset === "number") {
              let pos = this.fromOffset(end.offset);
              endLine = pos.line;
              endColumn = pos.col;
            } else {
              endLine = end.line;
              endColumn = end.column;
            }
          } else if (!column) {
            let pos = this.fromOffset(line);
            line = pos.line;
            column = pos.col;
          }
          let origin = this.origin(line, column, endLine, endColumn);
          if (origin) {
            result = new CssSyntaxError2(
              message,
              origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
              origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
              origin.source,
              origin.file,
              opts.plugin
            );
          } else {
            result = new CssSyntaxError2(
              message,
              endLine === void 0 ? line : { column, line },
              endLine === void 0 ? column : { column: endColumn, line: endLine },
              this.css,
              this.file,
              opts.plugin
            );
          }
          result.input = { column, endColumn, endLine, line, source: this.css };
          if (this.file) {
            if (pathToFileURL) {
              result.input.url = pathToFileURL(this.file).toString();
            }
            result.input.file = this.file;
          }
          return result;
        }
        fromOffset(offset) {
          let lastLine, lineToIndex;
          if (!this[fromOffsetCache]) {
            let lines = this.css.split("\n");
            lineToIndex = new Array(lines.length);
            let prevIndex = 0;
            for (let i = 0, l = lines.length; i < l; i++) {
              lineToIndex[i] = prevIndex;
              prevIndex += lines[i].length + 1;
            }
            this[fromOffsetCache] = lineToIndex;
          } else {
            lineToIndex = this[fromOffsetCache];
          }
          lastLine = lineToIndex[lineToIndex.length - 1];
          let min = 0;
          if (offset >= lastLine) {
            min = lineToIndex.length - 1;
          } else {
            let max2 = lineToIndex.length - 2;
            let mid;
            while (min < max2) {
              mid = min + (max2 - min >> 1);
              if (offset < lineToIndex[mid]) {
                max2 = mid - 1;
              } else if (offset >= lineToIndex[mid + 1]) {
                min = mid + 1;
              } else {
                min = mid;
                break;
              }
            }
          }
          return {
            col: offset - lineToIndex[min] + 1,
            line: min + 1
          };
        }
        mapResolve(file) {
          if (/^\w+:\/\//.test(file)) {
            return file;
          }
          return resolve2(this.map.consumer().sourceRoot || this.map.root || ".", file);
        }
        origin(line, column, endLine, endColumn) {
          if (!this.map)
            return false;
          let consumer = this.map.consumer();
          let from = consumer.originalPositionFor({ column, line });
          if (!from.source)
            return false;
          let to;
          if (typeof endLine === "number") {
            to = consumer.originalPositionFor({ column: endColumn, line: endLine });
          }
          let fromUrl;
          if (isAbsolute(from.source)) {
            fromUrl = pathToFileURL(from.source);
          } else {
            fromUrl = new URL(
              from.source,
              this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
            );
          }
          let result = {
            column: from.column,
            endColumn: to && to.column,
            endLine: to && to.line,
            line: from.line,
            url: fromUrl.toString()
          };
          if (fromUrl.protocol === "file:") {
            if (fileURLToPath) {
              result.file = fileURLToPath(fromUrl);
            } else {
              throw new Error(`file: protocol is not available in this PostCSS build`);
            }
          }
          let source = consumer.sourceContentFor(from.source);
          if (source)
            result.source = source;
          return result;
        }
        toJSON() {
          let json = {};
          for (let name of ["hasBOM", "css", "file", "id"]) {
            if (this[name] != null) {
              json[name] = this[name];
            }
          }
          if (this.map) {
            json.map = { ...this.map };
            if (json.map.consumerCache) {
              json.map.consumerCache = void 0;
            }
          }
          return json;
        }
        get from() {
          return this.file || this.id;
        }
      };
      module.exports = Input2;
      Input2.default = Input2;
      if (terminalHighlight && terminalHighlight.registerInput) {
        terminalHighlight.registerInput(Input2);
      }
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/map-generator.js
  var require_map_generator = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/map-generator.js"(exports, module) {
      "use strict";
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { dirname: dirname2, relative: relative2, resolve: resolve2, sep: sep2 } = require_path();
      var { pathToFileURL } = require_url();
      var Input2 = require_input();
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(dirname2 && resolve2 && relative2 && sep2);
      var MapGenerator = class {
        constructor(stringify2, root2, opts, cssString) {
          this.stringify = stringify2;
          this.mapOpts = opts.map || {};
          this.root = root2;
          this.opts = opts;
          this.css = cssString;
          this.originalCSS = cssString;
          this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
          this.memoizedFileURLs = /* @__PURE__ */ new Map();
          this.memoizedPaths = /* @__PURE__ */ new Map();
          this.memoizedURLs = /* @__PURE__ */ new Map();
        }
        addAnnotation() {
          let content;
          if (this.isInline()) {
            content = "data:application/json;base64," + this.toBase64(this.map.toString());
          } else if (typeof this.mapOpts.annotation === "string") {
            content = this.mapOpts.annotation;
          } else if (typeof this.mapOpts.annotation === "function") {
            content = this.mapOpts.annotation(this.opts.to, this.root);
          } else {
            content = this.outputFile() + ".map";
          }
          let eol = "\n";
          if (this.css.includes("\r\n"))
            eol = "\r\n";
          this.css += eol + "/*# sourceMappingURL=" + content + " */";
        }
        applyPrevMaps() {
          for (let prev of this.previous()) {
            let from = this.toUrl(this.path(prev.file));
            let root2 = prev.root || dirname2(prev.file);
            let map;
            if (this.mapOpts.sourcesContent === false) {
              map = new SourceMapConsumer(prev.text);
              if (map.sourcesContent) {
                map.sourcesContent = null;
              }
            } else {
              map = prev.consumer();
            }
            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
          }
        }
        clearAnnotation() {
          if (this.mapOpts.annotation === false)
            return;
          if (this.root) {
            let node;
            for (let i = this.root.nodes.length - 1; i >= 0; i--) {
              node = this.root.nodes[i];
              if (node.type !== "comment")
                continue;
              if (node.text.indexOf("# sourceMappingURL=") === 0) {
                this.root.removeChild(i);
              }
            }
          } else if (this.css) {
            this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
          }
        }
        generate() {
          this.clearAnnotation();
          if (pathAvailable && sourceMapAvailable && this.isMap()) {
            return this.generateMap();
          } else {
            let result = "";
            this.stringify(this.root, (i) => {
              result += i;
            });
            return [result];
          }
        }
        generateMap() {
          if (this.root) {
            this.generateString();
          } else if (this.previous().length === 1) {
            let prev = this.previous()[0].consumer();
            prev.file = this.outputFile();
            this.map = SourceMapGenerator.fromSourceMap(prev, {
              ignoreInvalidMapping: true
            });
          } else {
            this.map = new SourceMapGenerator({
              file: this.outputFile(),
              ignoreInvalidMapping: true
            });
            this.map.addMapping({
              generated: { column: 0, line: 1 },
              original: { column: 0, line: 1 },
              source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
            });
          }
          if (this.isSourcesContent())
            this.setSourcesContent();
          if (this.root && this.previous().length > 0)
            this.applyPrevMaps();
          if (this.isAnnotation())
            this.addAnnotation();
          if (this.isInline()) {
            return [this.css];
          } else {
            return [this.css, this.map];
          }
        }
        generateString() {
          this.css = "";
          this.map = new SourceMapGenerator({
            file: this.outputFile(),
            ignoreInvalidMapping: true
          });
          let line = 1;
          let column = 1;
          let noSource = "<no source>";
          let mapping = {
            generated: { column: 0, line: 0 },
            original: { column: 0, line: 0 },
            source: ""
          };
          let lines, last;
          this.stringify(this.root, (str, node, type) => {
            this.css += str;
            if (node && type !== "end") {
              mapping.generated.line = line;
              mapping.generated.column = column - 1;
              if (node.source && node.source.start) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.start.line;
                mapping.original.column = node.source.start.column - 1;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                this.map.addMapping(mapping);
              }
            }
            lines = str.match(/\n/g);
            if (lines) {
              line += lines.length;
              last = str.lastIndexOf("\n");
              column = str.length - last;
            } else {
              column += str.length;
            }
            if (node && type !== "start") {
              let p2 = node.parent || { raws: {} };
              let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
              if (!childless || node !== p2.last || p2.raws.semicolon) {
                if (node.source && node.source.end) {
                  mapping.source = this.sourcePath(node);
                  mapping.original.line = node.source.end.line;
                  mapping.original.column = node.source.end.column - 1;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 2;
                  this.map.addMapping(mapping);
                } else {
                  mapping.source = noSource;
                  mapping.original.line = 1;
                  mapping.original.column = 0;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 1;
                  this.map.addMapping(mapping);
                }
              }
            }
          });
        }
        isAnnotation() {
          if (this.isInline()) {
            return true;
          }
          if (typeof this.mapOpts.annotation !== "undefined") {
            return this.mapOpts.annotation;
          }
          if (this.previous().length) {
            return this.previous().some((i) => i.annotation);
          }
          return true;
        }
        isInline() {
          if (typeof this.mapOpts.inline !== "undefined") {
            return this.mapOpts.inline;
          }
          let annotation = this.mapOpts.annotation;
          if (typeof annotation !== "undefined" && annotation !== true) {
            return false;
          }
          if (this.previous().length) {
            return this.previous().some((i) => i.inline);
          }
          return true;
        }
        isMap() {
          if (typeof this.opts.map !== "undefined") {
            return !!this.opts.map;
          }
          return this.previous().length > 0;
        }
        isSourcesContent() {
          if (typeof this.mapOpts.sourcesContent !== "undefined") {
            return this.mapOpts.sourcesContent;
          }
          if (this.previous().length) {
            return this.previous().some((i) => i.withContent());
          }
          return true;
        }
        outputFile() {
          if (this.opts.to) {
            return this.path(this.opts.to);
          } else if (this.opts.from) {
            return this.path(this.opts.from);
          } else {
            return "to.css";
          }
        }
        path(file) {
          if (this.mapOpts.absolute)
            return file;
          if (file.charCodeAt(0) === 60)
            return file;
          if (/^\w+:\/\//.test(file))
            return file;
          let cached = this.memoizedPaths.get(file);
          if (cached)
            return cached;
          let from = this.opts.to ? dirname2(this.opts.to) : ".";
          if (typeof this.mapOpts.annotation === "string") {
            from = dirname2(resolve2(from, this.mapOpts.annotation));
          }
          let path = relative2(from, file);
          this.memoizedPaths.set(file, path);
          return path;
        }
        previous() {
          if (!this.previousMaps) {
            this.previousMaps = [];
            if (this.root) {
              this.root.walk((node) => {
                if (node.source && node.source.input.map) {
                  let map = node.source.input.map;
                  if (!this.previousMaps.includes(map)) {
                    this.previousMaps.push(map);
                  }
                }
              });
            } else {
              let input = new Input2(this.originalCSS, this.opts);
              if (input.map)
                this.previousMaps.push(input.map);
            }
          }
          return this.previousMaps;
        }
        setSourcesContent() {
          let already = {};
          if (this.root) {
            this.root.walk((node) => {
              if (node.source) {
                let from = node.source.input.from;
                if (from && !already[from]) {
                  already[from] = true;
                  let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
                  this.map.setSourceContent(fromUrl, node.source.input.css);
                }
              }
            });
          } else if (this.css) {
            let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
            this.map.setSourceContent(from, this.css);
          }
        }
        sourcePath(node) {
          if (this.mapOpts.from) {
            return this.toUrl(this.mapOpts.from);
          } else if (this.usesFileUrls) {
            return this.toFileUrl(node.source.input.from);
          } else {
            return this.toUrl(this.path(node.source.input.from));
          }
        }
        toBase64(str) {
          if (Buffer) {
            return Buffer.from(str).toString("base64");
          } else {
            return window.btoa(unescape(encodeURIComponent(str)));
          }
        }
        toFileUrl(path) {
          let cached = this.memoizedFileURLs.get(path);
          if (cached)
            return cached;
          if (pathToFileURL) {
            let fileURL = pathToFileURL(path).toString();
            this.memoizedFileURLs.set(path, fileURL);
            return fileURL;
          } else {
            throw new Error(
              "`map.absolute` option is not available in this PostCSS build"
            );
          }
        }
        toUrl(path) {
          let cached = this.memoizedURLs.get(path);
          if (cached)
            return cached;
          if (sep2 === "\\") {
            path = path.replace(/\\/g, "/");
          }
          let url2 = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
          this.memoizedURLs.set(path, url2);
          return url2;
        }
      };
      module.exports = MapGenerator;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/comment.js
  var require_comment = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/comment.js"(exports, module) {
      "use strict";
      var Node3 = require_node();
      var Comment2 = class extends Node3 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "comment";
        }
      };
      module.exports = Comment2;
      Comment2.default = Comment2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/container.js
  var require_container = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/container.js"(exports, module) {
      "use strict";
      var { isClean, my } = require_symbols();
      var Declaration2 = require_declaration();
      var Comment2 = require_comment();
      var Node3 = require_node();
      var parse4;
      var Rule2;
      var AtRule2;
      var Root2;
      function cleanSource(nodes) {
        return nodes.map((i) => {
          if (i.nodes)
            i.nodes = cleanSource(i.nodes);
          delete i.source;
          return i;
        });
      }
      function markDirtyUp(node) {
        node[isClean] = false;
        if (node.proxyOf.nodes) {
          for (let i of node.proxyOf.nodes) {
            markDirtyUp(i);
          }
        }
      }
      var Container2 = class _Container extends Node3 {
        append(...children) {
          for (let child of children) {
            let nodes = this.normalize(child, this.last);
            for (let node of nodes)
              this.proxyOf.nodes.push(node);
          }
          this.markDirty();
          return this;
        }
        cleanRaws(keepBetween) {
          super.cleanRaws(keepBetween);
          if (this.nodes) {
            for (let node of this.nodes)
              node.cleanRaws(keepBetween);
          }
        }
        each(callback) {
          if (!this.proxyOf.nodes)
            return void 0;
          let iterator = this.getIterator();
          let index2, result;
          while (this.indexes[iterator] < this.proxyOf.nodes.length) {
            index2 = this.indexes[iterator];
            result = callback(this.proxyOf.nodes[index2], index2);
            if (result === false)
              break;
            this.indexes[iterator] += 1;
          }
          delete this.indexes[iterator];
          return result;
        }
        every(condition) {
          return this.nodes.every(condition);
        }
        getIterator() {
          if (!this.lastEach)
            this.lastEach = 0;
          if (!this.indexes)
            this.indexes = {};
          this.lastEach += 1;
          let iterator = this.lastEach;
          this.indexes[iterator] = 0;
          return iterator;
        }
        getProxyProcessor() {
          return {
            get(node, prop) {
              if (prop === "proxyOf") {
                return node;
              } else if (!node[prop]) {
                return node[prop];
              } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
                return (...args) => {
                  return node[prop](
                    ...args.map((i) => {
                      if (typeof i === "function") {
                        return (child, index2) => i(child.toProxy(), index2);
                      } else {
                        return i;
                      }
                    })
                  );
                };
              } else if (prop === "every" || prop === "some") {
                return (cb) => {
                  return node[prop](
                    (child, ...other) => cb(child.toProxy(), ...other)
                  );
                };
              } else if (prop === "root") {
                return () => node.root().toProxy();
              } else if (prop === "nodes") {
                return node.nodes.map((i) => i.toProxy());
              } else if (prop === "first" || prop === "last") {
                return node[prop].toProxy();
              } else {
                return node[prop];
              }
            },
            set(node, prop, value2) {
              if (node[prop] === value2)
                return true;
              node[prop] = value2;
              if (prop === "name" || prop === "params" || prop === "selector") {
                node.markDirty();
              }
              return true;
            }
          };
        }
        index(child) {
          if (typeof child === "number")
            return child;
          if (child.proxyOf)
            child = child.proxyOf;
          return this.proxyOf.nodes.indexOf(child);
        }
        insertAfter(exist, add) {
          let existIndex = this.index(exist);
          let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
          existIndex = this.index(exist);
          for (let node of nodes)
            this.proxyOf.nodes.splice(existIndex + 1, 0, node);
          let index2;
          for (let id in this.indexes) {
            index2 = this.indexes[id];
            if (existIndex < index2) {
              this.indexes[id] = index2 + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        insertBefore(exist, add) {
          let existIndex = this.index(exist);
          let type = existIndex === 0 ? "prepend" : false;
          let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
          existIndex = this.index(exist);
          for (let node of nodes)
            this.proxyOf.nodes.splice(existIndex, 0, node);
          let index2;
          for (let id in this.indexes) {
            index2 = this.indexes[id];
            if (existIndex <= index2) {
              this.indexes[id] = index2 + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        normalize(nodes, sample) {
          if (typeof nodes === "string") {
            nodes = cleanSource(parse4(nodes).nodes);
          } else if (typeof nodes === "undefined") {
            nodes = [];
          } else if (Array.isArray(nodes)) {
            nodes = nodes.slice(0);
            for (let i of nodes) {
              if (i.parent)
                i.parent.removeChild(i, "ignore");
            }
          } else if (nodes.type === "root" && this.type !== "document") {
            nodes = nodes.nodes.slice(0);
            for (let i of nodes) {
              if (i.parent)
                i.parent.removeChild(i, "ignore");
            }
          } else if (nodes.type) {
            nodes = [nodes];
          } else if (nodes.prop) {
            if (typeof nodes.value === "undefined") {
              throw new Error("Value field is missed in node creation");
            } else if (typeof nodes.value !== "string") {
              nodes.value = String(nodes.value);
            }
            nodes = [new Declaration2(nodes)];
          } else if (nodes.selector) {
            nodes = [new Rule2(nodes)];
          } else if (nodes.name) {
            nodes = [new AtRule2(nodes)];
          } else if (nodes.text) {
            nodes = [new Comment2(nodes)];
          } else {
            throw new Error("Unknown node type in node creation");
          }
          let processed = nodes.map((i) => {
            if (!i[my])
              _Container.rebuild(i);
            i = i.proxyOf;
            if (i.parent)
              i.parent.removeChild(i);
            if (i[isClean])
              markDirtyUp(i);
            if (typeof i.raws.before === "undefined") {
              if (sample && typeof sample.raws.before !== "undefined") {
                i.raws.before = sample.raws.before.replace(/\S/g, "");
              }
            }
            i.parent = this.proxyOf;
            return i;
          });
          return processed;
        }
        prepend(...children) {
          children = children.reverse();
          for (let child of children) {
            let nodes = this.normalize(child, this.first, "prepend").reverse();
            for (let node of nodes)
              this.proxyOf.nodes.unshift(node);
            for (let id in this.indexes) {
              this.indexes[id] = this.indexes[id] + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        push(child) {
          child.parent = this;
          this.proxyOf.nodes.push(child);
          return this;
        }
        removeAll() {
          for (let node of this.proxyOf.nodes)
            node.parent = void 0;
          this.proxyOf.nodes = [];
          this.markDirty();
          return this;
        }
        removeChild(child) {
          child = this.index(child);
          this.proxyOf.nodes[child].parent = void 0;
          this.proxyOf.nodes.splice(child, 1);
          let index2;
          for (let id in this.indexes) {
            index2 = this.indexes[id];
            if (index2 >= child) {
              this.indexes[id] = index2 - 1;
            }
          }
          this.markDirty();
          return this;
        }
        replaceValues(pattern2, opts, callback) {
          if (!callback) {
            callback = opts;
            opts = {};
          }
          this.walkDecls((decl2) => {
            if (opts.props && !opts.props.includes(decl2.prop))
              return;
            if (opts.fast && !decl2.value.includes(opts.fast))
              return;
            decl2.value = decl2.value.replace(pattern2, callback);
          });
          this.markDirty();
          return this;
        }
        some(condition) {
          return this.nodes.some(condition);
        }
        walk(callback) {
          return this.each((child, i) => {
            let result;
            try {
              result = callback(child, i);
            } catch (e2) {
              throw child.addToError(e2);
            }
            if (result !== false && child.walk) {
              result = child.walk(callback);
            }
            return result;
          });
        }
        walkAtRules(name, callback) {
          if (!callback) {
            callback = name;
            return this.walk((child, i) => {
              if (child.type === "atrule") {
                return callback(child, i);
              }
            });
          }
          if (name instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === "atrule" && name.test(child.name)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === "atrule" && child.name === name) {
              return callback(child, i);
            }
          });
        }
        walkComments(callback) {
          return this.walk((child, i) => {
            if (child.type === "comment") {
              return callback(child, i);
            }
          });
        }
        walkDecls(prop, callback) {
          if (!callback) {
            callback = prop;
            return this.walk((child, i) => {
              if (child.type === "decl") {
                return callback(child, i);
              }
            });
          }
          if (prop instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === "decl" && prop.test(child.prop)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === "decl" && child.prop === prop) {
              return callback(child, i);
            }
          });
        }
        walkRules(selector, callback) {
          if (!callback) {
            callback = selector;
            return this.walk((child, i) => {
              if (child.type === "rule") {
                return callback(child, i);
              }
            });
          }
          if (selector instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === "rule" && selector.test(child.selector)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === "rule" && child.selector === selector) {
              return callback(child, i);
            }
          });
        }
        get first() {
          if (!this.proxyOf.nodes)
            return void 0;
          return this.proxyOf.nodes[0];
        }
        get last() {
          if (!this.proxyOf.nodes)
            return void 0;
          return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }
      };
      Container2.registerParse = (dependant) => {
        parse4 = dependant;
      };
      Container2.registerRule = (dependant) => {
        Rule2 = dependant;
      };
      Container2.registerAtRule = (dependant) => {
        AtRule2 = dependant;
      };
      Container2.registerRoot = (dependant) => {
        Root2 = dependant;
      };
      module.exports = Container2;
      Container2.default = Container2;
      Container2.rebuild = (node) => {
        if (node.type === "atrule") {
          Object.setPrototypeOf(node, AtRule2.prototype);
        } else if (node.type === "rule") {
          Object.setPrototypeOf(node, Rule2.prototype);
        } else if (node.type === "decl") {
          Object.setPrototypeOf(node, Declaration2.prototype);
        } else if (node.type === "comment") {
          Object.setPrototypeOf(node, Comment2.prototype);
        } else if (node.type === "root") {
          Object.setPrototypeOf(node, Root2.prototype);
        }
        node[my] = true;
        if (node.nodes) {
          node.nodes.forEach((child) => {
            Container2.rebuild(child);
          });
        }
      };
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/document.js
  var require_document = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/document.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var LazyResult;
      var Processor2;
      var Document2 = class extends Container2 {
        constructor(defaults3) {
          super({ type: "document", ...defaults3 });
          if (!this.nodes) {
            this.nodes = [];
          }
        }
        toResult(opts = {}) {
          let lazy2 = new LazyResult(new Processor2(), this, opts);
          return lazy2.stringify();
        }
      };
      Document2.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Document2.registerProcessor = (dependant) => {
        Processor2 = dependant;
      };
      module.exports = Document2;
      Document2.default = Document2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/warn-once.js
  var require_warn_once = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/warn-once.js"(exports, module) {
      "use strict";
      var printed = {};
      module.exports = function warnOnce(message) {
        if (printed[message])
          return;
        printed[message] = true;
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
      };
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/warning.js
  var require_warning = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/warning.js"(exports, module) {
      "use strict";
      var Warning2 = class {
        constructor(text2, opts = {}) {
          this.type = "warning";
          this.text = text2;
          if (opts.node && opts.node.source) {
            let range = opts.node.rangeBy(opts);
            this.line = range.start.line;
            this.column = range.start.column;
            this.endLine = range.end.line;
            this.endColumn = range.end.column;
          }
          for (let opt in opts)
            this[opt] = opts[opt];
        }
        toString() {
          if (this.node) {
            return this.node.error(this.text, {
              index: this.index,
              plugin: this.plugin,
              word: this.word
            }).message;
          }
          if (this.plugin) {
            return this.plugin + ": " + this.text;
          }
          return this.text;
        }
      };
      module.exports = Warning2;
      Warning2.default = Warning2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/result.js
  var require_result = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/result.js"(exports, module) {
      "use strict";
      var Warning2 = require_warning();
      var Result2 = class {
        constructor(processor, root2, opts) {
          this.processor = processor;
          this.messages = [];
          this.root = root2;
          this.opts = opts;
          this.css = void 0;
          this.map = void 0;
        }
        toString() {
          return this.css;
        }
        warn(text2, opts = {}) {
          if (!opts.plugin) {
            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
              opts.plugin = this.lastPlugin.postcssPlugin;
            }
          }
          let warning = new Warning2(text2, opts);
          this.messages.push(warning);
          return warning;
        }
        warnings() {
          return this.messages.filter((i) => i.type === "warning");
        }
        get content() {
          return this.css;
        }
      };
      module.exports = Result2;
      Result2.default = Result2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/tokenize.js
  var require_tokenize = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/tokenize.js"(exports, module) {
      "use strict";
      var SINGLE_QUOTE = "'".charCodeAt(0);
      var DOUBLE_QUOTE = '"'.charCodeAt(0);
      var BACKSLASH = "\\".charCodeAt(0);
      var SLASH = "/".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var SPACE3 = " ".charCodeAt(0);
      var FEED = "\f".charCodeAt(0);
      var TAB = "	".charCodeAt(0);
      var CR = "\r".charCodeAt(0);
      var OPEN_SQUARE = "[".charCodeAt(0);
      var CLOSE_SQUARE = "]".charCodeAt(0);
      var OPEN_PARENTHESES = "(".charCodeAt(0);
      var CLOSE_PARENTHESES = ")".charCodeAt(0);
      var OPEN_CURLY = "{".charCodeAt(0);
      var CLOSE_CURLY = "}".charCodeAt(0);
      var SEMICOLON = ";".charCodeAt(0);
      var ASTERISK = "*".charCodeAt(0);
      var COLON = ":".charCodeAt(0);
      var AT = "@".charCodeAt(0);
      var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
      var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
      var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
      var RE_HEX_ESCAPE = /[\da-f]/i;
      module.exports = function tokenizer(input, options = {}) {
        let css = input.css.valueOf();
        let ignore = options.ignoreErrors;
        let code, next, quote, content, escape2;
        let escaped, escapePos, prev, n2, currentToken;
        let length2 = css.length;
        let pos = 0;
        let buffer = [];
        let returned = [];
        function position2() {
          return pos;
        }
        function unclosed(what) {
          throw input.error("Unclosed " + what, pos);
        }
        function endOfFile() {
          return returned.length === 0 && pos >= length2;
        }
        function nextToken(opts) {
          if (returned.length)
            return returned.pop();
          if (pos >= length2)
            return;
          let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
          code = css.charCodeAt(pos);
          switch (code) {
            case NEWLINE:
            case SPACE3:
            case TAB:
            case CR:
            case FEED: {
              next = pos;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === SPACE3 || code === NEWLINE || code === TAB || code === CR || code === FEED);
              currentToken = ["space", css.slice(pos, next)];
              pos = next - 1;
              break;
            }
            case OPEN_SQUARE:
            case CLOSE_SQUARE:
            case OPEN_CURLY:
            case CLOSE_CURLY:
            case COLON:
            case SEMICOLON:
            case CLOSE_PARENTHESES: {
              let controlChar = String.fromCharCode(code);
              currentToken = [controlChar, controlChar, pos];
              break;
            }
            case OPEN_PARENTHESES: {
              prev = buffer.length ? buffer.pop()[1] : "";
              n2 = css.charCodeAt(pos + 1);
              if (prev === "url" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE3 && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {
                next = pos;
                do {
                  escaped = false;
                  next = css.indexOf(")", next + 1);
                  if (next === -1) {
                    if (ignore || ignoreUnclosed) {
                      next = pos;
                      break;
                    } else {
                      unclosed("bracket");
                    }
                  }
                  escapePos = next;
                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);
                currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
                pos = next;
              } else {
                next = css.indexOf(")", pos + 1);
                content = css.slice(pos, next + 1);
                if (next === -1 || RE_BAD_BRACKET.test(content)) {
                  currentToken = ["(", "(", pos];
                } else {
                  currentToken = ["brackets", content, pos, next];
                  pos = next;
                }
              }
              break;
            }
            case SINGLE_QUOTE:
            case DOUBLE_QUOTE: {
              quote = code === SINGLE_QUOTE ? "'" : '"';
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos + 1;
                    break;
                  } else {
                    unclosed("string");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["string", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            case AT: {
              RE_AT_END.lastIndex = pos + 1;
              RE_AT_END.test(css);
              if (RE_AT_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_AT_END.lastIndex - 2;
              }
              currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            case BACKSLASH: {
              next = pos;
              escape2 = true;
              while (css.charCodeAt(next + 1) === BACKSLASH) {
                next += 1;
                escape2 = !escape2;
              }
              code = css.charCodeAt(next + 1);
              if (escape2 && code !== SLASH && code !== SPACE3 && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
                next += 1;
                if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                  while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                    next += 1;
                  }
                  if (css.charCodeAt(next + 1) === SPACE3) {
                    next += 1;
                  }
                }
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            default: {
              if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                next = css.indexOf("*/", pos + 2) + 1;
                if (next === 0) {
                  if (ignore || ignoreUnclosed) {
                    next = css.length;
                  } else {
                    unclosed("comment");
                  }
                }
                currentToken = ["comment", css.slice(pos, next + 1), pos, next];
                pos = next;
              } else {
                RE_WORD_END.lastIndex = pos + 1;
                RE_WORD_END.test(css);
                if (RE_WORD_END.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_WORD_END.lastIndex - 2;
                }
                currentToken = ["word", css.slice(pos, next + 1), pos, next];
                buffer.push(currentToken);
                pos = next;
              }
              break;
            }
          }
          pos++;
          return currentToken;
        }
        function back(token) {
          returned.push(token);
        }
        return {
          back,
          endOfFile,
          nextToken,
          position: position2
        };
      };
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/at-rule.js
  var require_at_rule = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/at-rule.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var AtRule2 = class extends Container2 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "atrule";
        }
        append(...children) {
          if (!this.proxyOf.nodes)
            this.nodes = [];
          return super.append(...children);
        }
        prepend(...children) {
          if (!this.proxyOf.nodes)
            this.nodes = [];
          return super.prepend(...children);
        }
      };
      module.exports = AtRule2;
      AtRule2.default = AtRule2;
      Container2.registerAtRule(AtRule2);
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/root.js
  var require_root = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/root.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var LazyResult;
      var Processor2;
      var Root2 = class extends Container2 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "root";
          if (!this.nodes)
            this.nodes = [];
        }
        normalize(child, sample, type) {
          let nodes = super.normalize(child);
          if (sample) {
            if (type === "prepend") {
              if (this.nodes.length > 1) {
                sample.raws.before = this.nodes[1].raws.before;
              } else {
                delete sample.raws.before;
              }
            } else if (this.first !== sample) {
              for (let node of nodes) {
                node.raws.before = sample.raws.before;
              }
            }
          }
          return nodes;
        }
        removeChild(child, ignore) {
          let index2 = this.index(child);
          if (!ignore && index2 === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[index2].raws.before;
          }
          return super.removeChild(child);
        }
        toResult(opts = {}) {
          let lazy2 = new LazyResult(new Processor2(), this, opts);
          return lazy2.stringify();
        }
      };
      Root2.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Root2.registerProcessor = (dependant) => {
        Processor2 = dependant;
      };
      module.exports = Root2;
      Root2.default = Root2;
      Container2.registerRoot(Root2);
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/list.js
  var require_list = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/list.js"(exports, module) {
      "use strict";
      var list3 = {
        comma(string) {
          return list3.split(string, [","], true);
        },
        space(string) {
          let spaces = [" ", "\n", "	"];
          return list3.split(string, spaces);
        },
        split(string, separators, last) {
          let array = [];
          let current = "";
          let split = false;
          let func = 0;
          let inQuote = false;
          let prevQuote = "";
          let escape2 = false;
          for (let letter of string) {
            if (escape2) {
              escape2 = false;
            } else if (letter === "\\") {
              escape2 = true;
            } else if (inQuote) {
              if (letter === prevQuote) {
                inQuote = false;
              }
            } else if (letter === '"' || letter === "'") {
              inQuote = true;
              prevQuote = letter;
            } else if (letter === "(") {
              func += 1;
            } else if (letter === ")") {
              if (func > 0)
                func -= 1;
            } else if (func === 0) {
              if (separators.includes(letter))
                split = true;
            }
            if (split) {
              if (current !== "")
                array.push(current.trim());
              current = "";
              split = false;
            } else {
              current += letter;
            }
          }
          if (last || current !== "")
            array.push(current.trim());
          return array;
        }
      };
      module.exports = list3;
      list3.default = list3;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/rule.js
  var require_rule = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/rule.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var list3 = require_list();
      var Rule2 = class extends Container2 {
        constructor(defaults3) {
          super(defaults3);
          this.type = "rule";
          if (!this.nodes)
            this.nodes = [];
        }
        get selectors() {
          return list3.comma(this.selector);
        }
        set selectors(values) {
          let match = this.selector ? this.selector.match(/,\s*/) : null;
          let sep2 = match ? match[0] : "," + this.raw("between", "beforeOpen");
          this.selector = values.join(sep2);
        }
      };
      module.exports = Rule2;
      Rule2.default = Rule2;
      Container2.registerRule(Rule2);
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/parser.js
  var require_parser = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/parser.js"(exports, module) {
      "use strict";
      var Declaration2 = require_declaration();
      var tokenizer = require_tokenize();
      var Comment2 = require_comment();
      var AtRule2 = require_at_rule();
      var Root2 = require_root();
      var Rule2 = require_rule();
      var SAFE_COMMENT_NEIGHBOR = {
        empty: true,
        space: true
      };
      function findLastWithPosition(tokens) {
        for (let i = tokens.length - 1; i >= 0; i--) {
          let token = tokens[i];
          let pos = token[3] || token[2];
          if (pos)
            return pos;
        }
      }
      var Parser = class {
        constructor(input) {
          this.input = input;
          this.root = new Root2();
          this.current = this.root;
          this.spaces = "";
          this.semicolon = false;
          this.createTokenizer();
          this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
        }
        atrule(token) {
          let node = new AtRule2();
          node.name = token[1].slice(1);
          if (node.name === "") {
            this.unnamedAtrule(node, token);
          }
          this.init(node, token[2]);
          let type;
          let prev;
          let shift;
          let last = false;
          let open = false;
          let params = [];
          let brackets = [];
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            type = token[0];
            if (type === "(" || type === "[") {
              brackets.push(type === "(" ? ")" : "]");
            } else if (type === "{" && brackets.length > 0) {
              brackets.push("}");
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
            }
            if (brackets.length === 0) {
              if (type === ";") {
                node.source.end = this.getPosition(token[2]);
                node.source.end.offset++;
                this.semicolon = true;
                break;
              } else if (type === "{") {
                open = true;
                break;
              } else if (type === "}") {
                if (params.length > 0) {
                  shift = params.length - 1;
                  prev = params[shift];
                  while (prev && prev[0] === "space") {
                    prev = params[--shift];
                  }
                  if (prev) {
                    node.source.end = this.getPosition(prev[3] || prev[2]);
                    node.source.end.offset++;
                  }
                }
                this.end(token);
                break;
              } else {
                params.push(token);
              }
            } else {
              params.push(token);
            }
            if (this.tokenizer.endOfFile()) {
              last = true;
              break;
            }
          }
          node.raws.between = this.spacesAndCommentsFromEnd(params);
          if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, "params", params);
            if (last) {
              token = params[params.length - 1];
              node.source.end = this.getPosition(token[3] || token[2]);
              node.source.end.offset++;
              this.spaces = node.raws.between;
              node.raws.between = "";
            }
          } else {
            node.raws.afterName = "";
            node.params = "";
          }
          if (open) {
            node.nodes = [];
            this.current = node;
          }
        }
        checkMissedSemicolon(tokens) {
          let colon = this.colon(tokens);
          if (colon === false)
            return;
          let founded = 0;
          let token;
          for (let j = colon - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== "space") {
              founded += 1;
              if (founded === 2)
                break;
            }
          }
          throw this.input.error(
            "Missed semicolon",
            token[0] === "word" ? token[3] + 1 : token[2]
          );
        }
        colon(tokens) {
          let brackets = 0;
          let token, type, prev;
          for (let [i, element] of tokens.entries()) {
            token = element;
            type = token[0];
            if (type === "(") {
              brackets += 1;
            }
            if (type === ")") {
              brackets -= 1;
            }
            if (brackets === 0 && type === ":") {
              if (!prev) {
                this.doubleColon(token);
              } else if (prev[0] === "word" && prev[1] === "progid") {
                continue;
              } else {
                return i;
              }
            }
            prev = token;
          }
          return false;
        }
        comment(token) {
          let node = new Comment2();
          this.init(node, token[2]);
          node.source.end = this.getPosition(token[3] || token[2]);
          node.source.end.offset++;
          let text2 = token[1].slice(2, -2);
          if (/^\s*$/.test(text2)) {
            node.text = "";
            node.raws.left = text2;
            node.raws.right = "";
          } else {
            let match = text2.match(/^(\s*)([^]*\S)(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
          }
        }
        createTokenizer() {
          this.tokenizer = tokenizer(this.input);
        }
        decl(tokens, customProperty) {
          let node = new Declaration2();
          this.init(node, tokens[0][2]);
          let last = tokens[tokens.length - 1];
          if (last[0] === ";") {
            this.semicolon = true;
            tokens.pop();
          }
          node.source.end = this.getPosition(
            last[3] || last[2] || findLastWithPosition(tokens)
          );
          node.source.end.offset++;
          while (tokens[0][0] !== "word") {
            if (tokens.length === 1)
              this.unknownWord(tokens);
            node.raws.before += tokens.shift()[1];
          }
          node.source.start = this.getPosition(tokens[0][2]);
          node.prop = "";
          while (tokens.length) {
            let type = tokens[0][0];
            if (type === ":" || type === "space" || type === "comment") {
              break;
            }
            node.prop += tokens.shift()[1];
          }
          node.raws.between = "";
          let token;
          while (tokens.length) {
            token = tokens.shift();
            if (token[0] === ":") {
              node.raws.between += token[1];
              break;
            } else {
              if (token[0] === "word" && /\w/.test(token[1])) {
                this.unknownWord([token]);
              }
              node.raws.between += token[1];
            }
          }
          if (node.prop[0] === "_" || node.prop[0] === "*") {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
          }
          let firstSpaces = [];
          let next;
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== "space" && next !== "comment")
              break;
            firstSpaces.push(tokens.shift());
          }
          this.precheckMissedSemicolon(tokens);
          for (let i = tokens.length - 1; i >= 0; i--) {
            token = tokens[i];
            if (token[1].toLowerCase() === "!important") {
              node.important = true;
              let string = this.stringFrom(tokens, i);
              string = this.spacesFromEnd(tokens) + string;
              if (string !== " !important")
                node.raws.important = string;
              break;
            } else if (token[1].toLowerCase() === "important") {
              let cache3 = tokens.slice(0);
              let str = "";
              for (let j = i; j > 0; j--) {
                let type = cache3[j][0];
                if (str.trim().indexOf("!") === 0 && type !== "space") {
                  break;
                }
                str = cache3.pop()[1] + str;
              }
              if (str.trim().indexOf("!") === 0) {
                node.important = true;
                node.raws.important = str;
                tokens = cache3;
              }
            }
            if (token[0] !== "space" && token[0] !== "comment") {
              break;
            }
          }
          let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
          if (hasWord) {
            node.raws.between += firstSpaces.map((i) => i[1]).join("");
            firstSpaces = [];
          }
          this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
          if (node.value.includes(":") && !customProperty) {
            this.checkMissedSemicolon(tokens);
          }
        }
        doubleColon(token) {
          throw this.input.error(
            "Double colon",
            { offset: token[2] },
            { offset: token[2] + token[1].length }
          );
        }
        emptyRule(token) {
          let node = new Rule2();
          this.init(node, token[2]);
          node.selector = "";
          node.raws.between = "";
          this.current = node;
        }
        end(token) {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.semicolon = false;
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.spaces = "";
          if (this.current.parent) {
            this.current.source.end = this.getPosition(token[2]);
            this.current.source.end.offset++;
            this.current = this.current.parent;
          } else {
            this.unexpectedClose(token);
          }
        }
        endFile() {
          if (this.current.parent)
            this.unclosedBlock();
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.root.source.end = this.getPosition(this.tokenizer.position());
        }
        freeSemicolon(token) {
          this.spaces += token[1];
          if (this.current.nodes) {
            let prev = this.current.nodes[this.current.nodes.length - 1];
            if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
              prev.raws.ownSemicolon = this.spaces;
              this.spaces = "";
            }
          }
        }
        // Helpers
        getPosition(offset) {
          let pos = this.input.fromOffset(offset);
          return {
            column: pos.col,
            line: pos.line,
            offset
          };
        }
        init(node, offset) {
          this.current.push(node);
          node.source = {
            input: this.input,
            start: this.getPosition(offset)
          };
          node.raws.before = this.spaces;
          this.spaces = "";
          if (node.type !== "comment")
            this.semicolon = false;
        }
        other(start) {
          let end = false;
          let type = null;
          let colon = false;
          let bracket = null;
          let brackets = [];
          let customProperty = start[1].startsWith("--");
          let tokens = [];
          let token = start;
          while (token) {
            type = token[0];
            tokens.push(token);
            if (type === "(" || type === "[") {
              if (!bracket)
                bracket = token;
              brackets.push(type === "(" ? ")" : "]");
            } else if (customProperty && colon && type === "{") {
              if (!bracket)
                bracket = token;
              brackets.push("}");
            } else if (brackets.length === 0) {
              if (type === ";") {
                if (colon) {
                  this.decl(tokens, customProperty);
                  return;
                } else {
                  break;
                }
              } else if (type === "{") {
                this.rule(tokens);
                return;
              } else if (type === "}") {
                this.tokenizer.back(tokens.pop());
                end = true;
                break;
              } else if (type === ":") {
                colon = true;
              }
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
              if (brackets.length === 0)
                bracket = null;
            }
            token = this.tokenizer.nextToken();
          }
          if (this.tokenizer.endOfFile())
            end = true;
          if (brackets.length > 0)
            this.unclosedBracket(bracket);
          if (end && colon) {
            if (!customProperty) {
              while (tokens.length) {
                token = tokens[tokens.length - 1][0];
                if (token !== "space" && token !== "comment")
                  break;
                this.tokenizer.back(tokens.pop());
              }
            }
            this.decl(tokens, customProperty);
          } else {
            this.unknownWord(tokens);
          }
        }
        parse() {
          let token;
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            switch (token[0]) {
              case "space":
                this.spaces += token[1];
                break;
              case ";":
                this.freeSemicolon(token);
                break;
              case "}":
                this.end(token);
                break;
              case "comment":
                this.comment(token);
                break;
              case "at-word":
                this.atrule(token);
                break;
              case "{":
                this.emptyRule(token);
                break;
              default:
                this.other(token);
                break;
            }
          }
          this.endFile();
        }
        precheckMissedSemicolon() {
        }
        raw(node, prop, tokens, customProperty) {
          let token, type;
          let length2 = tokens.length;
          let value2 = "";
          let clean = true;
          let next, prev;
          for (let i = 0; i < length2; i += 1) {
            token = tokens[i];
            type = token[0];
            if (type === "space" && i === length2 - 1 && !customProperty) {
              clean = false;
            } else if (type === "comment") {
              prev = tokens[i - 1] ? tokens[i - 1][0] : "empty";
              next = tokens[i + 1] ? tokens[i + 1][0] : "empty";
              if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
                if (value2.slice(-1) === ",") {
                  clean = false;
                } else {
                  value2 += token[1];
                }
              } else {
                clean = false;
              }
            } else {
              value2 += token[1];
            }
          }
          if (!clean) {
            let raw = tokens.reduce((all, i) => all + i[1], "");
            node.raws[prop] = { raw, value: value2 };
          }
          node[prop] = value2;
        }
        rule(tokens) {
          tokens.pop();
          let node = new Rule2();
          this.init(node, tokens[0][2]);
          node.raws.between = this.spacesAndCommentsFromEnd(tokens);
          this.raw(node, "selector", tokens);
          this.current = node;
        }
        spacesAndCommentsFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space" && lastTokenType !== "comment")
              break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        // Errors
        spacesAndCommentsFromStart(tokens) {
          let next;
          let spaces = "";
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== "space" && next !== "comment")
              break;
            spaces += tokens.shift()[1];
          }
          return spaces;
        }
        spacesFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space")
              break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        stringFrom(tokens, from) {
          let result = "";
          for (let i = from; i < tokens.length; i++) {
            result += tokens[i][1];
          }
          tokens.splice(from, tokens.length - from);
          return result;
        }
        unclosedBlock() {
          let pos = this.current.source.start;
          throw this.input.error("Unclosed block", pos.line, pos.column);
        }
        unclosedBracket(bracket) {
          throw this.input.error(
            "Unclosed bracket",
            { offset: bracket[2] },
            { offset: bracket[2] + 1 }
          );
        }
        unexpectedClose(token) {
          throw this.input.error(
            "Unexpected }",
            { offset: token[2] },
            { offset: token[2] + 1 }
          );
        }
        unknownWord(tokens) {
          throw this.input.error(
            "Unknown word",
            { offset: tokens[0][2] },
            { offset: tokens[0][2] + tokens[0][1].length }
          );
        }
        unnamedAtrule(node, token) {
          throw this.input.error(
            "At-rule without name",
            { offset: token[2] },
            { offset: token[2] + token[1].length }
          );
        }
      };
      module.exports = Parser;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/parse.js"(exports, module) {
      "use strict";
      var Container2 = require_container();
      var Parser = require_parser();
      var Input2 = require_input();
      function parse4(css, opts) {
        let input = new Input2(css, opts);
        let parser4 = new Parser(input);
        try {
          parser4.parse();
        } catch (e2) {
          if (true) {
            if (e2.name === "CssSyntaxError" && opts && opts.from) {
              if (/\.scss$/i.test(opts.from)) {
                e2.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
              } else if (/\.sass/i.test(opts.from)) {
                e2.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
              } else if (/\.less$/i.test(opts.from)) {
                e2.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
              }
            }
          }
          throw e2;
        }
        return parser4.root;
      }
      module.exports = parse4;
      parse4.default = parse4;
      Container2.registerParse(parse4);
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/lazy-result.js
  var require_lazy_result = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/lazy-result.js"(exports, module) {
      "use strict";
      var { isClean, my } = require_symbols();
      var MapGenerator = require_map_generator();
      var stringify2 = require_stringify();
      var Container2 = require_container();
      var Document2 = require_document();
      var warnOnce = require_warn_once();
      var Result2 = require_result();
      var parse4 = require_parse();
      var Root2 = require_root();
      var TYPE_TO_CLASS_NAME = {
        atrule: "AtRule",
        comment: "Comment",
        decl: "Declaration",
        document: "Document",
        root: "Root",
        rule: "Rule"
      };
      var PLUGIN_PROPS = {
        AtRule: true,
        AtRuleExit: true,
        Comment: true,
        CommentExit: true,
        Declaration: true,
        DeclarationExit: true,
        Document: true,
        DocumentExit: true,
        Once: true,
        OnceExit: true,
        postcssPlugin: true,
        prepare: true,
        Root: true,
        RootExit: true,
        Rule: true,
        RuleExit: true
      };
      var NOT_VISITORS = {
        Once: true,
        postcssPlugin: true,
        prepare: true
      };
      var CHILDREN = 0;
      function isPromise(obj) {
        return typeof obj === "object" && typeof obj.then === "function";
      }
      function getEvents(node) {
        let key = false;
        let type = TYPE_TO_CLASS_NAME[node.type];
        if (node.type === "decl") {
          key = node.prop.toLowerCase();
        } else if (node.type === "atrule") {
          key = node.name.toLowerCase();
        }
        if (key && node.append) {
          return [
            type,
            type + "-" + key,
            CHILDREN,
            type + "Exit",
            type + "Exit-" + key
          ];
        } else if (key) {
          return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
        } else if (node.append) {
          return [type, CHILDREN, type + "Exit"];
        } else {
          return [type, type + "Exit"];
        }
      }
      function toStack(node) {
        let events;
        if (node.type === "document") {
          events = ["Document", CHILDREN, "DocumentExit"];
        } else if (node.type === "root") {
          events = ["Root", CHILDREN, "RootExit"];
        } else {
          events = getEvents(node);
        }
        return {
          eventIndex: 0,
          events,
          iterator: 0,
          node,
          visitorIndex: 0,
          visitors: []
        };
      }
      function cleanMarks(node) {
        node[isClean] = false;
        if (node.nodes)
          node.nodes.forEach((i) => cleanMarks(i));
        return node;
      }
      var postcss2 = {};
      var LazyResult = class _LazyResult {
        constructor(processor, css, opts) {
          this.stringified = false;
          this.processed = false;
          let root2;
          if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
            root2 = cleanMarks(css);
          } else if (css instanceof _LazyResult || css instanceof Result2) {
            root2 = cleanMarks(css.root);
            if (css.map) {
              if (typeof opts.map === "undefined")
                opts.map = {};
              if (!opts.map.inline)
                opts.map.inline = false;
              opts.map.prev = css.map;
            }
          } else {
            let parser4 = parse4;
            if (opts.syntax)
              parser4 = opts.syntax.parse;
            if (opts.parser)
              parser4 = opts.parser;
            if (parser4.parse)
              parser4 = parser4.parse;
            try {
              root2 = parser4(css, opts);
            } catch (error) {
              this.processed = true;
              this.error = error;
            }
            if (root2 && !root2[my]) {
              Container2.rebuild(root2);
            }
          }
          this.result = new Result2(processor, root2, opts);
          this.helpers = { ...postcss2, postcss: postcss2, result: this.result };
          this.plugins = this.processor.plugins.map((plugin2) => {
            if (typeof plugin2 === "object" && plugin2.prepare) {
              return { ...plugin2, ...plugin2.prepare(this.result) };
            } else {
              return plugin2;
            }
          });
        }
        async() {
          if (this.error)
            return Promise.reject(this.error);
          if (this.processed)
            return Promise.resolve(this.result);
          if (!this.processing) {
            this.processing = this.runAsync();
          }
          return this.processing;
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        getAsyncError() {
          throw new Error("Use process(css).then(cb) to work with async plugins");
        }
        handleError(error, node) {
          let plugin2 = this.result.lastPlugin;
          try {
            if (node)
              node.addToError(error);
            this.error = error;
            if (error.name === "CssSyntaxError" && !error.plugin) {
              error.plugin = plugin2.postcssPlugin;
              error.setMessage();
            } else if (plugin2.postcssVersion) {
              if (true) {
                let pluginName = plugin2.postcssPlugin;
                let pluginVer = plugin2.postcssVersion;
                let runtimeVer = this.result.processor.version;
                let a = pluginVer.split(".");
                let b = runtimeVer.split(".");
                if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                  console.error(
                    "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                  );
                }
              }
            }
          } catch (err) {
            if (console && console.error)
              console.error(err);
          }
          return error;
        }
        prepareVisitors() {
          this.listeners = {};
          let add = (plugin2, type, cb) => {
            if (!this.listeners[type])
              this.listeners[type] = [];
            this.listeners[type].push([plugin2, cb]);
          };
          for (let plugin2 of this.plugins) {
            if (typeof plugin2 === "object") {
              for (let event in plugin2) {
                if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                  throw new Error(
                    `Unknown event ${event} in ${plugin2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                  );
                }
                if (!NOT_VISITORS[event]) {
                  if (typeof plugin2[event] === "object") {
                    for (let filter in plugin2[event]) {
                      if (filter === "*") {
                        add(plugin2, event, plugin2[event][filter]);
                      } else {
                        add(
                          plugin2,
                          event + "-" + filter.toLowerCase(),
                          plugin2[event][filter]
                        );
                      }
                    }
                  } else if (typeof plugin2[event] === "function") {
                    add(plugin2, event, plugin2[event]);
                  }
                }
              }
            }
          }
          this.hasListener = Object.keys(this.listeners).length > 0;
        }
        async runAsync() {
          this.plugin = 0;
          for (let i = 0; i < this.plugins.length; i++) {
            let plugin2 = this.plugins[i];
            let promise = this.runOnRoot(plugin2);
            if (isPromise(promise)) {
              try {
                await promise;
              } catch (error) {
                throw this.handleError(error);
              }
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root2 = this.result.root;
            while (!root2[isClean]) {
              root2[isClean] = true;
              let stack = [toStack(root2)];
              while (stack.length > 0) {
                let promise = this.visitTick(stack);
                if (isPromise(promise)) {
                  try {
                    await promise;
                  } catch (e2) {
                    let node = stack[stack.length - 1].node;
                    throw this.handleError(e2, node);
                  }
                }
              }
            }
            if (this.listeners.OnceExit) {
              for (let [plugin2, visitor] of this.listeners.OnceExit) {
                this.result.lastPlugin = plugin2;
                try {
                  if (root2.type === "document") {
                    let roots = root2.nodes.map(
                      (subRoot) => visitor(subRoot, this.helpers)
                    );
                    await Promise.all(roots);
                  } else {
                    await visitor(root2, this.helpers);
                  }
                } catch (e2) {
                  throw this.handleError(e2);
                }
              }
            }
          }
          this.processed = true;
          return this.stringify();
        }
        runOnRoot(plugin2) {
          this.result.lastPlugin = plugin2;
          try {
            if (typeof plugin2 === "object" && plugin2.Once) {
              if (this.result.root.type === "document") {
                let roots = this.result.root.nodes.map(
                  (root2) => plugin2.Once(root2, this.helpers)
                );
                if (isPromise(roots[0])) {
                  return Promise.all(roots);
                }
                return roots;
              }
              return plugin2.Once(this.result.root, this.helpers);
            } else if (typeof plugin2 === "function") {
              return plugin2(this.result.root, this.result);
            }
          } catch (error) {
            throw this.handleError(error);
          }
        }
        stringify() {
          if (this.error)
            throw this.error;
          if (this.stringified)
            return this.result;
          this.stringified = true;
          this.sync();
          let opts = this.result.opts;
          let str = stringify2;
          if (opts.syntax)
            str = opts.syntax.stringify;
          if (opts.stringifier)
            str = opts.stringifier;
          if (str.stringify)
            str = str.stringify;
          let map = new MapGenerator(str, this.result.root, this.result.opts);
          let data = map.generate();
          this.result.css = data[0];
          this.result.map = data[1];
          return this.result;
        }
        sync() {
          if (this.error)
            throw this.error;
          if (this.processed)
            return this.result;
          this.processed = true;
          if (this.processing) {
            throw this.getAsyncError();
          }
          for (let plugin2 of this.plugins) {
            let promise = this.runOnRoot(plugin2);
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root2 = this.result.root;
            while (!root2[isClean]) {
              root2[isClean] = true;
              this.walkSync(root2);
            }
            if (this.listeners.OnceExit) {
              if (root2.type === "document") {
                for (let subRoot of root2.nodes) {
                  this.visitSync(this.listeners.OnceExit, subRoot);
                }
              } else {
                this.visitSync(this.listeners.OnceExit, root2);
              }
            }
          }
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this.opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this.css;
        }
        visitSync(visitors, node) {
          for (let [plugin2, visitor] of visitors) {
            this.result.lastPlugin = plugin2;
            let promise;
            try {
              promise = visitor(node, this.helpers);
            } catch (e2) {
              throw this.handleError(e2, node.proxyOf);
            }
            if (node.type !== "root" && node.type !== "document" && !node.parent) {
              return true;
            }
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
        }
        visitTick(stack) {
          let visit = stack[stack.length - 1];
          let { node, visitors } = visit;
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            stack.pop();
            return;
          }
          if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
            let [plugin2, visitor] = visitors[visit.visitorIndex];
            visit.visitorIndex += 1;
            if (visit.visitorIndex === visitors.length) {
              visit.visitors = [];
              visit.visitorIndex = 0;
            }
            this.result.lastPlugin = plugin2;
            try {
              return visitor(node.toProxy(), this.helpers);
            } catch (e2) {
              throw this.handleError(e2, node);
            }
          }
          if (visit.iterator !== 0) {
            let iterator = visit.iterator;
            let child;
            while (child = node.nodes[node.indexes[iterator]]) {
              node.indexes[iterator] += 1;
              if (!child[isClean]) {
                child[isClean] = true;
                stack.push(toStack(child));
                return;
              }
            }
            visit.iterator = 0;
            delete node.indexes[iterator];
          }
          let events = visit.events;
          while (visit.eventIndex < events.length) {
            let event = events[visit.eventIndex];
            visit.eventIndex += 1;
            if (event === CHILDREN) {
              if (node.nodes && node.nodes.length) {
                node[isClean] = true;
                visit.iterator = node.getIterator();
              }
              return;
            } else if (this.listeners[event]) {
              visit.visitors = this.listeners[event];
              return;
            }
          }
          stack.pop();
        }
        walkSync(node) {
          node[isClean] = true;
          let events = getEvents(node);
          for (let event of events) {
            if (event === CHILDREN) {
              if (node.nodes) {
                node.each((child) => {
                  if (!child[isClean])
                    this.walkSync(child);
                });
              }
            } else {
              let visitors = this.listeners[event];
              if (visitors) {
                if (this.visitSync(visitors, node.toProxy()))
                  return;
              }
            }
          }
        }
        warnings() {
          return this.sync().warnings();
        }
        get content() {
          return this.stringify().content;
        }
        get css() {
          return this.stringify().css;
        }
        get map() {
          return this.stringify().map;
        }
        get messages() {
          return this.sync().messages;
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          return this.sync().root;
        }
        get [Symbol.toStringTag]() {
          return "LazyResult";
        }
      };
      LazyResult.registerPostcss = (dependant) => {
        postcss2 = dependant;
      };
      module.exports = LazyResult;
      LazyResult.default = LazyResult;
      Root2.registerLazyResult(LazyResult);
      Document2.registerLazyResult(LazyResult);
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/no-work-result.js
  var require_no_work_result = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/no-work-result.js"(exports, module) {
      "use strict";
      var MapGenerator = require_map_generator();
      var stringify2 = require_stringify();
      var warnOnce = require_warn_once();
      var parse4 = require_parse();
      var Result2 = require_result();
      var NoWorkResult = class {
        constructor(processor, css, opts) {
          css = css.toString();
          this.stringified = false;
          this._processor = processor;
          this._css = css;
          this._opts = opts;
          this._map = void 0;
          let root2;
          let str = stringify2;
          this.result = new Result2(this._processor, root2, this._opts);
          this.result.css = css;
          let self2 = this;
          Object.defineProperty(this.result, "root", {
            get() {
              return self2.root;
            }
          });
          let map = new MapGenerator(str, root2, this._opts, css);
          if (map.isMap()) {
            let [generatedCSS, generatedMap] = map.generate();
            if (generatedCSS) {
              this.result.css = generatedCSS;
            }
            if (generatedMap) {
              this.result.map = generatedMap;
            }
          } else {
            map.clearAnnotation();
            this.result.css = map.css;
          }
        }
        async() {
          if (this.error)
            return Promise.reject(this.error);
          return Promise.resolve(this.result);
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        sync() {
          if (this.error)
            throw this.error;
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this._opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this._css;
        }
        warnings() {
          return [];
        }
        get content() {
          return this.result.css;
        }
        get css() {
          return this.result.css;
        }
        get map() {
          return this.result.map;
        }
        get messages() {
          return [];
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          if (this._root) {
            return this._root;
          }
          let root2;
          let parser4 = parse4;
          try {
            root2 = parser4(this._css, this._opts);
          } catch (error) {
            this.error = error;
          }
          if (this.error) {
            throw this.error;
          } else {
            this._root = root2;
            return root2;
          }
        }
        get [Symbol.toStringTag]() {
          return "NoWorkResult";
        }
      };
      module.exports = NoWorkResult;
      NoWorkResult.default = NoWorkResult;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/processor.js
  var require_processor = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/processor.js"(exports, module) {
      "use strict";
      var NoWorkResult = require_no_work_result();
      var LazyResult = require_lazy_result();
      var Document2 = require_document();
      var Root2 = require_root();
      var Processor2 = class {
        constructor(plugins = []) {
          this.version = "8.4.38";
          this.plugins = this.normalize(plugins);
        }
        normalize(plugins) {
          let normalized = [];
          for (let i of plugins) {
            if (i.postcss === true) {
              i = i();
            } else if (i.postcss) {
              i = i.postcss;
            }
            if (typeof i === "object" && Array.isArray(i.plugins)) {
              normalized = normalized.concat(i.plugins);
            } else if (typeof i === "object" && i.postcssPlugin) {
              normalized.push(i);
            } else if (typeof i === "function") {
              normalized.push(i);
            } else if (typeof i === "object" && (i.parse || i.stringify)) {
              if (true) {
                throw new Error(
                  "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
                );
              }
            } else {
              throw new Error(i + " is not a PostCSS plugin");
            }
          }
          return normalized;
        }
        process(css, opts = {}) {
          if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
            return new NoWorkResult(this, css, opts);
          } else {
            return new LazyResult(this, css, opts);
          }
        }
        use(plugin2) {
          this.plugins = this.plugins.concat(this.normalize([plugin2]));
          return this;
        }
      };
      module.exports = Processor2;
      Processor2.default = Processor2;
      Root2.registerProcessor(Processor2);
      Document2.registerProcessor(Processor2);
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/fromJSON.js
  var require_fromJSON = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/fromJSON.js"(exports, module) {
      "use strict";
      var Declaration2 = require_declaration();
      var PreviousMap = require_previous_map();
      var Comment2 = require_comment();
      var AtRule2 = require_at_rule();
      var Input2 = require_input();
      var Root2 = require_root();
      var Rule2 = require_rule();
      function fromJSON2(json, inputs) {
        if (Array.isArray(json))
          return json.map((n2) => fromJSON2(n2));
        let { inputs: ownInputs, ...defaults3 } = json;
        if (ownInputs) {
          inputs = [];
          for (let input of ownInputs) {
            let inputHydrated = { ...input, __proto__: Input2.prototype };
            if (inputHydrated.map) {
              inputHydrated.map = {
                ...inputHydrated.map,
                __proto__: PreviousMap.prototype
              };
            }
            inputs.push(inputHydrated);
          }
        }
        if (defaults3.nodes) {
          defaults3.nodes = json.nodes.map((n2) => fromJSON2(n2, inputs));
        }
        if (defaults3.source) {
          let { inputId, ...source } = defaults3.source;
          defaults3.source = source;
          if (inputId != null) {
            defaults3.source.input = inputs[inputId];
          }
        }
        if (defaults3.type === "root") {
          return new Root2(defaults3);
        } else if (defaults3.type === "decl") {
          return new Declaration2(defaults3);
        } else if (defaults3.type === "rule") {
          return new Rule2(defaults3);
        } else if (defaults3.type === "comment") {
          return new Comment2(defaults3);
        } else if (defaults3.type === "atrule") {
          return new AtRule2(defaults3);
        } else {
          throw new Error("Unknown node type: " + json.type);
        }
      }
      module.exports = fromJSON2;
      fromJSON2.default = fromJSON2;
    }
  });

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/postcss.js
  var require_postcss = __commonJS({
    "node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/postcss.js"(exports, module) {
      "use strict";
      var CssSyntaxError2 = require_css_syntax_error();
      var Declaration2 = require_declaration();
      var LazyResult = require_lazy_result();
      var Container2 = require_container();
      var Processor2 = require_processor();
      var stringify2 = require_stringify();
      var fromJSON2 = require_fromJSON();
      var Document2 = require_document();
      var Warning2 = require_warning();
      var Comment2 = require_comment();
      var AtRule2 = require_at_rule();
      var Result2 = require_result();
      var Input2 = require_input();
      var parse4 = require_parse();
      var list3 = require_list();
      var Rule2 = require_rule();
      var Root2 = require_root();
      var Node3 = require_node();
      function postcss2(...plugins) {
        if (plugins.length === 1 && Array.isArray(plugins[0])) {
          plugins = plugins[0];
        }
        return new Processor2(plugins);
      }
      postcss2.plugin = function plugin2(name, initializer) {
        let warningPrinted = false;
        function creator(...args) {
          if (console && console.warn && !warningPrinted) {
            warningPrinted = true;
            console.warn(
              name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
            );
            if (process.env.LANG && process.env.LANG.startsWith("cn")) {
              console.warn(
                name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
              );
            }
          }
          let transformer = initializer(...args);
          transformer.postcssPlugin = name;
          transformer.postcssVersion = new Processor2().version;
          return transformer;
        }
        let cache3;
        Object.defineProperty(creator, "postcss", {
          get() {
            if (!cache3)
              cache3 = creator();
            return cache3;
          }
        });
        creator.process = function(css, processOpts, pluginOpts) {
          return postcss2([creator(pluginOpts)]).process(css, processOpts);
        };
        return creator;
      };
      postcss2.stringify = stringify2;
      postcss2.parse = parse4;
      postcss2.fromJSON = fromJSON2;
      postcss2.list = list3;
      postcss2.comment = (defaults3) => new Comment2(defaults3);
      postcss2.atRule = (defaults3) => new AtRule2(defaults3);
      postcss2.decl = (defaults3) => new Declaration2(defaults3);
      postcss2.rule = (defaults3) => new Rule2(defaults3);
      postcss2.root = (defaults3) => new Root2(defaults3);
      postcss2.document = (defaults3) => new Document2(defaults3);
      postcss2.CssSyntaxError = CssSyntaxError2;
      postcss2.Declaration = Declaration2;
      postcss2.Container = Container2;
      postcss2.Processor = Processor2;
      postcss2.Document = Document2;
      postcss2.Comment = Comment2;
      postcss2.Warning = Warning2;
      postcss2.AtRule = AtRule2;
      postcss2.Result = Result2;
      postcss2.Input = Input2;
      postcss2.Rule = Rule2;
      postcss2.Root = Root2;
      postcss2.Node = Node3;
      LazyResult.registerPostcss(postcss2);
      module.exports = postcss2;
      postcss2.default = postcss2;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/util/unesc.js
  var require_unesc = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/util/unesc.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = unesc;
      function gobbleHex(str) {
        var lower = str.toLowerCase();
        var hex2 = "";
        var spaceTerminated = false;
        for (var i = 0; i < 6 && lower[i] !== void 0; i++) {
          var code = lower.charCodeAt(i);
          var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
          spaceTerminated = code === 32;
          if (!valid) {
            break;
          }
          hex2 += lower[i];
        }
        if (hex2.length === 0) {
          return void 0;
        }
        var codePoint = parseInt(hex2, 16);
        var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
        if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
          return ["\uFFFD", hex2.length + (spaceTerminated ? 1 : 0)];
        }
        return [String.fromCodePoint(codePoint), hex2.length + (spaceTerminated ? 1 : 0)];
      }
      var CONTAINS_ESCAPE = /\\/;
      function unesc(str) {
        var needToProcess = CONTAINS_ESCAPE.test(str);
        if (!needToProcess) {
          return str;
        }
        var ret = "";
        for (var i = 0; i < str.length; i++) {
          if (str[i] === "\\") {
            var gobbled = gobbleHex(str.slice(i + 1, i + 7));
            if (gobbled !== void 0) {
              ret += gobbled[0];
              i += gobbled[1];
              continue;
            }
            if (str[i + 1] === "\\") {
              ret += "\\";
              i++;
              continue;
            }
            if (str.length === i + 1) {
              ret += str[i];
            }
            continue;
          }
          ret += str[i];
        }
        return ret;
      }
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/util/getProp.js
  var require_getProp = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/util/getProp.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = getProp;
      function getProp(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            return void 0;
          }
          obj = obj[prop];
        }
        return obj;
      }
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/util/ensureObject.js
  var require_ensureObject = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/util/ensureObject.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = ensureObject;
      function ensureObject(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            obj[prop] = {};
          }
          obj = obj[prop];
        }
      }
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/util/stripComments.js
  var require_stripComments = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/util/stripComments.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = stripComments;
      function stripComments(str) {
        var s2 = "";
        var commentStart = str.indexOf("/*");
        var lastEnd = 0;
        while (commentStart >= 0) {
          s2 = s2 + str.slice(lastEnd, commentStart);
          var commentEnd = str.indexOf("*/", commentStart + 2);
          if (commentEnd < 0) {
            return s2;
          }
          lastEnd = commentEnd + 2;
          commentStart = str.indexOf("/*", lastEnd);
        }
        s2 = s2 + str.slice(lastEnd);
        return s2;
      }
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/util/index.js
  var require_util = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/util/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.unesc = exports.stripComments = exports.getProp = exports.ensureObject = void 0;
      var _unesc = _interopRequireDefault(require_unesc());
      exports.unesc = _unesc["default"];
      var _getProp = _interopRequireDefault(require_getProp());
      exports.getProp = _getProp["default"];
      var _ensureObject = _interopRequireDefault(require_ensureObject());
      exports.ensureObject = _ensureObject["default"];
      var _stripComments = _interopRequireDefault(require_stripComments());
      exports.stripComments = _stripComments["default"];
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/node.js
  var require_node2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/node.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _util = require_util();
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var cloneNode = function cloneNode2(obj, parent) {
        if (typeof obj !== "object" || obj === null) {
          return obj;
        }
        var cloned = new obj.constructor();
        for (var i in obj) {
          if (!obj.hasOwnProperty(i)) {
            continue;
          }
          var value2 = obj[i];
          var type = typeof value2;
          if (i === "parent" && type === "object") {
            if (parent) {
              cloned[i] = parent;
            }
          } else if (value2 instanceof Array) {
            cloned[i] = value2.map(function(j) {
              return cloneNode2(j, cloned);
            });
          } else {
            cloned[i] = cloneNode2(value2, cloned);
          }
        }
        return cloned;
      };
      var Node3 = /* @__PURE__ */ function() {
        function Node4(opts) {
          if (opts === void 0) {
            opts = {};
          }
          Object.assign(this, opts);
          this.spaces = this.spaces || {};
          this.spaces.before = this.spaces.before || "";
          this.spaces.after = this.spaces.after || "";
        }
        var _proto = Node4.prototype;
        _proto.remove = function remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        };
        _proto.replaceWith = function replaceWith() {
          if (this.parent) {
            for (var index2 in arguments) {
              this.parent.insertBefore(this, arguments[index2]);
            }
            this.remove();
          }
          return this;
        };
        _proto.next = function next() {
          return this.parent.at(this.parent.index(this) + 1);
        };
        _proto.prev = function prev() {
          return this.parent.at(this.parent.index(this) - 1);
        };
        _proto.clone = function clone(overrides) {
          if (overrides === void 0) {
            overrides = {};
          }
          var cloned = cloneNode(this);
          for (var name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        };
        _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value2, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          var originalValue = this[name];
          var originalEscaped = this.raws[name];
          this[name] = originalValue + value2;
          if (originalEscaped || valueEscaped !== value2) {
            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
          } else {
            delete this.raws[name];
          }
        };
        _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value2, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          this[name] = value2;
          this.raws[name] = valueEscaped;
        };
        _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value2) {
          this[name] = value2;
          if (this.raws) {
            delete this.raws[name];
          }
        };
        _proto.isAtPosition = function isAtPosition(line, column) {
          if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line) {
              return false;
            }
            if (this.source.end.line < line) {
              return false;
            }
            if (this.source.start.line === line && this.source.start.column > column) {
              return false;
            }
            if (this.source.end.line === line && this.source.end.column < column) {
              return false;
            }
            return true;
          }
          return void 0;
        };
        _proto.stringifyProperty = function stringifyProperty(name) {
          return this.raws && this.raws[name] || this[name];
        };
        _proto.valueToString = function valueToString() {
          return String(this.stringifyProperty("value"));
        };
        _proto.toString = function toString2() {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
        };
        _createClass(Node4, [{
          key: "rawSpaceBefore",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
            if (rawSpace === void 0) {
              rawSpace = this.spaces && this.spaces.before;
            }
            return rawSpace || "";
          },
          set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
          }
        }, {
          key: "rawSpaceAfter",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
            if (rawSpace === void 0) {
              rawSpace = this.spaces.after;
            }
            return rawSpace || "";
          },
          set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
          }
        }]);
        return Node4;
      }();
      exports["default"] = Node3;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/types.js
  var require_types = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/types.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.UNIVERSAL = exports.TAG = exports.STRING = exports.SELECTOR = exports.ROOT = exports.PSEUDO = exports.NESTING = exports.ID = exports.COMMENT = exports.COMBINATOR = exports.CLASS = exports.ATTRIBUTE = void 0;
      var TAG = "tag";
      exports.TAG = TAG;
      var STRING = "string";
      exports.STRING = STRING;
      var SELECTOR = "selector";
      exports.SELECTOR = SELECTOR;
      var ROOT = "root";
      exports.ROOT = ROOT;
      var PSEUDO = "pseudo";
      exports.PSEUDO = PSEUDO;
      var NESTING = "nesting";
      exports.NESTING = NESTING;
      var ID = "id";
      exports.ID = ID;
      var COMMENT = "comment";
      exports.COMMENT = COMMENT;
      var COMBINATOR = "combinator";
      exports.COMBINATOR = COMBINATOR;
      var CLASS = "class";
      exports.CLASS = CLASS;
      var ATTRIBUTE = "attribute";
      exports.ATTRIBUTE = ATTRIBUTE;
      var UNIVERSAL = "universal";
      exports.UNIVERSAL = UNIVERSAL;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/container.js
  var require_container2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/container.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var types2 = _interopRequireWildcard(require_types());
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache3 = _getRequireWildcardCache(nodeInterop);
        if (cache3 && cache3.has(obj)) {
          return cache3.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache3) {
          cache3.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (it)
          return (it = it.call(o)).next.bind(it);
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          return function() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n2 = Object.prototype.toString.call(o).slice(8, -1);
        if (n2 === "Object" && o.constructor)
          n2 = o.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var Container2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Container3, _Node);
        function Container3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          if (!_this.nodes) {
            _this.nodes = [];
          }
          return _this;
        }
        var _proto = Container3.prototype;
        _proto.append = function append(selector) {
          selector.parent = this;
          this.nodes.push(selector);
          return this;
        };
        _proto.prepend = function prepend(selector) {
          selector.parent = this;
          this.nodes.unshift(selector);
          return this;
        };
        _proto.at = function at(index2) {
          return this.nodes[index2];
        };
        _proto.index = function index2(child) {
          if (typeof child === "number") {
            return child;
          }
          return this.nodes.indexOf(child);
        };
        _proto.removeChild = function removeChild(child) {
          child = this.index(child);
          this.at(child).parent = void 0;
          this.nodes.splice(child, 1);
          var index2;
          for (var id in this.indexes) {
            index2 = this.indexes[id];
            if (index2 >= child) {
              this.indexes[id] = index2 - 1;
            }
          }
          return this;
        };
        _proto.removeAll = function removeAll() {
          for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
            var node = _step.value;
            node.parent = void 0;
          }
          this.nodes = [];
          return this;
        };
        _proto.empty = function empty() {
          return this.removeAll();
        };
        _proto.insertAfter = function insertAfter(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex + 1, 0, newNode);
          newNode.parent = this;
          var index2;
          for (var id in this.indexes) {
            index2 = this.indexes[id];
            if (oldIndex <= index2) {
              this.indexes[id] = index2 + 1;
            }
          }
          return this;
        };
        _proto.insertBefore = function insertBefore(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex, 0, newNode);
          newNode.parent = this;
          var index2;
          for (var id in this.indexes) {
            index2 = this.indexes[id];
            if (index2 <= oldIndex) {
              this.indexes[id] = index2 + 1;
            }
          }
          return this;
        };
        _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
          var found = void 0;
          this.each(function(node) {
            if (node.atPosition) {
              var foundChild = node.atPosition(line, col);
              if (foundChild) {
                found = foundChild;
                return false;
              }
            } else if (node.isAtPosition(line, col)) {
              found = node;
              return false;
            }
          });
          return found;
        };
        _proto.atPosition = function atPosition(line, col) {
          if (this.isAtPosition(line, col)) {
            return this._findChildAtPosition(line, col) || this;
          } else {
            return void 0;
          }
        };
        _proto._inferEndPosition = function _inferEndPosition() {
          if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
          }
        };
        _proto.each = function each(callback) {
          if (!this.lastEach) {
            this.lastEach = 0;
          }
          if (!this.indexes) {
            this.indexes = {};
          }
          this.lastEach++;
          var id = this.lastEach;
          this.indexes[id] = 0;
          if (!this.length) {
            return void 0;
          }
          var index2, result;
          while (this.indexes[id] < this.length) {
            index2 = this.indexes[id];
            result = callback(this.at(index2), index2);
            if (result === false) {
              break;
            }
            this.indexes[id] += 1;
          }
          delete this.indexes[id];
          if (result === false) {
            return false;
          }
        };
        _proto.walk = function walk(callback) {
          return this.each(function(node, i) {
            var result = callback(node, i);
            if (result !== false && node.length) {
              result = node.walk(callback);
            }
            if (result === false) {
              return false;
            }
          });
        };
        _proto.walkAttributes = function walkAttributes(callback) {
          var _this2 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.ATTRIBUTE) {
              return callback.call(_this2, selector);
            }
          });
        };
        _proto.walkClasses = function walkClasses(callback) {
          var _this3 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.CLASS) {
              return callback.call(_this3, selector);
            }
          });
        };
        _proto.walkCombinators = function walkCombinators(callback) {
          var _this4 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.COMBINATOR) {
              return callback.call(_this4, selector);
            }
          });
        };
        _proto.walkComments = function walkComments(callback) {
          var _this5 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.COMMENT) {
              return callback.call(_this5, selector);
            }
          });
        };
        _proto.walkIds = function walkIds(callback) {
          var _this6 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.ID) {
              return callback.call(_this6, selector);
            }
          });
        };
        _proto.walkNesting = function walkNesting(callback) {
          var _this7 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.NESTING) {
              return callback.call(_this7, selector);
            }
          });
        };
        _proto.walkPseudos = function walkPseudos(callback) {
          var _this8 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.PSEUDO) {
              return callback.call(_this8, selector);
            }
          });
        };
        _proto.walkTags = function walkTags(callback) {
          var _this9 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.TAG) {
              return callback.call(_this9, selector);
            }
          });
        };
        _proto.walkUniversals = function walkUniversals(callback) {
          var _this10 = this;
          return this.walk(function(selector) {
            if (selector.type === types2.UNIVERSAL) {
              return callback.call(_this10, selector);
            }
          });
        };
        _proto.split = function split(callback) {
          var _this11 = this;
          var current = [];
          return this.reduce(function(memo, node, index2) {
            var split2 = callback.call(_this11, node);
            current.push(node);
            if (split2) {
              memo.push(current);
              current = [];
            } else if (index2 === _this11.length - 1) {
              memo.push(current);
            }
            return memo;
          }, []);
        };
        _proto.map = function map(callback) {
          return this.nodes.map(callback);
        };
        _proto.reduce = function reduce(callback, memo) {
          return this.nodes.reduce(callback, memo);
        };
        _proto.every = function every(callback) {
          return this.nodes.every(callback);
        };
        _proto.some = function some(callback) {
          return this.nodes.some(callback);
        };
        _proto.filter = function filter(callback) {
          return this.nodes.filter(callback);
        };
        _proto.sort = function sort(callback) {
          return this.nodes.sort(callback);
        };
        _proto.toString = function toString2() {
          return this.map(String).join("");
        };
        _createClass(Container3, [{
          key: "first",
          get: function get() {
            return this.at(0);
          }
        }, {
          key: "last",
          get: function get() {
            return this.at(this.length - 1);
          }
        }, {
          key: "length",
          get: function get() {
            return this.nodes.length;
          }
        }]);
        return Container3;
      }(_node["default"]);
      exports["default"] = Container2;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/root.js
  var require_root2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/root.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _container = _interopRequireDefault(require_container2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var Root2 = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Root3, _Container);
        function Root3(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types.ROOT;
          return _this;
        }
        var _proto = Root3.prototype;
        _proto.toString = function toString2() {
          var str = this.reduce(function(memo, selector) {
            memo.push(String(selector));
            return memo;
          }, []).join(",");
          return this.trailingComma ? str + "," : str;
        };
        _proto.error = function error(message, options) {
          if (this._error) {
            return this._error(message, options);
          } else {
            return new Error(message);
          }
        };
        _createClass(Root3, [{
          key: "errorGenerator",
          set: function set(handler) {
            this._error = handler;
          }
        }]);
        return Root3;
      }(_container["default"]);
      exports["default"] = Root2;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/selector.js
  var require_selector = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/selector.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _container = _interopRequireDefault(require_container2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var Selector = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Selector2, _Container);
        function Selector2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types.SELECTOR;
          return _this;
        }
        return Selector2;
      }(_container["default"]);
      exports["default"] = Selector;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js
  var require_cssesc = __commonJS({
    "node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js"(exports, module) {
      "use strict";
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var merge = function merge2(options, defaults3) {
        if (!options) {
          return defaults3;
        }
        var result = {};
        for (var key in defaults3) {
          result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults3[key];
        }
        return result;
      };
      var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
      var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
      var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
      var cssesc = function cssesc2(string, options) {
        options = merge(options, cssesc2.options);
        if (options.quotes != "single" && options.quotes != "double") {
          options.quotes = "single";
        }
        var quote = options.quotes == "double" ? '"' : "'";
        var isIdentifier = options.isIdentifier;
        var firstChar = string.charAt(0);
        var output = "";
        var counter = 0;
        var length2 = string.length;
        while (counter < length2) {
          var character = string.charAt(counter++);
          var codePoint = character.charCodeAt();
          var value2 = void 0;
          if (codePoint < 32 || codePoint > 126) {
            if (codePoint >= 55296 && codePoint <= 56319 && counter < length2) {
              var extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
              } else {
                counter--;
              }
            }
            value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else {
            if (options.escapeEverything) {
              if (regexAnySingleEscape.test(character)) {
                value2 = "\\" + character;
              } else {
                value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
              }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
              value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
            } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
              value2 = "\\" + character;
            } else {
              value2 = character;
            }
          }
          output += value2;
        }
        if (isIdentifier) {
          if (/^-[-\d]/.test(output)) {
            output = "\\-" + output.slice(1);
          } else if (/\d/.test(firstChar)) {
            output = "\\3" + firstChar + " " + output.slice(1);
          }
        }
        output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
          if ($1 && $1.length % 2) {
            return $0;
          }
          return ($1 || "") + $2;
        });
        if (!isIdentifier && options.wrap) {
          return quote + output + quote;
        }
        return output;
      };
      cssesc.options = {
        "escapeEverything": false,
        "isIdentifier": false,
        "quotes": "single",
        "wrap": false
      };
      cssesc.version = "3.0.0";
      module.exports = cssesc;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/className.js
  var require_className = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/className.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _cssesc = _interopRequireDefault(require_cssesc());
      var _util = require_util();
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var ClassName = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(ClassName2, _Node);
        function ClassName2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.CLASS;
          _this._constructed = true;
          return _this;
        }
        var _proto = ClassName2.prototype;
        _proto.valueToString = function valueToString() {
          return "." + _Node.prototype.valueToString.call(this);
        };
        _createClass(ClassName2, [{
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set(v) {
            if (this._constructed) {
              var escaped = (0, _cssesc["default"])(v, {
                isIdentifier: true
              });
              if (escaped !== v) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.value = escaped;
              } else if (this.raws) {
                delete this.raws.value;
              }
            }
            this._value = v;
          }
        }]);
        return ClassName2;
      }(_node["default"]);
      exports["default"] = ClassName;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/comment.js
  var require_comment2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/comment.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var Comment2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Comment3, _Node);
        function Comment3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMMENT;
          return _this;
        }
        return Comment3;
      }(_node["default"]);
      exports["default"] = Comment2;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/id.js
  var require_id = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/id.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var ID = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(ID2, _Node);
        function ID2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.ID;
          return _this;
        }
        var _proto = ID2.prototype;
        _proto.valueToString = function valueToString() {
          return "#" + _Node.prototype.valueToString.call(this);
        };
        return ID2;
      }(_node["default"]);
      exports["default"] = ID;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/namespace.js
  var require_namespace = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/namespace.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _cssesc = _interopRequireDefault(require_cssesc());
      var _util = require_util();
      var _node = _interopRequireDefault(require_node2());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var Namespace = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Namespace2, _Node);
        function Namespace2() {
          return _Node.apply(this, arguments) || this;
        }
        var _proto = Namespace2.prototype;
        _proto.qualifiedName = function qualifiedName(value2) {
          if (this.namespace) {
            return this.namespaceString + "|" + value2;
          } else {
            return value2;
          }
        };
        _proto.valueToString = function valueToString() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        };
        _createClass(Namespace2, [{
          key: "namespace",
          get: function get() {
            return this._namespace;
          },
          set: function set(namespace) {
            if (namespace === true || namespace === "*" || namespace === "&") {
              this._namespace = namespace;
              if (this.raws) {
                delete this.raws.namespace;
              }
              return;
            }
            var escaped = (0, _cssesc["default"])(namespace, {
              isIdentifier: true
            });
            this._namespace = namespace;
            if (escaped !== namespace) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.namespace = escaped;
            } else if (this.raws) {
              delete this.raws.namespace;
            }
          }
        }, {
          key: "ns",
          get: function get() {
            return this._namespace;
          },
          set: function set(namespace) {
            this.namespace = namespace;
          }
        }, {
          key: "namespaceString",
          get: function get() {
            if (this.namespace) {
              var ns = this.stringifyProperty("namespace");
              if (ns === true) {
                return "";
              } else {
                return ns;
              }
            } else {
              return "";
            }
          }
        }]);
        return Namespace2;
      }(_node["default"]);
      exports["default"] = Namespace;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/tag.js
  var require_tag = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/tag.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _namespace = _interopRequireDefault(require_namespace());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var Tag = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Tag2, _Namespace);
        function Tag2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.TAG;
          return _this;
        }
        return Tag2;
      }(_namespace["default"]);
      exports["default"] = Tag;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/string.js
  var require_string = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/string.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var String2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(String3, _Node);
        function String3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.STRING;
          return _this;
        }
        return String3;
      }(_node["default"]);
      exports["default"] = String2;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/pseudo.js
  var require_pseudo = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _container = _interopRequireDefault(require_container2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var Pseudo = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Pseudo2, _Container);
        function Pseudo2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types.PSEUDO;
          return _this;
        }
        var _proto = Pseudo2.prototype;
        _proto.toString = function toString2() {
          var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
          return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
        };
        return Pseudo2;
      }(_container["default"]);
      exports["default"] = Pseudo;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js"(exports, module) {
      module.exports = deprecate;
      function deprecate(fn2, msg) {
        if (config("noDeprecation")) {
          return fn2;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config("throwDeprecation")) {
              throw new Error(msg);
            } else if (config("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn2.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name) {
        try {
          if (!global.localStorage)
            return false;
        } catch (_) {
          return false;
        }
        var val = global.localStorage[name];
        if (null == val)
          return false;
        return String(val).toLowerCase() === "true";
      }
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/attribute.js
  var require_attribute = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/attribute.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      exports.unescapeValue = unescapeValue;
      var _cssesc = _interopRequireDefault(require_cssesc());
      var _unesc = _interopRequireDefault(require_unesc());
      var _namespace = _interopRequireDefault(require_namespace());
      var _types = require_types();
      var _CSSESC_QUOTE_OPTIONS;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var deprecate = require_browser();
      var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function() {
      }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function() {
      }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function() {
      }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
      function unescapeValue(value2) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value2;
        var m = unescaped.match(WRAPPED_IN_QUOTES);
        if (m) {
          quoteMark = m[1];
          unescaped = m[2];
        }
        unescaped = (0, _unesc["default"])(unescaped);
        if (unescaped !== value2) {
          deprecatedUsage = true;
        }
        return {
          deprecatedUsage,
          unescaped,
          quoteMark
        };
      }
      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== void 0) {
          return opts;
        }
        if (opts.value === void 0) {
          return opts;
        }
        warnOfDeprecatedConstructor();
        var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
        if (!opts.raws) {
          opts.raws = {};
        }
        if (opts.raws.value === void 0) {
          opts.raws.value = opts.value;
        }
        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }
      var Attribute = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Attribute2, _Namespace);
        function Attribute2(opts) {
          var _this;
          if (opts === void 0) {
            opts = {};
          }
          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, "unquoted", {
            get: deprecate(function() {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function() {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
          });
          _this._constructed = true;
          return _this;
        }
        var _proto = Attribute2.prototype;
        _proto.getQuotedValue = function getQuotedValue(options) {
          if (options === void 0) {
            options = {};
          }
          var quoteMark = this._determineQuoteMark(options);
          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped = (0, _cssesc["default"])(this._value, cssescopts);
          return escaped;
        };
        _proto._determineQuoteMark = function _determineQuoteMark(options) {
          return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
        };
        _proto.setValue = function setValue(value2, options) {
          if (options === void 0) {
            options = {};
          }
          this._value = value2;
          this._quoteMark = this._determineQuoteMark(options);
          this._syncRawValue();
        };
        _proto.smartQuoteMark = function smartQuoteMark(options) {
          var v = this.value;
          var numSingleQuotes = v.replace(/[^']/g, "").length;
          var numDoubleQuotes = v.replace(/[^"]/g, "").length;
          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped = (0, _cssesc["default"])(v, {
              isIdentifier: true
            });
            if (escaped === v) {
              return Attribute2.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options);
              if (pref === Attribute2.NO_QUOTE) {
                var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote];
                var quoteValue = (0, _cssesc["default"])(v, opts);
                if (quoteValue.length < escaped.length) {
                  return quote;
                }
              }
              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute2.DOUBLE_QUOTE;
          } else {
            return Attribute2.SINGLE_QUOTE;
          }
        };
        _proto.preferredQuoteMark = function preferredQuoteMark(options) {
          var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
          if (quoteMark === void 0) {
            quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
          }
          if (quoteMark === void 0) {
            quoteMark = Attribute2.DOUBLE_QUOTE;
          }
          return quoteMark;
        };
        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };
        _proto._handleEscapes = function _handleEscapes(prop, value2) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(value2, {
              isIdentifier: true
            });
            if (escaped !== value2) {
              this.raws[prop] = escaped;
            } else {
              delete this.raws[prop];
            }
          }
        };
        _proto._spacesFor = function _spacesFor(name) {
          var attrSpaces = {
            before: "",
            after: ""
          };
          var spaces = this.spaces[name] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
          return Object.assign(attrSpaces, spaces, rawSpaces);
        };
        _proto._stringFor = function _stringFor(name, spaceName, concat) {
          if (spaceName === void 0) {
            spaceName = name;
          }
          if (concat === void 0) {
            concat = defaultAttrConcat;
          }
          var attrSpaces = this._spacesFor(spaceName);
          return concat(this.stringifyProperty(name), attrSpaces);
        };
        _proto.offsetOf = function offsetOf(name) {
          var count = 1;
          var attributeSpaces = this._spacesFor("attribute");
          count += attributeSpaces.before.length;
          if (name === "namespace" || name === "ns") {
            return this.namespace ? count : -1;
          }
          if (name === "attributeNS") {
            return count;
          }
          count += this.namespaceString.length;
          if (this.namespace) {
            count += 1;
          }
          if (name === "attribute") {
            return count;
          }
          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;
          var operatorSpaces = this._spacesFor("operator");
          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");
          if (name === "operator") {
            return operator ? count : -1;
          }
          count += operator.length;
          count += operatorSpaces.after.length;
          var valueSpaces = this._spacesFor("value");
          count += valueSpaces.before.length;
          var value2 = this.stringifyProperty("value");
          if (name === "value") {
            return value2 ? count : -1;
          }
          count += value2.length;
          count += valueSpaces.after.length;
          var insensitiveSpaces = this._spacesFor("insensitive");
          count += insensitiveSpaces.before.length;
          if (name === "insensitive") {
            return this.insensitive ? count : -1;
          }
          return -1;
        };
        _proto.toString = function toString2() {
          var _this2 = this;
          var selector = [this.rawSpaceBefore, "["];
          selector.push(this._stringFor("qualifiedAttribute", "attribute"));
          if (this.operator && (this.value || this.value === "")) {
            selector.push(this._stringFor("operator"));
            selector.push(this._stringFor("value"));
            selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }
              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }
          selector.push("]");
          selector.push(this.rawSpaceAfter);
          return selector.join("");
        };
        _createClass(Attribute2, [{
          key: "quoted",
          get: function get() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set(value2) {
            warnOfDeprecatedQuotedAssignment();
          }
          /**
           * returns a single (`'`) or double (`"`) quote character if the value is quoted.
           * returns `null` if the value is not quoted.
           * returns `undefined` if the quotation state is unknown (this can happen when
           * the attribute is constructed without specifying a quote mark.)
           */
        }, {
          key: "quoteMark",
          get: function get() {
            return this._quoteMark;
          },
          set: function set(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }
            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;
              this._syncRawValue();
            }
          }
        }, {
          key: "qualifiedAttribute",
          get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          }
        }, {
          key: "insensitiveFlag",
          get: function get() {
            return this.insensitive ? "i" : "";
          }
        }, {
          key: "value",
          get: function get() {
            return this._value;
          },
          set: (
            /**
             * Before 3.0, the value had to be set to an escaped value including any wrapped
             * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
             * is unescaped during parsing and any quote marks are removed.
             *
             * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
             * a deprecation warning is raised when the new value contains any characters that would
             * require escaping (including if it contains wrapped quotes).
             *
             * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
             * how the new value is quoted.
             */
            function set(v) {
              if (this._constructed) {
                var _unescapeValue2 = unescapeValue(v), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
                if (deprecatedUsage) {
                  warnOfDeprecatedValueAssignment();
                }
                if (unescaped === this._value && quoteMark === this._quoteMark) {
                  return;
                }
                this._value = unescaped;
                this._quoteMark = quoteMark;
                this._syncRawValue();
              } else {
                this._value = v;
              }
            }
          )
        }, {
          key: "insensitive",
          get: function get() {
            return this._insensitive;
          },
          set: function set(insensitive) {
            if (!insensitive) {
              this._insensitive = false;
              if (this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i")) {
                this.raws.insensitiveFlag = void 0;
              }
            }
            this._insensitive = insensitive;
          }
        }, {
          key: "attribute",
          get: function get() {
            return this._attribute;
          },
          set: function set(name) {
            this._handleEscapes("attribute", name);
            this._attribute = name;
          }
        }]);
        return Attribute2;
      }(_namespace["default"]);
      exports["default"] = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: "single",
          wrap: true
        },
        '"': {
          quotes: "double",
          wrap: true
        }
      }, _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true
      }, _CSSESC_QUOTE_OPTIONS);
      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/universal.js
  var require_universal = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/universal.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _namespace = _interopRequireDefault(require_namespace());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var Universal = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Universal2, _Namespace);
        function Universal2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.UNIVERSAL;
          _this.value = "*";
          return _this;
        }
        return Universal2;
      }(_namespace["default"]);
      exports["default"] = Universal;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/combinator.js
  var require_combinator = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/combinator.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var Combinator = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Combinator2, _Node);
        function Combinator2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMBINATOR;
          return _this;
        }
        return Combinator2;
      }(_node["default"]);
      exports["default"] = Combinator;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/nesting.js
  var require_nesting = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/nesting.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _node = _interopRequireDefault(require_node2());
      var _types = require_types();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p4) {
          o2.__proto__ = p4;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var Nesting = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Nesting2, _Node);
        function Nesting2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types.NESTING;
          _this.value = "&";
          return _this;
        }
        return Nesting2;
      }(_node["default"]);
      exports["default"] = Nesting;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/sortAscending.js
  var require_sortAscending = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/sortAscending.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = sortAscending;
      function sortAscending(list3) {
        return list3.sort(function(a, b) {
          return a - b;
        });
      }
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/tokenTypes.js
  var require_tokenTypes = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/tokenTypes.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.word = exports.tilde = exports.tab = exports.str = exports.space = exports.slash = exports.singleQuote = exports.semicolon = exports.plus = exports.pipe = exports.openSquare = exports.openParenthesis = exports.newline = exports.greaterThan = exports.feed = exports.equals = exports.doubleQuote = exports.dollar = exports.cr = exports.comment = exports.comma = exports.combinator = exports.colon = exports.closeSquare = exports.closeParenthesis = exports.caret = exports.bang = exports.backslash = exports.at = exports.asterisk = exports.ampersand = void 0;
      var ampersand = 38;
      exports.ampersand = ampersand;
      var asterisk = 42;
      exports.asterisk = asterisk;
      var at = 64;
      exports.at = at;
      var comma = 44;
      exports.comma = comma;
      var colon = 58;
      exports.colon = colon;
      var semicolon = 59;
      exports.semicolon = semicolon;
      var openParenthesis = 40;
      exports.openParenthesis = openParenthesis;
      var closeParenthesis = 41;
      exports.closeParenthesis = closeParenthesis;
      var openSquare = 91;
      exports.openSquare = openSquare;
      var closeSquare = 93;
      exports.closeSquare = closeSquare;
      var dollar = 36;
      exports.dollar = dollar;
      var tilde = 126;
      exports.tilde = tilde;
      var caret = 94;
      exports.caret = caret;
      var plus = 43;
      exports.plus = plus;
      var equals3 = 61;
      exports.equals = equals3;
      var pipe = 124;
      exports.pipe = pipe;
      var greaterThan = 62;
      exports.greaterThan = greaterThan;
      var space = 32;
      exports.space = space;
      var singleQuote = 39;
      exports.singleQuote = singleQuote;
      var doubleQuote = 34;
      exports.doubleQuote = doubleQuote;
      var slash = 47;
      exports.slash = slash;
      var bang = 33;
      exports.bang = bang;
      var backslash = 92;
      exports.backslash = backslash;
      var cr = 13;
      exports.cr = cr;
      var feed = 12;
      exports.feed = feed;
      var newline = 10;
      exports.newline = newline;
      var tab = 9;
      exports.tab = tab;
      var str = singleQuote;
      exports.str = str;
      var comment2 = -1;
      exports.comment = comment2;
      var word = -2;
      exports.word = word;
      var combinator = -3;
      exports.combinator = combinator;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/tokenize.js
  var require_tokenize2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/tokenize.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.FIELDS = void 0;
      exports["default"] = tokenize;
      var t = _interopRequireWildcard(require_tokenTypes());
      var _unescapable;
      var _wordDelimiters;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache3 = _getRequireWildcardCache(nodeInterop);
        if (cache3 && cache3.has(obj)) {
          return cache3.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache3) {
          cache3.set(obj, newObj);
        }
        return newObj;
      }
      var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
      var hex2 = {};
      var hexChars = "0123456789abcdefABCDEF";
      for (i = 0; i < hexChars.length; i++) {
        hex2[hexChars.charCodeAt(i)] = true;
      }
      var i;
      function consumeWord(css, start) {
        var next = start;
        var code;
        do {
          code = css.charCodeAt(next);
          if (wordDelimiters[code]) {
            return next - 1;
          } else if (code === t.backslash) {
            next = consumeEscape(css, next) + 1;
          } else {
            next++;
          }
        } while (next < css.length);
        return next - 1;
      }
      function consumeEscape(css, start) {
        var next = start;
        var code = css.charCodeAt(next + 1);
        if (unescapable[code]) {
        } else if (hex2[code]) {
          var hexDigits = 0;
          do {
            next++;
            hexDigits++;
            code = css.charCodeAt(next + 1);
          } while (hex2[code] && hexDigits < 6);
          if (hexDigits < 6 && code === t.space) {
            next++;
          }
        } else {
          next++;
        }
        return next;
      }
      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6
      };
      exports.FIELDS = FIELDS;
      function tokenize(input) {
        var tokens = [];
        var css = input.css.valueOf();
        var _css = css, length2 = _css.length;
        var offset = -1;
        var line = 1;
        var start = 0;
        var end = 0;
        var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
        function unclosed(what, fix) {
          if (input.safe) {
            css += fix;
            next = css.length - 1;
          } else {
            throw input.error("Unclosed " + what, line, start - offset, start);
          }
        }
        while (start < length2) {
          code = css.charCodeAt(start);
          if (code === t.newline) {
            offset = start;
            line += 1;
          }
          switch (code) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
              next = start;
              do {
                next += 1;
                code = css.charCodeAt(next);
                if (code === t.newline) {
                  offset = next;
                  line += 1;
                }
              } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
              tokenType = t.space;
              endLine = line;
              endColumn = next - offset - 1;
              end = next;
              break;
            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
              next = start;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
              tokenType = t.combinator;
              endLine = line;
              endColumn = start - offset;
              end = next;
              break;
            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;
            case t.singleQuote:
            case t.doubleQuote:
              quote = code === t.singleQuote ? "'" : '"';
              next = start;
              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) {
                  unclosed("quote", quote);
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === t.backslash) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              tokenType = t.str;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;
            default:
              if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                next = css.indexOf("*/", start + 2) + 1;
                if (next === 0) {
                  unclosed("comment", "*/");
                }
                content = css.slice(start, next + 1);
                lines = content.split("\n");
                last = lines.length - 1;
                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }
                tokenType = t.comment;
                line = nextLine;
                endLine = nextLine;
                endColumn = next - nextOffset;
              } else if (code === t.slash) {
                next = start;
                tokenType = code;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
              } else {
                next = consumeWord(css, start);
                tokenType = t.word;
                endLine = line;
                endColumn = next - offset;
              }
              end = next + 1;
              break;
          }
          tokens.push([
            tokenType,
            // [0] Token type
            line,
            // [1] Starting line
            start - offset,
            // [2] Starting column
            endLine,
            // [3] Ending line
            endColumn,
            // [4] Ending column
            start,
            // [5] Start position / Source index
            end
            // [6] End position
          ]);
          if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
          }
          start = end;
        }
        return tokens;
      }
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/parser.js
  var require_parser2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/parser.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _root = _interopRequireDefault(require_root2());
      var _selector = _interopRequireDefault(require_selector());
      var _className = _interopRequireDefault(require_className());
      var _comment = _interopRequireDefault(require_comment2());
      var _id = _interopRequireDefault(require_id());
      var _tag = _interopRequireDefault(require_tag());
      var _string = _interopRequireDefault(require_string());
      var _pseudo = _interopRequireDefault(require_pseudo());
      var _attribute = _interopRequireWildcard(require_attribute());
      var _universal = _interopRequireDefault(require_universal());
      var _combinator = _interopRequireDefault(require_combinator());
      var _nesting = _interopRequireDefault(require_nesting());
      var _sortAscending = _interopRequireDefault(require_sortAscending());
      var _tokenize = _interopRequireWildcard(require_tokenize2());
      var tokens = _interopRequireWildcard(require_tokenTypes());
      var types2 = _interopRequireWildcard(require_types());
      var _util = require_util();
      var _WHITESPACE_TOKENS;
      var _Object$assign;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache3 = _getRequireWildcardCache(nodeInterop);
        if (cache3 && cache3.has(obj)) {
          return cache3.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache3) {
          cache3.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
      var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
      function tokenStart(token) {
        return {
          line: token[_tokenize.FIELDS.START_LINE],
          column: token[_tokenize.FIELDS.START_COL]
        };
      }
      function tokenEnd(token) {
        return {
          line: token[_tokenize.FIELDS.END_LINE],
          column: token[_tokenize.FIELDS.END_COL]
        };
      }
      function getSource(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn
          },
          end: {
            line: endLine,
            column: endColumn
          }
        };
      }
      function getTokenSource(token) {
        return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
      }
      function getTokenSourceSpan(startToken, endToken) {
        if (!startToken) {
          return void 0;
        }
        return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }
      function unescapeProp(node, prop) {
        var value2 = node[prop];
        if (typeof value2 !== "string") {
          return;
        }
        if (value2.indexOf("\\") !== -1) {
          (0, _util.ensureObject)(node, "raws");
          node[prop] = (0, _util.unesc)(value2);
          if (node.raws[prop] === void 0) {
            node.raws[prop] = value2;
          }
        }
        return node;
      }
      function indexesOf(array, item) {
        var i = -1;
        var indexes = [];
        while ((i = array.indexOf(item, i + 1)) !== -1) {
          indexes.push(i);
        }
        return indexes;
      }
      function uniqs() {
        var list3 = Array.prototype.concat.apply([], arguments);
        return list3.filter(function(item, i) {
          return i === list3.indexOf(item);
        });
      }
      var Parser = /* @__PURE__ */ function() {
        function Parser2(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          this.rule = rule2;
          this.options = Object.assign({
            lossy: false,
            safe: false
          }, options);
          this.position = 0;
          this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
          this.tokens = (0, _tokenize["default"])({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe
          });
          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root["default"]({
            source: rootSource
          });
          this.root.errorGenerator = this._errorGenerator();
          var selector = new _selector["default"]({
            source: {
              start: {
                line: 1,
                column: 1
              }
            }
          });
          this.root.append(selector);
          this.current = selector;
          this.loop();
        }
        var _proto = Parser2.prototype;
        _proto._errorGenerator = function _errorGenerator() {
          var _this = this;
          return function(message, errorOptions) {
            if (typeof _this.rule === "string") {
              return new Error(message);
            }
            return _this.rule.error(message, errorOptions);
          };
        };
        _proto.attribute = function attribute() {
          var attr = [];
          var startingToken = this.currToken;
          this.position++;
          while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
          }
          var len = attr.length;
          var node = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          };
          if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
            return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
          }
          var pos = 0;
          var spaceBefore = "";
          var commentBefore = "";
          var lastAdded = null;
          var spaceAfterMeaningfulToken = false;
          while (pos < len) {
            var token = attr[pos];
            var content = this.content(token);
            var next = attr[pos + 1];
            switch (token[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                spaceAfterMeaningfulToken = true;
                if (this.options.lossy) {
                  break;
                }
                if (lastAdded) {
                  (0, _util.ensureObject)(node, "spaces", lastAdded);
                  var prevContent = node.spaces[lastAdded].after || "";
                  node.spaces[lastAdded].after = prevContent + content;
                  var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
                  if (existingComment) {
                    node.raws.spaces[lastAdded].after = existingComment + content;
                  }
                } else {
                  spaceBefore = spaceBefore + content;
                  commentBefore = commentBefore + content;
                }
                break;
              case tokens.asterisk:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "attribute");
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                    node.raws.spaces.attribute.before = spaceBefore;
                    commentBefore = "";
                  }
                  node.namespace = (node.namespace || "") + content;
                  var rawValue = (0, _util.getProp)(node, "raws", "namespace") || null;
                  if (rawValue) {
                    node.raws.namespace += content;
                  }
                  lastAdded = "namespace";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.dollar:
                if (lastAdded === "value") {
                  var oldRawValue = (0, _util.getProp)(node, "raws", "value");
                  node.value += "$";
                  if (oldRawValue) {
                    node.raws.value = oldRawValue + "$";
                  }
                  break;
                }
              case tokens.caret:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.combinator:
                if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                }
                if (content !== "|") {
                  spaceAfterMeaningfulToken = false;
                  break;
                }
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = "operator";
                } else if (!node.namespace && !node.attribute) {
                  node.namespace = true;
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.word:
                if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                !node.operator && !node.namespace) {
                  node.namespace = content;
                  lastAdded = "namespace";
                } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "attribute");
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                    node.raws.spaces.attribute.before = commentBefore;
                    commentBefore = "";
                  }
                  node.attribute = (node.attribute || "") + content;
                  var _rawValue = (0, _util.getProp)(node, "raws", "attribute") || null;
                  if (_rawValue) {
                    node.raws.attribute += content;
                  }
                  lastAdded = "attribute";
                } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
                  var _unescaped = (0, _util.unesc)(content);
                  var _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "";
                  var oldValue = node.value || "";
                  node.value = oldValue + _unescaped;
                  node.quoteMark = null;
                  if (_unescaped !== content || _oldRawValue) {
                    (0, _util.ensureObject)(node, "raws");
                    node.raws.value = (_oldRawValue || oldValue) + content;
                  }
                  lastAdded = "value";
                } else {
                  var insensitive = content === "i" || content === "I";
                  if ((node.value || node.value === "") && (node.quoteMark || spaceAfterMeaningfulToken)) {
                    node.insensitive = insensitive;
                    if (!insensitive || content === "I") {
                      (0, _util.ensureObject)(node, "raws");
                      node.raws.insensitiveFlag = content;
                    }
                    lastAdded = "insensitive";
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node, "spaces", "insensitive");
                      node.spaces.insensitive.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node, "raws", "spaces", "insensitive");
                      node.raws.spaces.insensitive.before = commentBefore;
                      commentBefore = "";
                    }
                  } else if (node.value || node.value === "") {
                    lastAdded = "value";
                    node.value += content;
                    if (node.raws.value) {
                      node.raws.value += content;
                    }
                  }
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.str:
                if (!node.attribute || !node.operator) {
                  return this.error("Expected an attribute followed by an operator preceding the string.", {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
                node.value = unescaped;
                node.quoteMark = quoteMark;
                lastAdded = "value";
                (0, _util.ensureObject)(node, "raws");
                node.raws.value = content;
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.equals:
                if (!node.attribute) {
                  return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
                }
                if (node.value) {
                  return this.error('Unexpected "=" found; an operator was already defined.', {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                node.operator = node.operator ? node.operator + content : content;
                lastAdded = "operator";
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.comment:
                if (lastAdded) {
                  if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                    var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "";
                    var rawLastComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                    (0, _util.ensureObject)(node, "raws", "spaces", lastAdded);
                    node.raws.spaces[lastAdded].after = rawLastComment + content;
                  } else {
                    var lastValue = node[lastAdded] || "";
                    var rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                    (0, _util.ensureObject)(node, "raws");
                    node.raws[lastAdded] = rawLastValue + content;
                  }
                } else {
                  commentBefore = commentBefore + content;
                }
                break;
              default:
                return this.error('Unexpected "' + content + '" found.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
            }
            pos++;
          }
          unescapeProp(node, "attribute");
          unescapeProp(node, "namespace");
          this.newNode(new _attribute["default"](node));
          this.position++;
        };
        _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
          if (stopPosition < 0) {
            stopPosition = this.tokens.length;
          }
          var startPosition = this.position;
          var nodes = [];
          var space = "";
          var lastComment = void 0;
          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
              if (!this.options.lossy) {
                space += this.content();
              }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces = {};
              if (space) {
                spaces.before = space;
                space = "";
              }
              lastComment = new _comment["default"]({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces
              });
              nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);
          if (space) {
            if (lastComment) {
              lastComment.spaces.after = space;
            } else if (!this.options.lossy) {
              var firstToken = this.tokens[startPosition];
              var lastToken = this.tokens[this.position - 1];
              nodes.push(new _string["default"]({
                value: "",
                source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: {
                  before: space,
                  after: ""
                }
              }));
            }
          }
          return nodes;
        };
        _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
          var _this2 = this;
          if (requiredSpace === void 0) {
            requiredSpace = false;
          }
          var space = "";
          var rawSpace = "";
          nodes.forEach(function(n2) {
            var spaceBefore = _this2.lossySpace(n2.spaces.before, requiredSpace);
            var rawSpaceBefore = _this2.lossySpace(n2.rawSpaceBefore, requiredSpace);
            space += spaceBefore + _this2.lossySpace(n2.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n2.value + _this2.lossySpace(n2.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
          });
          if (rawSpace === space) {
            rawSpace = void 0;
          }
          var result = {
            space,
            rawSpace
          };
          return result;
        };
        _proto.isNamedCombinator = function isNamedCombinator(position2) {
          if (position2 === void 0) {
            position2 = this.position;
          }
          return this.tokens[position2 + 0] && this.tokens[position2 + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position2 + 1] && this.tokens[position2 + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position2 + 2] && this.tokens[position2 + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        };
        _proto.namedCombinator = function namedCombinator() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};
            if (name !== nameRaw) {
              raws.value = "/" + nameRaw + "/";
            }
            var node = new _combinator["default"]({
              value: "/" + name + "/",
              source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws
            });
            this.position = this.position + 3;
            return node;
          } else {
            this.unexpected();
          }
        };
        _proto.combinator = function combinator() {
          var _this3 = this;
          if (this.content() === "|") {
            return this.namespace();
          }
          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
          if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
            if (nodes.length > 0) {
              var last = this.current.last;
              if (last) {
                var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
                if (rawSpace !== void 0) {
                  last.rawSpaceAfter += rawSpace;
                }
                last.spaces.after += space;
              } else {
                nodes.forEach(function(n2) {
                  return _this3.newNode(n2);
                });
              }
            }
            return;
          }
          var firstToken = this.currToken;
          var spaceOrDescendantSelectorNodes = void 0;
          if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          }
          var node;
          if (this.isNamedCombinator()) {
            node = this.namedCombinator();
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node = new _combinator["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
            });
            this.position++;
          } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
          } else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
          }
          if (node) {
            if (spaceOrDescendantSelectorNodes) {
              var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
              node.spaces.before = _space;
              node.rawSpaceBefore = _rawSpace;
            }
          } else {
            var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
            if (!_rawSpace2) {
              _rawSpace2 = _space2;
            }
            var spaces = {};
            var raws = {
              spaces: {}
            };
            if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
              spaces.before = _space2.slice(0, _space2.length - 1);
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
              spaces.after = _space2.slice(1);
              raws.spaces.after = _rawSpace2.slice(1);
            } else {
              raws.value = _rawSpace2;
            }
            node = new _combinator["default"]({
              value: " ",
              source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces,
              raws
            });
          }
          if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node.spaces.after = this.optionalSpace(this.content());
            this.position++;
          }
          return this.newNode(node);
        };
        _proto.comma = function comma() {
          if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
          }
          this.current._inferEndPosition();
          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position + 1])
            }
          });
          this.current.parent.append(selector);
          this.current = selector;
          this.position++;
        };
        _proto.comment = function comment2() {
          var current = this.currToken;
          this.newNode(new _comment["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.error = function error(message, opts) {
          throw this.root.error(message, opts);
        };
        _proto.missingBackslash = function missingBackslash() {
          return this.error("Expected a backslash preceding the semicolon.", {
            index: this.currToken[_tokenize.FIELDS.START_POS]
          });
        };
        _proto.missingParenthesis = function missingParenthesis() {
          return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.missingSquareBracket = function missingSquareBracket() {
          return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpected = function unexpected() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpectedPipe = function unexpectedPipe() {
          return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.namespace = function namespace() {
          var before = this.prevToken && this.content(this.prevToken) || true;
          if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
          } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
          }
          this.unexpectedPipe();
        };
        _proto.nesting = function nesting() {
          if (this.nextToken) {
            var nextContent = this.content(this.nextToken);
            if (nextContent === "|") {
              this.position++;
              return;
            }
          }
          var current = this.currToken;
          this.newNode(new _nesting["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.parentheses = function parentheses() {
          var last = this.current.last;
          var unbalanced = 1;
          this.position++;
          if (last && last.type === types2.PSEUDO) {
            var selector = new _selector["default"]({
              source: {
                start: tokenStart(this.tokens[this.position - 1])
              }
            });
            var cache3 = this.current;
            last.append(selector);
            this.current = selector;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              if (unbalanced) {
                this.parse();
              } else {
                this.current.source.end = tokenEnd(this.currToken);
                this.current.parent.source.end = tokenEnd(this.currToken);
                this.position++;
              }
            }
            this.current = cache3;
          } else {
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              parenEnd = this.currToken;
              parenValue += this.parseParenthesisToken(this.currToken);
              this.position++;
            }
            if (last) {
              last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
              this.newNode(new _string["default"]({
                value: parenValue,
                source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
              }));
            }
          }
          if (unbalanced) {
            return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.pseudo = function pseudo() {
          var _this4 = this;
          var pseudoStr = "";
          var startingToken = this.currToken;
          while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
          }
          if (!this.currToken) {
            return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function(first, length2) {
              pseudoStr += first;
              _this4.newNode(new _pseudo["default"]({
                value: pseudoStr,
                source: getTokenSourceSpan(startingToken, _this4.currToken),
                sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
              }));
              if (length2 > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                _this4.error("Misplaced parenthesis.", {
                  index: _this4.nextToken[_tokenize.FIELDS.START_POS]
                });
              }
            });
          } else {
            return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.space = function space() {
          var content = this.content();
          if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node) {
            return node.type === "comment";
          })) {
            this.spaces = this.optionalSpace(content);
            this.position++;
          } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content);
            this.position++;
          } else {
            this.combinator();
          }
        };
        _proto.string = function string() {
          var current = this.currToken;
          this.newNode(new _string["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.universal = function universal(namespace) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          var current = this.currToken;
          this.newNode(new _universal["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }), namespace);
          this.position++;
        };
        _proto.splitWord = function splitWord(namespace, firstCallback) {
          var _this5 = this;
          var nextToken = this.nextToken;
          var word = this.content();
          while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word += current;
            if (current.lastIndexOf("\\") === current.length - 1) {
              var next = this.nextToken;
              if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                word += this.requiredSpace(this.content(next));
                this.position++;
              }
            }
            nextToken = this.nextToken;
          }
          var hasClass = indexesOf(word, ".").filter(function(i) {
            var escapedDot = word[i - 1] === "\\";
            var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
            return !escapedDot && !isKeyframesPercent;
          });
          var hasId = indexesOf(word, "#").filter(function(i) {
            return word[i - 1] !== "\\";
          });
          var interpolations = indexesOf(word, "#{");
          if (interpolations.length) {
            hasId = hasId.filter(function(hashIndex) {
              return !~interpolations.indexOf(hashIndex);
            });
          }
          var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
          indices.forEach(function(ind, i) {
            var index2 = indices[i + 1] || word.length;
            var value2 = word.slice(ind, index2);
            if (i === 0 && firstCallback) {
              return firstCallback.call(_this5, value2, indices.length);
            }
            var node;
            var current2 = _this5.currToken;
            var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i];
            var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index2 - 1));
            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value2.slice(1),
                source,
                sourceIndex
              };
              node = new _className["default"](unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value2.slice(1),
                source,
                sourceIndex
              };
              node = new _id["default"](unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value: value2,
                source,
                sourceIndex
              };
              unescapeProp(tagOpts, "value");
              node = new _tag["default"](tagOpts);
            }
            _this5.newNode(node, namespace);
            namespace = null;
          });
          this.position++;
        };
        _proto.word = function word(namespace) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          return this.splitWord(namespace);
        };
        _proto.loop = function loop() {
          while (this.position < this.tokens.length) {
            this.parse(true);
          }
          this.current._inferEndPosition();
          return this.root;
        };
        _proto.parse = function parse4(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              this.space();
              break;
            case tokens.comment:
              this.comment();
              break;
            case tokens.openParenthesis:
              this.parentheses();
              break;
            case tokens.closeParenthesis:
              if (throwOnParenthesis) {
                this.missingParenthesis();
              }
              break;
            case tokens.openSquare:
              this.attribute();
              break;
            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
              this.word();
              break;
            case tokens.colon:
              this.pseudo();
              break;
            case tokens.comma:
              this.comma();
              break;
            case tokens.asterisk:
              this.universal();
              break;
            case tokens.ampersand:
              this.nesting();
              break;
            case tokens.slash:
            case tokens.combinator:
              this.combinator();
              break;
            case tokens.str:
              this.string();
              break;
            case tokens.closeSquare:
              this.missingSquareBracket();
            case tokens.semicolon:
              this.missingBackslash();
            default:
              this.unexpected();
          }
        };
        _proto.expected = function expected(description, index2, found) {
          if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(", ") + " or " + last;
          }
          var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
          if (!found) {
            return this.error("Expected " + an + " " + description + ".", {
              index: index2
            });
          }
          return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
            index: index2
          });
        };
        _proto.requiredSpace = function requiredSpace(space) {
          return this.options.lossy ? " " : space;
        };
        _proto.optionalSpace = function optionalSpace(space) {
          return this.options.lossy ? "" : space;
        };
        _proto.lossySpace = function lossySpace(space, required) {
          if (this.options.lossy) {
            return required ? " " : "";
          } else {
            return space;
          }
        };
        _proto.parseParenthesisToken = function parseParenthesisToken(token) {
          var content = this.content(token);
          if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content);
          } else {
            return content;
          }
        };
        _proto.newNode = function newNode(node, namespace) {
          if (namespace) {
            if (/^ +$/.test(namespace)) {
              if (!this.options.lossy) {
                this.spaces = (this.spaces || "") + namespace;
              }
              namespace = true;
            }
            node.namespace = namespace;
            unescapeProp(node, "namespace");
          }
          if (this.spaces) {
            node.spaces.before = this.spaces;
            this.spaces = "";
          }
          return this.current.append(node);
        };
        _proto.content = function content(token) {
          if (token === void 0) {
            token = this.currToken;
          }
          return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
        };
        _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
          if (startPosition === void 0) {
            startPosition = this.position + 1;
          }
          var searchPosition = startPosition;
          while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
              searchPosition++;
              continue;
            } else {
              return searchPosition;
            }
          }
          return -1;
        };
        _createClass(Parser2, [{
          key: "currToken",
          get: function get() {
            return this.tokens[this.position];
          }
        }, {
          key: "nextToken",
          get: function get() {
            return this.tokens[this.position + 1];
          }
        }, {
          key: "prevToken",
          get: function get() {
            return this.tokens[this.position - 1];
          }
        }]);
        return Parser2;
      }();
      exports["default"] = Parser;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/processor.js
  var require_processor2 = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/processor.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _parser = _interopRequireDefault(require_parser2());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var Processor2 = /* @__PURE__ */ function() {
        function Processor3(func, options) {
          this.func = func || function noop() {
          };
          this.funcRes = null;
          this.options = options;
        }
        var _proto = Processor3.prototype;
        _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          var merged = Object.assign({}, this.options, options);
          if (merged.updateSelector === false) {
            return false;
          } else {
            return typeof rule2 !== "string";
          }
        };
        _proto._isLossy = function _isLossy(options) {
          if (options === void 0) {
            options = {};
          }
          var merged = Object.assign({}, this.options, options);
          if (merged.lossless === false) {
            return true;
          } else {
            return false;
          }
        };
        _proto._root = function _root(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          var parser4 = new _parser["default"](rule2, this._parseOptions(options));
          return parser4.root;
        };
        _proto._parseOptions = function _parseOptions(options) {
          return {
            lossy: this._isLossy(options)
          };
        };
        _proto._run = function _run(rule2, options) {
          var _this = this;
          if (options === void 0) {
            options = {};
          }
          return new Promise(function(resolve2, reject) {
            try {
              var root2 = _this._root(rule2, options);
              Promise.resolve(_this.func(root2)).then(function(transform) {
                var string = void 0;
                if (_this._shouldUpdateSelector(rule2, options)) {
                  string = root2.toString();
                  rule2.selector = string;
                }
                return {
                  transform,
                  root: root2,
                  string
                };
              }).then(resolve2, reject);
            } catch (e2) {
              reject(e2);
              return;
            }
          });
        };
        _proto._runSync = function _runSync(rule2, options) {
          if (options === void 0) {
            options = {};
          }
          var root2 = this._root(rule2, options);
          var transform = this.func(root2);
          if (transform && typeof transform.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
          }
          var string = void 0;
          if (options.updateSelector && typeof rule2 !== "string") {
            string = root2.toString();
            rule2.selector = string;
          }
          return {
            transform,
            root: root2,
            string
          };
        };
        _proto.ast = function ast(rule2, options) {
          return this._run(rule2, options).then(function(result) {
            return result.root;
          });
        };
        _proto.astSync = function astSync(rule2, options) {
          return this._runSync(rule2, options).root;
        };
        _proto.transform = function transform(rule2, options) {
          return this._run(rule2, options).then(function(result) {
            return result.transform;
          });
        };
        _proto.transformSync = function transformSync(rule2, options) {
          return this._runSync(rule2, options).transform;
        };
        _proto.process = function process2(rule2, options) {
          return this._run(rule2, options).then(function(result) {
            return result.string || result.root.toString();
          });
        };
        _proto.processSync = function processSync(rule2, options) {
          var result = this._runSync(rule2, options);
          return result.string || result.root.toString();
        };
        return Processor3;
      }();
      exports["default"] = Processor2;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/constructors.js
  var require_constructors = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/constructors.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;
      var _attribute = _interopRequireDefault(require_attribute());
      var _className = _interopRequireDefault(require_className());
      var _combinator = _interopRequireDefault(require_combinator());
      var _comment = _interopRequireDefault(require_comment2());
      var _id = _interopRequireDefault(require_id());
      var _nesting = _interopRequireDefault(require_nesting());
      var _pseudo = _interopRequireDefault(require_pseudo());
      var _root = _interopRequireDefault(require_root2());
      var _selector = _interopRequireDefault(require_selector());
      var _string = _interopRequireDefault(require_string());
      var _tag = _interopRequireDefault(require_tag());
      var _universal = _interopRequireDefault(require_universal());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var attribute = function attribute2(opts) {
        return new _attribute["default"](opts);
      };
      exports.attribute = attribute;
      var className = function className2(opts) {
        return new _className["default"](opts);
      };
      exports.className = className;
      var combinator = function combinator2(opts) {
        return new _combinator["default"](opts);
      };
      exports.combinator = combinator;
      var comment2 = function comment3(opts) {
        return new _comment["default"](opts);
      };
      exports.comment = comment2;
      var id = function id2(opts) {
        return new _id["default"](opts);
      };
      exports.id = id;
      var nesting = function nesting2(opts) {
        return new _nesting["default"](opts);
      };
      exports.nesting = nesting;
      var pseudo = function pseudo2(opts) {
        return new _pseudo["default"](opts);
      };
      exports.pseudo = pseudo;
      var root2 = function root3(opts) {
        return new _root["default"](opts);
      };
      exports.root = root2;
      var selector = function selector2(opts) {
        return new _selector["default"](opts);
      };
      exports.selector = selector;
      var string = function string2(opts) {
        return new _string["default"](opts);
      };
      exports.string = string;
      var tag = function tag2(opts) {
        return new _tag["default"](opts);
      };
      exports.tag = tag;
      var universal = function universal2(opts) {
        return new _universal["default"](opts);
      };
      exports.universal = universal;
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/guards.js
  var require_guards = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/guards.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;
      exports.isContainer = isContainer;
      exports.isIdentifier = void 0;
      exports.isNamespace = isNamespace;
      exports.isNesting = void 0;
      exports.isNode = isNode;
      exports.isPseudo = void 0;
      exports.isPseudoClass = isPseudoClass;
      exports.isPseudoElement = isPseudoElement2;
      exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = void 0;
      var _types = require_types();
      var _IS_TYPE;
      var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
      function isNode(node) {
        return typeof node === "object" && IS_TYPE[node.type];
      }
      function isNodeType(type, node) {
        return isNode(node) && node.type === type;
      }
      var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
      exports.isAttribute = isAttribute;
      var isClassName = isNodeType.bind(null, _types.CLASS);
      exports.isClassName = isClassName;
      var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
      exports.isCombinator = isCombinator;
      var isComment = isNodeType.bind(null, _types.COMMENT);
      exports.isComment = isComment;
      var isIdentifier = isNodeType.bind(null, _types.ID);
      exports.isIdentifier = isIdentifier;
      var isNesting = isNodeType.bind(null, _types.NESTING);
      exports.isNesting = isNesting;
      var isPseudo2 = isNodeType.bind(null, _types.PSEUDO);
      exports.isPseudo = isPseudo2;
      var isRoot2 = isNodeType.bind(null, _types.ROOT);
      exports.isRoot = isRoot2;
      var isSelector = isNodeType.bind(null, _types.SELECTOR);
      exports.isSelector = isSelector;
      var isString2 = isNodeType.bind(null, _types.STRING);
      exports.isString = isString2;
      var isTag = isNodeType.bind(null, _types.TAG);
      exports.isTag = isTag;
      var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
      exports.isUniversal = isUniversal;
      function isPseudoElement2(node) {
        return isPseudo2(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
      }
      function isPseudoClass(node) {
        return isPseudo2(node) && !isPseudoElement2(node);
      }
      function isContainer(node) {
        return !!(isNode(node) && node.walk);
      }
      function isNamespace(node) {
        return isAttribute(node) || isTag(node);
      }
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/index.js
  var require_selectors = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/selectors/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      var _types = require_types();
      Object.keys(_types).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _types[key])
          return;
        exports[key] = _types[key];
      });
      var _constructors = require_constructors();
      Object.keys(_constructors).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _constructors[key])
          return;
        exports[key] = _constructors[key];
      });
      var _guards = require_guards();
      Object.keys(_guards).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _guards[key])
          return;
        exports[key] = _guards[key];
      });
    }
  });

  // node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/index.js
  var require_dist = __commonJS({
    "node_modules/.pnpm/postcss-selector-parser@6.0.16/node_modules/postcss-selector-parser/dist/index.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = void 0;
      var _processor = _interopRequireDefault(require_processor2());
      var selectors = _interopRequireWildcard(require_selectors());
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache3 = _getRequireWildcardCache(nodeInterop);
        if (cache3 && cache3.has(obj)) {
          return cache3.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache3) {
          cache3.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var parser4 = function parser5(processor) {
        return new _processor["default"](processor);
      };
      Object.assign(parser4, selectors);
      delete parser4.__esModule;
      var _default = parser4;
      exports["default"] = _default;
      module.exports = exports.default;
    }
  });

  // node_modules/.pnpm/postcss-nested@6.0.1_postcss@8.4.38/node_modules/postcss-nested/index.js
  var require_postcss_nested = __commonJS({
    "node_modules/.pnpm/postcss-nested@6.0.1_postcss@8.4.38/node_modules/postcss-nested/index.js"(exports, module) {
      var { Rule: Rule2, AtRule: AtRule2 } = require_postcss();
      var parser4 = require_dist();
      function parse4(rawSelector, rule2) {
        let nodes;
        try {
          parser4((parsed) => {
            nodes = parsed;
          }).processSync(rawSelector);
        } catch (e2) {
          if (rawSelector.includes(":")) {
            throw rule2 ? rule2.error("Missed semicolon") : e2;
          } else {
            throw rule2 ? rule2.error(e2.message) : e2;
          }
        }
        return nodes.at(0);
      }
      function interpolateAmpInSelector(nodes, parent) {
        let replaced = false;
        nodes.each((node) => {
          if (node.type === "nesting") {
            let clonedParent = parent.clone({});
            if (node.value !== "&") {
              node.replaceWith(
                parse4(node.value.replace("&", clonedParent.toString()))
              );
            } else {
              node.replaceWith(clonedParent);
            }
            replaced = true;
          } else if ("nodes" in node && node.nodes) {
            if (interpolateAmpInSelector(node, parent)) {
              replaced = true;
            }
          }
        });
        return replaced;
      }
      function mergeSelectors(parent, child) {
        let merged = [];
        parent.selectors.forEach((sel) => {
          let parentNode = parse4(sel, parent);
          child.selectors.forEach((selector) => {
            if (!selector) {
              return;
            }
            let node = parse4(selector, child);
            let replaced = interpolateAmpInSelector(node, parentNode);
            if (!replaced) {
              node.prepend(parser4.combinator({ value: " " }));
              node.prepend(parentNode.clone({}));
            }
            merged.push(node.toString());
          });
        });
        return merged;
      }
      function breakOut(child, after) {
        let prev = child.prev();
        after.after(child);
        while (prev && prev.type === "comment") {
          let nextPrev = prev.prev();
          after.after(prev);
          prev = nextPrev;
        }
        return child;
      }
      function createFnAtruleChilds(bubble) {
        return function atruleChilds(rule2, atrule, bubbling, mergeSels = bubbling) {
          let children = [];
          atrule.each((child) => {
            if (child.type === "rule" && bubbling) {
              if (mergeSels) {
                child.selectors = mergeSelectors(rule2, child);
              }
            } else if (child.type === "atrule" && child.nodes) {
              if (bubble[child.name]) {
                atruleChilds(rule2, child, mergeSels);
              } else if (atrule[rootRuleMergeSel] !== false) {
                children.push(child);
              }
            } else {
              children.push(child);
            }
          });
          if (bubbling) {
            if (children.length) {
              let clone = rule2.clone({ nodes: [] });
              for (let child of children) {
                clone.append(child);
              }
              atrule.prepend(clone);
            }
          }
        };
      }
      function pickDeclarations(selector, declarations, after) {
        let parent = new Rule2({
          selector,
          nodes: []
        });
        parent.append(declarations);
        after.after(parent);
        return parent;
      }
      function atruleNames(defaults3, custom) {
        let list3 = {};
        for (let name of defaults3) {
          list3[name] = true;
        }
        if (custom) {
          for (let name of custom) {
            list3[name.replace(/^@/, "")] = true;
          }
        }
        return list3;
      }
      function parseRootRuleParams(params) {
        params = params.trim();
        let braceBlock = params.match(/^\((.*)\)$/);
        if (!braceBlock) {
          return { type: "basic", selector: params };
        }
        let bits = braceBlock[1].match(/^(with(?:out)?):(.+)$/);
        if (bits) {
          let allowlist = bits[1] === "with";
          let rules = Object.fromEntries(
            bits[2].trim().split(/\s+/).map((name) => [name, true])
          );
          if (allowlist && rules.all) {
            return { type: "noop" };
          }
          let escapes = (rule2) => !!rules[rule2];
          if (rules.all) {
            escapes = () => true;
          } else if (allowlist) {
            escapes = (rule2) => rule2 === "all" ? false : !rules[rule2];
          }
          return {
            type: "withrules",
            escapes
          };
        }
        return { type: "unknown" };
      }
      function getAncestorRules(leaf) {
        let lineage = [];
        let parent = leaf.parent;
        while (parent && parent instanceof AtRule2) {
          lineage.push(parent);
          parent = parent.parent;
        }
        return lineage;
      }
      function unwrapRootRule(rule2) {
        let escapes = rule2[rootRuleEscapes];
        if (!escapes) {
          rule2.after(rule2.nodes);
        } else {
          let nodes = rule2.nodes;
          let topEscaped;
          let topEscapedIdx = -1;
          let breakoutLeaf;
          let breakoutRoot;
          let clone;
          let lineage = getAncestorRules(rule2);
          lineage.forEach((parent, i) => {
            if (escapes(parent.name)) {
              topEscaped = parent;
              topEscapedIdx = i;
              breakoutRoot = clone;
            } else {
              let oldClone = clone;
              clone = parent.clone({ nodes: [] });
              oldClone && clone.append(oldClone);
              breakoutLeaf = breakoutLeaf || clone;
            }
          });
          if (!topEscaped) {
            rule2.after(nodes);
          } else if (!breakoutRoot) {
            topEscaped.after(nodes);
          } else {
            let leaf = breakoutLeaf;
            leaf.append(nodes);
            topEscaped.after(breakoutRoot);
          }
          if (rule2.next() && topEscaped) {
            let restRoot;
            lineage.slice(0, topEscapedIdx + 1).forEach((parent, i, arr) => {
              let oldRoot = restRoot;
              restRoot = parent.clone({ nodes: [] });
              oldRoot && restRoot.append(oldRoot);
              let nextSibs = [];
              let _child = arr[i - 1] || rule2;
              let next = _child.next();
              while (next) {
                nextSibs.push(next);
                next = next.next();
              }
              restRoot.append(nextSibs);
            });
            restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot);
          }
        }
        rule2.remove();
      }
      var rootRuleMergeSel = Symbol("rootRuleMergeSel");
      var rootRuleEscapes = Symbol("rootRuleEscapes");
      function normalizeRootRule(rule2) {
        let { params } = rule2;
        let { type, selector, escapes } = parseRootRuleParams(params);
        if (type === "unknown") {
          throw rule2.error(
            `Unknown @${rule2.name} parameter ${JSON.stringify(params)}`
          );
        }
        if (type === "basic" && selector) {
          let selectorBlock = new Rule2({ selector, nodes: rule2.nodes });
          rule2.removeAll();
          rule2.append(selectorBlock);
        }
        rule2[rootRuleEscapes] = escapes;
        rule2[rootRuleMergeSel] = escapes ? !escapes("all") : type === "noop";
      }
      var hasRootRule = Symbol("hasRootRule");
      module.exports = (opts = {}) => {
        let bubble = atruleNames(
          ["media", "supports", "layer", "container"],
          opts.bubble
        );
        let atruleChilds = createFnAtruleChilds(bubble);
        let unwrap = atruleNames(
          [
            "document",
            "font-face",
            "keyframes",
            "-webkit-keyframes",
            "-moz-keyframes"
          ],
          opts.unwrap
        );
        let rootRuleName = (opts.rootRuleName || "at-root").replace(/^@/, "");
        let preserveEmpty = opts.preserveEmpty;
        return {
          postcssPlugin: "postcss-nested",
          Once(root2) {
            root2.walkAtRules(rootRuleName, (node) => {
              normalizeRootRule(node);
              root2[hasRootRule] = true;
            });
          },
          Rule(rule2) {
            let unwrapped = false;
            let after = rule2;
            let copyDeclarations = false;
            let declarations = [];
            rule2.each((child) => {
              if (child.type === "rule") {
                if (declarations.length) {
                  after = pickDeclarations(rule2.selector, declarations, after);
                  declarations = [];
                }
                copyDeclarations = true;
                unwrapped = true;
                child.selectors = mergeSelectors(rule2, child);
                after = breakOut(child, after);
              } else if (child.type === "atrule") {
                if (declarations.length) {
                  after = pickDeclarations(rule2.selector, declarations, after);
                  declarations = [];
                }
                if (child.name === rootRuleName) {
                  unwrapped = true;
                  atruleChilds(rule2, child, true, child[rootRuleMergeSel]);
                  after = breakOut(child, after);
                } else if (bubble[child.name]) {
                  copyDeclarations = true;
                  unwrapped = true;
                  atruleChilds(rule2, child, true);
                  after = breakOut(child, after);
                } else if (unwrap[child.name]) {
                  copyDeclarations = true;
                  unwrapped = true;
                  atruleChilds(rule2, child, false);
                  after = breakOut(child, after);
                } else if (copyDeclarations) {
                  declarations.push(child);
                }
              } else if (child.type === "decl" && copyDeclarations) {
                declarations.push(child);
              }
            });
            if (declarations.length) {
              after = pickDeclarations(rule2.selector, declarations, after);
            }
            if (unwrapped && preserveEmpty !== true) {
              rule2.raws.semicolon = true;
              if (rule2.nodes.length === 0)
                rule2.remove();
            }
          },
          RootExit(root2) {
            if (root2[hasRootRule]) {
              root2.walkAtRules(rootRuleName, unwrapRootRule);
              root2[hasRootRule] = false;
            }
          }
        };
      };
      module.exports.postcss = true;
    }
  });

  // node_modules/.pnpm/camelcase-css@2.0.1/node_modules/camelcase-css/index-es5.js
  var require_index_es5 = __commonJS({
    "node_modules/.pnpm/camelcase-css@2.0.1/node_modules/camelcase-css/index-es5.js"(exports, module) {
      "use strict";
      var pattern2 = /-(\w|$)/g;
      var callback = function callback2(dashChar, char) {
        return char.toUpperCase();
      };
      var camelCaseCSS = function camelCaseCSS2(property) {
        property = property.toLowerCase();
        if (property === "float") {
          return "cssFloat";
        } else if (property.charCodeAt(0) === 45 && property.charCodeAt(1) === 109 && property.charCodeAt(2) === 115 && property.charCodeAt(3) === 45) {
          return property.substr(1).replace(pattern2, callback);
        } else {
          return property.replace(pattern2, callback);
        }
      };
      module.exports = camelCaseCSS;
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/objectifier.js
  var require_objectifier = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/objectifier.js"(exports, module) {
      var camelcase = require_index_es5();
      var UNITLESS = {
        boxFlex: true,
        boxFlexGroup: true,
        columnCount: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        strokeDashoffset: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function atRule2(node) {
        if (typeof node.nodes === "undefined") {
          return true;
        } else {
          return process2(node);
        }
      }
      function process2(node) {
        let name;
        let result = {};
        node.each((child) => {
          if (child.type === "atrule") {
            name = "@" + child.name;
            if (child.params)
              name += " " + child.params;
            if (typeof result[name] === "undefined") {
              result[name] = atRule2(child);
            } else if (Array.isArray(result[name])) {
              result[name].push(atRule2(child));
            } else {
              result[name] = [result[name], atRule2(child)];
            }
          } else if (child.type === "rule") {
            let body = process2(child);
            if (result[child.selector]) {
              for (let i in body) {
                result[child.selector][i] = body[i];
              }
            } else {
              result[child.selector] = body;
            }
          } else if (child.type === "decl") {
            if (child.prop[0] === "-" && child.prop[1] === "-") {
              name = child.prop;
            } else if (child.parent && child.parent.selector === ":export") {
              name = child.prop;
            } else {
              name = camelcase(child.prop);
            }
            let value2 = child.value;
            if (!isNaN(child.value) && UNITLESS[name]) {
              value2 = parseFloat(child.value);
            }
            if (child.important)
              value2 += " !important";
            if (typeof result[name] === "undefined") {
              result[name] = value2;
            } else if (Array.isArray(result[name])) {
              result[name].push(value2);
            } else {
              result[name] = [result[name], value2];
            }
          }
        });
        return result;
      }
      module.exports = process2;
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/parser.js
  var require_parser3 = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/parser.js"(exports, module) {
      var postcss2 = require_postcss();
      var IMPORTANT = /\s*!important\s*$/i;
      var UNITLESS = {
        "box-flex": true,
        "box-flex-group": true,
        "column-count": true,
        "flex": true,
        "flex-grow": true,
        "flex-positive": true,
        "flex-shrink": true,
        "flex-negative": true,
        "font-weight": true,
        "line-clamp": true,
        "line-height": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "tab-size": true,
        "widows": true,
        "z-index": true,
        "zoom": true,
        "fill-opacity": true,
        "stroke-dashoffset": true,
        "stroke-opacity": true,
        "stroke-width": true
      };
      function dashify(str) {
        return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
      }
      function decl2(parent, name, value2) {
        if (value2 === false || value2 === null)
          return;
        if (!name.startsWith("--")) {
          name = dashify(name);
        }
        if (typeof value2 === "number") {
          if (value2 === 0 || UNITLESS[name]) {
            value2 = value2.toString();
          } else {
            value2 += "px";
          }
        }
        if (name === "css-float")
          name = "float";
        if (IMPORTANT.test(value2)) {
          value2 = value2.replace(IMPORTANT, "");
          parent.push(postcss2.decl({ prop: name, value: value2, important: true }));
        } else {
          parent.push(postcss2.decl({ prop: name, value: value2 }));
        }
      }
      function atRule2(parent, parts, value2) {
        let node = postcss2.atRule({ name: parts[1], params: parts[3] || "" });
        if (typeof value2 === "object") {
          node.nodes = [];
          parse4(value2, node);
        }
        parent.push(node);
      }
      function parse4(obj, parent) {
        let name, value2, node;
        for (name in obj) {
          value2 = obj[name];
          if (value2 === null || typeof value2 === "undefined") {
            continue;
          } else if (name[0] === "@") {
            let parts = name.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
            if (Array.isArray(value2)) {
              for (let i of value2) {
                atRule2(parent, parts, i);
              }
            } else {
              atRule2(parent, parts, value2);
            }
          } else if (Array.isArray(value2)) {
            for (let i of value2) {
              decl2(parent, name, i);
            }
          } else if (typeof value2 === "object") {
            node = postcss2.rule({ selector: name });
            parse4(value2, node);
            parent.push(node);
          } else {
            decl2(parent, name, value2);
          }
        }
      }
      module.exports = function(obj) {
        let root2 = postcss2.root();
        parse4(obj, root2);
        return root2;
      };
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/process-result.js
  var require_process_result = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/process-result.js"(exports, module) {
      var objectify2 = require_objectifier();
      module.exports = function processResult(result) {
        if (console && console.warn) {
          result.warnings().forEach((warn2) => {
            let source = warn2.plugin || "PostCSS";
            console.warn(source + ": " + warn2.text);
          });
        }
        return objectify2(result.root);
      };
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/async.js
  var require_async = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/async.js"(exports, module) {
      var postcss2 = require_postcss();
      var processResult = require_process_result();
      var parse4 = require_parser3();
      module.exports = function async2(plugins) {
        let processor = postcss2(plugins);
        return async (input) => {
          let result = await processor.process(input, {
            parser: parse4,
            from: void 0
          });
          return processResult(result);
        };
      };
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/sync.js
  var require_sync = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/sync.js"(exports, module) {
      var postcss2 = require_postcss();
      var processResult = require_process_result();
      var parse4 = require_parser3();
      module.exports = function(plugins) {
        let processor = postcss2(plugins);
        return (input) => {
          let result = processor.process(input, { parser: parse4, from: void 0 });
          return processResult(result);
        };
      };
    }
  });

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/index.js
  var require_postcss_js = __commonJS({
    "node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/index.js"(exports, module) {
      var objectify2 = require_objectifier();
      var parse4 = require_parser3();
      var async2 = require_async();
      var sync2 = require_sync();
      module.exports = {
        objectify: objectify2,
        parse: parse4,
        async: async2,
        sync: sync2
      };
    }
  });

  // node_modules/.pnpm/dlv@1.1.3/node_modules/dlv/dist/dlv.umd.js
  var require_dlv_umd = __commonJS({
    "node_modules/.pnpm/dlv@1.1.3/node_modules/dlv/dist/dlv.umd.js"(exports, module) {
      !function(t, n2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = function(t2, n3, e2, i, o) {
          for (n3 = n3.split ? n3.split(".") : n3, i = 0; i < n3.length; i++)
            t2 = t2 ? t2[n3[i]] : o;
          return t2 === o ? e2 : t2;
        } : "function" == typeof define && define.amd ? define(function() {
          return function(t2, n3, e2, i, o) {
            for (n3 = n3.split ? n3.split(".") : n3, i = 0; i < n3.length; i++)
              t2 = t2 ? t2[n3[i]] : o;
            return t2 === o ? e2 : t2;
          };
        }) : t.dlv = function(t2, n3, e2, i, o) {
          for (n3 = n3.split ? n3.split(".") : n3, i = 0; i < n3.length; i++)
            t2 = t2 ? t2[n3[i]] : o;
          return t2 === o ? e2 : t2;
        };
      }(exports);
    }
  });

  // node_modules/.pnpm/didyoumean@1.2.2/node_modules/didyoumean/didYouMean-1.2.1.js
  var require_didYouMean_1_2_1 = __commonJS({
    "node_modules/.pnpm/didyoumean@1.2.2/node_modules/didyoumean/didYouMean-1.2.1.js"(exports, module) {
      (function() {
        "use strict";
        function didYouMean2(str, list3, key) {
          if (!str)
            return null;
          if (!didYouMean2.caseSensitive) {
            str = str.toLowerCase();
          }
          var thresholdRelative = didYouMean2.threshold === null ? null : didYouMean2.threshold * str.length, thresholdAbsolute = didYouMean2.thresholdAbsolute, winningVal;
          if (thresholdRelative !== null && thresholdAbsolute !== null)
            winningVal = Math.min(thresholdRelative, thresholdAbsolute);
          else if (thresholdRelative !== null)
            winningVal = thresholdRelative;
          else if (thresholdAbsolute !== null)
            winningVal = thresholdAbsolute;
          else
            winningVal = null;
          var winner, candidate, testCandidate, val, i, len = list3.length;
          for (i = 0; i < len; i++) {
            candidate = list3[i];
            if (key) {
              candidate = candidate[key];
            }
            if (!candidate) {
              continue;
            }
            if (!didYouMean2.caseSensitive) {
              testCandidate = candidate.toLowerCase();
            } else {
              testCandidate = candidate;
            }
            val = getEditDistance(str, testCandidate, winningVal);
            if (winningVal === null || val < winningVal) {
              winningVal = val;
              if (key && didYouMean2.returnWinningObject)
                winner = list3[i];
              else
                winner = candidate;
              if (didYouMean2.returnFirstMatch)
                return winner;
            }
          }
          return winner || didYouMean2.nullResultValue;
        }
        didYouMean2.threshold = 0.4;
        didYouMean2.thresholdAbsolute = 20;
        didYouMean2.caseSensitive = false;
        didYouMean2.nullResultValue = null;
        didYouMean2.returnWinningObject = null;
        didYouMean2.returnFirstMatch = false;
        if (typeof module !== "undefined" && module.exports) {
          module.exports = didYouMean2;
        } else {
          window.didYouMean = didYouMean2;
        }
        var MAX_INT = Math.pow(2, 32) - 1;
        function getEditDistance(a, b, max2) {
          max2 = max2 || max2 === 0 ? max2 : MAX_INT;
          var lena = a.length;
          var lenb = b.length;
          if (lena === 0)
            return Math.min(max2 + 1, lenb);
          if (lenb === 0)
            return Math.min(max2 + 1, lena);
          if (Math.abs(lena - lenb) > max2)
            return max2 + 1;
          var matrix = [], i, j, colMin, minJ, maxJ;
          for (i = 0; i <= lenb; i++) {
            matrix[i] = [i];
          }
          for (j = 0; j <= lena; j++) {
            matrix[0][j] = j;
          }
          for (i = 1; i <= lenb; i++) {
            colMin = MAX_INT;
            minJ = 1;
            if (i > max2)
              minJ = i - max2;
            maxJ = lenb + 1;
            if (maxJ > max2 + i)
              maxJ = max2 + i;
            for (j = 1; j <= lena; j++) {
              if (j < minJ || j > maxJ) {
                matrix[i][j] = max2 + 1;
              } else {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                  matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                  matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    // Substitute
                    Math.min(
                      matrix[i][j - 1] + 1,
                      // Insert
                      matrix[i - 1][j] + 1
                    )
                  );
                }
              }
              if (matrix[i][j] < colMin)
                colMin = matrix[i][j];
            }
            if (colMin > max2)
              return max2 + 1;
          }
          return matrix[lenb][lena];
        }
      })();
    }
  });

  // node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js
  var require_parse2 = __commonJS({
    "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js"(exports, module) {
      var openParentheses = "(".charCodeAt(0);
      var closeParentheses = ")".charCodeAt(0);
      var singleQuote = "'".charCodeAt(0);
      var doubleQuote = '"'.charCodeAt(0);
      var backslash = "\\".charCodeAt(0);
      var slash = "/".charCodeAt(0);
      var comma = ",".charCodeAt(0);
      var colon = ":".charCodeAt(0);
      var star = "*".charCodeAt(0);
      var uLower = "u".charCodeAt(0);
      var uUpper = "U".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var isUnicodeRange = /^[a-f0-9?-]+$/i;
      module.exports = function(input) {
        var tokens = [];
        var value2 = input;
        var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
        var pos = 0;
        var code = value2.charCodeAt(pos);
        var max2 = value2.length;
        var stack = [{ nodes: tokens }];
        var balanced = 0;
        var parent;
        var name = "";
        var before = "";
        var after = "";
        while (pos < max2) {
          if (code <= 32) {
            next = pos;
            do {
              next += 1;
              code = value2.charCodeAt(next);
            } while (code <= 32);
            token = value2.slice(pos, next);
            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
              after = token;
            } else if (prev && prev.type === "div") {
              prev.after = token;
              prev.sourceEndIndex += token.length;
            } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
              before = token;
            } else {
              tokens.push({
                type: "space",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token
              });
            }
            pos = next;
          } else if (code === singleQuote || code === doubleQuote) {
            next = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
              type: "string",
              sourceIndex: pos,
              quote
            };
            do {
              escape2 = false;
              next = value2.indexOf(quote, next + 1);
              if (~next) {
                escapePos = next;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += quote;
                next = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            token.value = value2.slice(pos + 1, next);
            token.sourceEndIndex = token.unclosed ? next : next + 1;
            tokens.push(token);
            pos = next + 1;
            code = value2.charCodeAt(pos);
          } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
            next = value2.indexOf("*/", pos);
            token = {
              type: "comment",
              sourceIndex: pos,
              sourceEndIndex: next + 2
            };
            if (next === -1) {
              token.unclosed = true;
              next = value2.length;
              token.sourceEndIndex = next;
            }
            token.value = value2.slice(pos + 2, next);
            tokens.push(token);
            pos = next + 2;
            code = value2.charCodeAt(pos);
          } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
            token = value2[pos];
            tokens.push({
              type: "word",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token
            });
            pos += 1;
            code = value2.charCodeAt(pos);
          } else if (code === slash || code === comma || code === colon) {
            token = value2[pos];
            tokens.push({
              type: "div",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token,
              before,
              after: ""
            });
            before = "";
            pos += 1;
            code = value2.charCodeAt(pos);
          } else if (openParentheses === code) {
            next = pos;
            do {
              next += 1;
              code = value2.charCodeAt(next);
            } while (code <= 32);
            parenthesesOpenPos = pos;
            token = {
              type: "function",
              sourceIndex: pos - name.length,
              value: name,
              before: value2.slice(parenthesesOpenPos + 1, next)
            };
            pos = next;
            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
              next -= 1;
              do {
                escape2 = false;
                next = value2.indexOf(")", next + 1);
                if (~next) {
                  escapePos = next;
                  while (value2.charCodeAt(escapePos - 1) === backslash) {
                    escapePos -= 1;
                    escape2 = !escape2;
                  }
                } else {
                  value2 += ")";
                  next = value2.length - 1;
                  token.unclosed = true;
                }
              } while (escape2);
              whitespacePos = next;
              do {
                whitespacePos -= 1;
                code = value2.charCodeAt(whitespacePos);
              } while (code <= 32);
              if (parenthesesOpenPos < whitespacePos) {
                if (pos !== whitespacePos + 1) {
                  token.nodes = [
                    {
                      type: "word",
                      sourceIndex: pos,
                      sourceEndIndex: whitespacePos + 1,
                      value: value2.slice(pos, whitespacePos + 1)
                    }
                  ];
                } else {
                  token.nodes = [];
                }
                if (token.unclosed && whitespacePos + 1 !== next) {
                  token.after = "";
                  token.nodes.push({
                    type: "space",
                    sourceIndex: whitespacePos + 1,
                    sourceEndIndex: next,
                    value: value2.slice(whitespacePos + 1, next)
                  });
                } else {
                  token.after = value2.slice(whitespacePos + 1, next);
                  token.sourceEndIndex = next;
                }
              } else {
                token.after = "";
                token.nodes = [];
              }
              pos = next + 1;
              token.sourceEndIndex = token.unclosed ? next : pos;
              code = value2.charCodeAt(pos);
              tokens.push(token);
            } else {
              balanced += 1;
              token.after = "";
              token.sourceEndIndex = pos + 1;
              tokens.push(token);
              stack.push(token);
              tokens = token.nodes = [];
              parent = token;
            }
            name = "";
          } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value2.charCodeAt(pos);
            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;
          } else {
            next = pos;
            do {
              if (code === backslash) {
                next += 1;
              }
              next += 1;
              code = value2.charCodeAt(next);
            } while (next < max2 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
            token = value2.slice(pos, next);
            if (openParentheses === code) {
              name = token;
            } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
              tokens.push({
                type: "unicode-range",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token
              });
            } else {
              tokens.push({
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token
              });
            }
            pos = next;
          }
        }
        for (pos = stack.length - 1; pos; pos -= 1) {
          stack[pos].unclosed = true;
          stack[pos].sourceEndIndex = value2.length;
        }
        return stack[0].nodes;
      };
    }
  });

  // node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/walk.js
  var require_walk = __commonJS({
    "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/walk.js"(exports, module) {
      module.exports = function walk(nodes, cb, bubble) {
        var i, max2, node, result;
        for (i = 0, max2 = nodes.length; i < max2; i += 1) {
          node = nodes[i];
          if (!bubble) {
            result = cb(node, i, nodes);
          }
          if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
            walk(node.nodes, cb, bubble);
          }
          if (bubble) {
            cb(node, i, nodes);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/stringify.js
  var require_stringify2 = __commonJS({
    "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/stringify.js"(exports, module) {
      function stringifyNode(node, custom) {
        var type = node.type;
        var value2 = node.value;
        var buf;
        var customResult;
        if (custom && (customResult = custom(node)) !== void 0) {
          return customResult;
        } else if (type === "word" || type === "space") {
          return value2;
        } else if (type === "string") {
          buf = node.quote || "";
          return buf + value2 + (node.unclosed ? "" : buf);
        } else if (type === "comment") {
          return "/*" + value2 + (node.unclosed ? "" : "*/");
        } else if (type === "div") {
          return (node.before || "") + value2 + (node.after || "");
        } else if (Array.isArray(node.nodes)) {
          buf = stringify2(node.nodes, custom);
          if (type !== "function") {
            return buf;
          }
          return value2 + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
        }
        return value2;
      }
      function stringify2(nodes, custom) {
        var result, i;
        if (Array.isArray(nodes)) {
          result = "";
          for (i = nodes.length - 1; ~i; i -= 1) {
            result = stringifyNode(nodes[i], custom) + result;
          }
          return result;
        }
        return stringifyNode(nodes, custom);
      }
      module.exports = stringify2;
    }
  });

  // node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js
  var require_unit = __commonJS({
    "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js"(exports, module) {
      var minus = "-".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var dot = ".".charCodeAt(0);
      var exp = "e".charCodeAt(0);
      var EXP = "E".charCodeAt(0);
      function likeNumber(value2) {
        var code = value2.charCodeAt(0);
        var nextCode;
        if (code === plus || code === minus) {
          nextCode = value2.charCodeAt(1);
          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }
          var nextNextCode = value2.charCodeAt(2);
          if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
          }
          return false;
        }
        if (code === dot) {
          nextCode = value2.charCodeAt(1);
          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }
          return false;
        }
        if (code >= 48 && code <= 57) {
          return true;
        }
        return false;
      }
      module.exports = function(value2) {
        var pos = 0;
        var length2 = value2.length;
        var code;
        var nextCode;
        var nextNextCode;
        if (length2 === 0 || !likeNumber(value2)) {
          return false;
        }
        code = value2.charCodeAt(pos);
        if (code === plus || code === minus) {
          pos++;
        }
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
        code = value2.charCodeAt(pos);
        nextCode = value2.charCodeAt(pos + 1);
        if (code === dot && nextCode >= 48 && nextCode <= 57) {
          pos += 2;
          while (pos < length2) {
            code = value2.charCodeAt(pos);
            if (code < 48 || code > 57) {
              break;
            }
            pos += 1;
          }
        }
        code = value2.charCodeAt(pos);
        nextCode = value2.charCodeAt(pos + 1);
        nextNextCode = value2.charCodeAt(pos + 2);
        if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
          pos += nextCode === plus || nextCode === minus ? 3 : 2;
          while (pos < length2) {
            code = value2.charCodeAt(pos);
            if (code < 48 || code > 57) {
              break;
            }
            pos += 1;
          }
        }
        return {
          number: value2.slice(0, pos),
          unit: value2.slice(pos)
        };
      };
    }
  });

  // node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/index.js
  var require_lib = __commonJS({
    "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/index.js"(exports, module) {
      var parse4 = require_parse2();
      var walk = require_walk();
      var stringify2 = require_stringify2();
      function ValueParser(value2) {
        if (this instanceof ValueParser) {
          this.nodes = parse4(value2);
          return this;
        }
        return new ValueParser(value2);
      }
      ValueParser.prototype.toString = function() {
        return Array.isArray(this.nodes) ? stringify2(this.nodes) : "";
      };
      ValueParser.prototype.walk = function(cb, bubble) {
        walk(this.nodes, cb, bubble);
        return this;
      };
      ValueParser.unit = require_unit();
      ValueParser.walk = walk;
      ValueParser.stringify = stringify2;
      module.exports = ValueParser;
    }
  });

  // node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js
  var require_isarray = __commonJS({
    "node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js"(exports, module) {
      var toString2 = {}.toString;
      module.exports = Array.isArray || function(arr) {
        return toString2.call(arr) == "[object Array]";
      };
    }
  });

  // node_modules/.pnpm/isobject@2.1.0/node_modules/isobject/index.js
  var require_isobject = __commonJS({
    "node_modules/.pnpm/isobject@2.1.0/node_modules/isobject/index.js"(exports, module) {
      "use strict";
      var isArray = require_isarray();
      module.exports = function isObject4(val) {
        return val != null && typeof val === "object" && isArray(val) === false;
      };
    }
  });

  // node_modules/.pnpm/line-column@1.0.2/node_modules/line-column/lib/line-column.js
  var require_line_column = __commonJS({
    "node_modules/.pnpm/line-column@1.0.2/node_modules/line-column/lib/line-column.js"(exports, module) {
      "use strict";
      var isArray = require_isarray();
      var isObject4 = require_isobject();
      var slice = Array.prototype.slice;
      module.exports = LineColumnFinder;
      function LineColumnFinder(str, options) {
        if (!(this instanceof LineColumnFinder)) {
          if (typeof options === "number") {
            return new LineColumnFinder(str).fromIndex(options);
          }
          return new LineColumnFinder(str, options);
        }
        this.str = str || "";
        this.lineToIndex = buildLineToIndex(this.str);
        options = options || {};
        this.origin = typeof options.origin === "undefined" ? 1 : options.origin;
      }
      LineColumnFinder.prototype.fromIndex = function(index2) {
        if (index2 < 0 || index2 >= this.str.length || isNaN(index2)) {
          return null;
        }
        var line = findLowerIndexInRangeArray(index2, this.lineToIndex);
        return {
          line: line + this.origin,
          col: index2 - this.lineToIndex[line] + this.origin
        };
      };
      LineColumnFinder.prototype.toIndex = function(line, column) {
        if (typeof column === "undefined") {
          if (isArray(line) && line.length >= 2) {
            return this.toIndex(line[0], line[1]);
          }
          if (isObject4(line) && "line" in line && ("col" in line || "column" in line)) {
            return this.toIndex(line.line, "col" in line ? line.col : line.column);
          }
          return -1;
        }
        if (isNaN(line) || isNaN(column)) {
          return -1;
        }
        line -= this.origin;
        column -= this.origin;
        if (line >= 0 && column >= 0 && line < this.lineToIndex.length) {
          var lineIndex = this.lineToIndex[line];
          var nextIndex = line === this.lineToIndex.length - 1 ? this.str.length : this.lineToIndex[line + 1];
          if (column < nextIndex - lineIndex) {
            return lineIndex + column;
          }
        }
        return -1;
      };
      function buildLineToIndex(str) {
        var lines = str.split("\n"), lineToIndex = new Array(lines.length), index2 = 0;
        for (var i = 0, l = lines.length; i < l; i++) {
          lineToIndex[i] = index2;
          index2 += lines[i].length + /* "\n".length */
          1;
        }
        return lineToIndex;
      }
      function findLowerIndexInRangeArray(value2, arr) {
        if (value2 >= arr[arr.length - 1]) {
          return arr.length - 1;
        }
        var min = 0, max2 = arr.length - 2, mid;
        while (min < max2) {
          mid = min + (max2 - min >> 1);
          if (value2 < arr[mid]) {
            max2 = mid - 1;
          } else if (value2 >= arr[mid + 1]) {
            min = mid + 1;
          } else {
            min = mid;
            break;
          }
        }
        return min;
      }
    }
  });

  // node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js
  var require_moo = __commonJS({
    "node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js"(exports, module) {
      (function(root2, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else {
          root2.moo = factory();
        }
      })(exports, function() {
        "use strict";
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var toString2 = Object.prototype.toString;
        var hasSticky = typeof new RegExp().sticky === "boolean";
        function isRegExp(o) {
          return o && toString2.call(o) === "[object RegExp]";
        }
        function isObject4(o) {
          return o && typeof o === "object" && !isRegExp(o) && !Array.isArray(o);
        }
        function reEscape(s2) {
          return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        function reGroups(s2) {
          var re = new RegExp("|" + s2);
          return re.exec("").length - 1;
        }
        function reCapture(s2) {
          return "(" + s2 + ")";
        }
        function reUnion(regexps) {
          if (!regexps.length)
            return "(?!)";
          var source = regexps.map(function(s2) {
            return "(?:" + s2 + ")";
          }).join("|");
          return "(?:" + source + ")";
        }
        function regexpOrLiteral(obj) {
          if (typeof obj === "string") {
            return "(?:" + reEscape(obj) + ")";
          } else if (isRegExp(obj)) {
            if (obj.ignoreCase)
              throw new Error("RegExp /i flag not allowed");
            if (obj.global)
              throw new Error("RegExp /g flag is implied");
            if (obj.sticky)
              throw new Error("RegExp /y flag is implied");
            if (obj.multiline)
              throw new Error("RegExp /m flag is implied");
            return obj.source;
          } else {
            throw new Error("Not a pattern: " + obj);
          }
        }
        function pad(s2, length2) {
          if (s2.length > length2) {
            return s2;
          }
          return Array(length2 - s2.length + 1).join(" ") + s2;
        }
        function lastNLines(string, numLines) {
          var position2 = string.length;
          var lineBreaks = 0;
          while (true) {
            var idx = string.lastIndexOf("\n", position2 - 1);
            if (idx === -1) {
              break;
            } else {
              lineBreaks++;
            }
            position2 = idx;
            if (lineBreaks === numLines) {
              break;
            }
            if (position2 === 0) {
              break;
            }
          }
          var startPosition = lineBreaks < numLines ? 0 : position2 + 1;
          return string.substring(startPosition).split("\n");
        }
        function objectToRules(object) {
          var keys = Object.getOwnPropertyNames(object);
          var result = [];
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var thing = object[key];
            var rules = [].concat(thing);
            if (key === "include") {
              for (var j = 0; j < rules.length; j++) {
                result.push({ include: rules[j] });
              }
              continue;
            }
            var match = [];
            rules.forEach(function(rule2) {
              if (isObject4(rule2)) {
                if (match.length)
                  result.push(ruleOptions(key, match));
                result.push(ruleOptions(key, rule2));
                match = [];
              } else {
                match.push(rule2);
              }
            });
            if (match.length)
              result.push(ruleOptions(key, match));
          }
          return result;
        }
        function arrayToRules(array) {
          var result = [];
          for (var i = 0; i < array.length; i++) {
            var obj = array[i];
            if (obj.include) {
              var include = [].concat(obj.include);
              for (var j = 0; j < include.length; j++) {
                result.push({ include: include[j] });
              }
              continue;
            }
            if (!obj.type) {
              throw new Error("Rule has no type: " + JSON.stringify(obj));
            }
            result.push(ruleOptions(obj.type, obj));
          }
          return result;
        }
        function ruleOptions(type, obj) {
          if (!isObject4(obj)) {
            obj = { match: obj };
          }
          if (obj.include) {
            throw new Error("Matching rules cannot also include states");
          }
          var options = {
            defaultType: type,
            lineBreaks: !!obj.error || !!obj.fallback,
            pop: false,
            next: null,
            push: null,
            error: false,
            fallback: false,
            value: null,
            type: null,
            shouldThrow: false
          };
          for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
              options[key] = obj[key];
            }
          }
          if (typeof options.type === "string" && type !== options.type) {
            throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')");
          }
          var match = options.match;
          options.match = Array.isArray(match) ? match : match ? [match] : [];
          options.match.sort(function(a, b) {
            return isRegExp(a) && isRegExp(b) ? 0 : isRegExp(b) ? -1 : isRegExp(a) ? 1 : b.length - a.length;
          });
          return options;
        }
        function toRules(spec) {
          return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
        }
        var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
        function compileRules(rules, hasStates) {
          var errorRule = null;
          var fast = /* @__PURE__ */ Object.create(null);
          var fastAllowed = true;
          var unicodeFlag = null;
          var groups = [];
          var parts = [];
          for (var i = 0; i < rules.length; i++) {
            if (rules[i].fallback) {
              fastAllowed = false;
            }
          }
          for (var i = 0; i < rules.length; i++) {
            var options = rules[i];
            if (options.include) {
              throw new Error("Inheritance is not allowed in stateless lexers");
            }
            if (options.error || options.fallback) {
              if (errorRule) {
                if (!options.fallback === !errorRule.fallback) {
                  throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
                } else {
                  throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
                }
              }
              errorRule = options;
            }
            var match = options.match.slice();
            if (fastAllowed) {
              while (match.length && typeof match[0] === "string" && match[0].length === 1) {
                var word = match.shift();
                fast[word.charCodeAt(0)] = options;
              }
            }
            if (options.pop || options.push || options.next) {
              if (!hasStates) {
                throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
              }
              if (options.fallback) {
                throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
              }
            }
            if (match.length === 0) {
              continue;
            }
            fastAllowed = false;
            groups.push(options);
            for (var j = 0; j < match.length; j++) {
              var obj = match[j];
              if (!isRegExp(obj)) {
                continue;
              }
              if (unicodeFlag === null) {
                unicodeFlag = obj.unicode;
              } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
                throw new Error("If one rule is /u then all must be");
              }
            }
            var pat = reUnion(match.map(regexpOrLiteral));
            var regexp = new RegExp(pat);
            if (regexp.test("")) {
              throw new Error("RegExp matches empty string: " + regexp);
            }
            var groupCount = reGroups(pat);
            if (groupCount > 0) {
              throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: \u2026 ) instead");
            }
            if (!options.lineBreaks && regexp.test("\n")) {
              throw new Error("Rule should declare lineBreaks: " + regexp);
            }
            parts.push(reCapture(pat));
          }
          var fallbackRule = errorRule && errorRule.fallback;
          var flags = hasSticky && !fallbackRule ? "ym" : "gm";
          var suffix = hasSticky || fallbackRule ? "" : "|";
          if (unicodeFlag === true)
            flags += "u";
          var combined = new RegExp(reUnion(parts) + suffix, flags);
          return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
        }
        function compile(rules) {
          var result = compileRules(toRules(rules));
          return new Lexer({ start: result }, "start");
        }
        function checkStateGroup(g, name, map) {
          var state = g && (g.push || g.next);
          if (state && !map[state]) {
            throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')");
          }
          if (g && g.pop && +g.pop !== 1) {
            throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')");
          }
        }
        function compileStates(states2, start) {
          var all = states2.$all ? toRules(states2.$all) : [];
          delete states2.$all;
          var keys = Object.getOwnPropertyNames(states2);
          if (!start)
            start = keys[0];
          var ruleMap = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            ruleMap[key] = toRules(states2[key]).concat(all);
          }
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var rules = ruleMap[key];
            var included = /* @__PURE__ */ Object.create(null);
            for (var j = 0; j < rules.length; j++) {
              var rule2 = rules[j];
              if (!rule2.include)
                continue;
              var splice = [j, 1];
              if (rule2.include !== key && !included[rule2.include]) {
                included[rule2.include] = true;
                var newRules = ruleMap[rule2.include];
                if (!newRules) {
                  throw new Error("Cannot include nonexistent state '" + rule2.include + "' (in state '" + key + "')");
                }
                for (var k2 = 0; k2 < newRules.length; k2++) {
                  var newRule = newRules[k2];
                  if (rules.indexOf(newRule) !== -1)
                    continue;
                  splice.push(newRule);
                }
              }
              rules.splice.apply(rules, splice);
              j--;
            }
          }
          var map = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            map[key] = compileRules(ruleMap[key], true);
          }
          for (var i = 0; i < keys.length; i++) {
            var name = keys[i];
            var state = map[name];
            var groups = state.groups;
            for (var j = 0; j < groups.length; j++) {
              checkStateGroup(groups[j], name, map);
            }
            var fastKeys = Object.getOwnPropertyNames(state.fast);
            for (var j = 0; j < fastKeys.length; j++) {
              checkStateGroup(state.fast[fastKeys[j]], name, map);
            }
          }
          return new Lexer(map, start);
        }
        function keywordTransform(map) {
          var isMap = typeof Map !== "undefined";
          var reverseMap = isMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
          var types2 = Object.getOwnPropertyNames(map);
          for (var i = 0; i < types2.length; i++) {
            var tokenType = types2[i];
            var item = map[tokenType];
            var keywordList = Array.isArray(item) ? item : [item];
            keywordList.forEach(function(keyword) {
              if (typeof keyword !== "string") {
                throw new Error("keyword must be string (in keyword '" + tokenType + "')");
              }
              if (isMap) {
                reverseMap.set(keyword, tokenType);
              } else {
                reverseMap[keyword] = tokenType;
              }
            });
          }
          return function(k2) {
            return isMap ? reverseMap.get(k2) : reverseMap[k2];
          };
        }
        var Lexer = function(states2, state) {
          this.startState = state;
          this.states = states2;
          this.buffer = "";
          this.stack = [];
          this.reset();
        };
        Lexer.prototype.reset = function(data, info) {
          this.buffer = data || "";
          this.index = 0;
          this.line = info ? info.line : 1;
          this.col = info ? info.col : 1;
          this.queuedToken = info ? info.queuedToken : null;
          this.queuedText = info ? info.queuedText : "";
          this.queuedThrow = info ? info.queuedThrow : null;
          this.setState(info ? info.state : this.startState);
          this.stack = info && info.stack ? info.stack.slice() : [];
          return this;
        };
        Lexer.prototype.save = function() {
          return {
            line: this.line,
            col: this.col,
            state: this.state,
            stack: this.stack.slice(),
            queuedToken: this.queuedToken,
            queuedText: this.queuedText,
            queuedThrow: this.queuedThrow
          };
        };
        Lexer.prototype.setState = function(state) {
          if (!state || this.state === state)
            return;
          this.state = state;
          var info = this.states[state];
          this.groups = info.groups;
          this.error = info.error;
          this.re = info.regexp;
          this.fast = info.fast;
        };
        Lexer.prototype.popState = function() {
          this.setState(this.stack.pop());
        };
        Lexer.prototype.pushState = function(state) {
          this.stack.push(this.state);
          this.setState(state);
        };
        var eat = hasSticky ? function(re, buffer) {
          return re.exec(buffer);
        } : function(re, buffer) {
          var match = re.exec(buffer);
          if (match[0].length === 0) {
            return null;
          }
          return match;
        };
        Lexer.prototype._getGroup = function(match) {
          var groupCount = this.groups.length;
          for (var i = 0; i < groupCount; i++) {
            if (match[i + 1] !== void 0) {
              return this.groups[i];
            }
          }
          throw new Error("Cannot find token type for matched text");
        };
        function tokenToString() {
          return this.value;
        }
        Lexer.prototype.next = function() {
          var index2 = this.index;
          if (this.queuedGroup) {
            var token = this._token(this.queuedGroup, this.queuedText, index2);
            this.queuedGroup = null;
            this.queuedText = "";
            return token;
          }
          var buffer = this.buffer;
          if (index2 === buffer.length) {
            return;
          }
          var group = this.fast[buffer.charCodeAt(index2)];
          if (group) {
            return this._token(group, buffer.charAt(index2), index2);
          }
          var re = this.re;
          re.lastIndex = index2;
          var match = eat(re, buffer);
          var error = this.error;
          if (match == null) {
            return this._token(error, buffer.slice(index2, buffer.length), index2);
          }
          var group = this._getGroup(match);
          var text2 = match[0];
          if (error.fallback && match.index !== index2) {
            this.queuedGroup = group;
            this.queuedText = text2;
            return this._token(error, buffer.slice(index2, match.index), index2);
          }
          return this._token(group, text2, index2);
        };
        Lexer.prototype._token = function(group, text2, offset) {
          var lineBreaks = 0;
          if (group.lineBreaks) {
            var matchNL = /\n/g;
            var nl = 1;
            if (text2 === "\n") {
              lineBreaks = 1;
            } else {
              while (matchNL.exec(text2)) {
                lineBreaks++;
                nl = matchNL.lastIndex;
              }
            }
          }
          var token = {
            type: typeof group.type === "function" && group.type(text2) || group.defaultType,
            value: typeof group.value === "function" ? group.value(text2) : text2,
            text: text2,
            toString: tokenToString,
            offset,
            lineBreaks,
            line: this.line,
            col: this.col
          };
          var size = text2.length;
          this.index += size;
          this.line += lineBreaks;
          if (lineBreaks !== 0) {
            this.col = size - nl + 1;
          } else {
            this.col += size;
          }
          if (group.shouldThrow) {
            var err = new Error(this.formatError(token, "invalid syntax"));
            throw err;
          }
          if (group.pop)
            this.popState();
          else if (group.push)
            this.pushState(group.push);
          else if (group.next)
            this.setState(group.next);
          return token;
        };
        if (typeof Symbol !== "undefined" && Symbol.iterator) {
          var LexerIterator = function(lexer) {
            this.lexer = lexer;
          };
          LexerIterator.prototype.next = function() {
            var token = this.lexer.next();
            return { value: token, done: !token };
          };
          LexerIterator.prototype[Symbol.iterator] = function() {
            return this;
          };
          Lexer.prototype[Symbol.iterator] = function() {
            return new LexerIterator(this);
          };
        }
        Lexer.prototype.formatError = function(token, message) {
          if (token == null) {
            var text2 = this.buffer.slice(this.index);
            var token = {
              text: text2,
              offset: this.index,
              lineBreaks: text2.indexOf("\n") === -1 ? 0 : 1,
              line: this.line,
              col: this.col
            };
          }
          var numLinesAround = 2;
          var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
          var lastDisplayedLine = token.line + numLinesAround;
          var lastLineDigits = String(lastDisplayedLine).length;
          var displayedLines = lastNLines(
            this.buffer,
            this.line - token.line + numLinesAround + 1
          ).slice(0, 5);
          var errorLines = [];
          errorLines.push(message + " at line " + token.line + " col " + token.col + ":");
          errorLines.push("");
          for (var i = 0; i < displayedLines.length; i++) {
            var line = displayedLines[i];
            var lineNo = firstDisplayedLine + i;
            errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
            if (lineNo === token.line) {
              errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
            }
          }
          return errorLines.join("\n");
        };
        Lexer.prototype.clone = function() {
          return new Lexer(this.states, this.state);
        };
        Lexer.prototype.has = function(tokenType) {
          return true;
        };
        return {
          compile,
          states: compileStates,
          error: Object.freeze({ error: true }),
          fallback: Object.freeze({ fallback: true }),
          keywords: keywordTransform
        };
      });
    }
  });

  // node_modules/.pnpm/becke-ch--regex--s0-0-v1--base--pl--lib@1.4.0/node_modules/becke-ch--regex--s0-0-v1--base--pl--lib/src/becke-ch--regex--s0-0-v1--base--pl--lib.js
  var require_becke_ch_regex_s0_0_v1_base_pl_lib = __commonJS({
    "node_modules/.pnpm/becke-ch--regex--s0-0-v1--base--pl--lib@1.4.0/node_modules/becke-ch--regex--s0-0-v1--base--pl--lib/src/becke-ch--regex--s0-0-v1--base--pl--lib.js"(exports, module) {
      Symbol = typeof Symbol === "undefined" ? [] : Symbol;
      function Regex2(pattern2, options) {
        var patternInstanceofRegExp = false;
        if (pattern2 instanceof RegExp) {
          pattern2 = pattern2.source;
          patternInstanceofRegExp = true;
        }
        if (pattern2) {
          this.regexGroupStructure = getRegexCompleteGroupingStructure(pattern2);
          if (patternInstanceofRegExp) {
            this.source = pattern2;
          } else {
            this.source = this.regexGroupStructure[2][0];
          }
          try {
            this.regex = new RegExp(this.regexGroupStructure[0][2], options);
          } catch (e2) {
            new RegExp(pattern2, options);
          }
        } else {
          this.regex = new RegExp(pattern2, options);
          this.source = this.regex.source;
        }
        this.flags = this.regex.flags;
        this.global = this.regex.global;
        this.ignoreCase = this.regex.ignoreCase;
        this.multiline = this.regex.multiline;
        this.sticky = this.regex.sticky;
        this.unicode = this.regex.unicode;
        this.lastIndex = this.regex.lastIndex;
      }
      Regex2.prototype = Object.create(RegExp.prototype, {
        flags: {
          value: null,
          enumerable: true,
          configurable: true,
          writable: true
        },
        global: {
          value: null,
          enumerable: true,
          configurable: true,
          writable: true
        },
        ignoreCase: {
          value: null,
          enumerable: true,
          configurable: true,
          writable: true
        },
        multiline: {
          value: null,
          enumerable: true,
          configurable: true,
          writable: true
        },
        source: {
          value: null,
          enumerable: true,
          configurable: true,
          writable: true
        },
        sticky: {
          value: null,
          enumerable: true,
          configurable: true,
          writable: true
        },
        unicode: {
          value: null,
          enumerable: true,
          configurable: true,
          writable: true
        }
      });
      Regex2.prototype.constructor = Regex2;
      Regex2.prototype.toString = function() {
        return "/" + this.source + "/" + this.flags;
      };
      Regex2.prototype.test = function(str) {
        return this.regex.test(str);
      };
      Regex2.prototype[Symbol.search] = function(str) {
        return this.regex[Symbol.search](str);
      };
      Regex2.prototype[Symbol.split] = function(str, limit) {
        return this.regex[Symbol.split](str);
      };
      Regex2.prototype.exec = function(str) {
        var result = [];
        result.index = [];
        var resultRegex = this.regex.exec(str);
        this.lastIndex = this.regex.lastIndex;
        if (!resultRegex) {
          return resultRegex;
        }
        result[0] = resultRegex[0];
        result.index[0] = resultRegex.index;
        result.input = str;
        var execInternal = function(strPosition, regexGroupStructureChildren) {
          var currentStrPos = strPosition;
          for (var i = 0; i < regexGroupStructureChildren.length; i++) {
            var index2 = regexGroupStructureChildren[i][0];
            var originalIndex = regexGroupStructureChildren[i][1];
            if (originalIndex) {
              result[originalIndex] = resultRegex[index2];
              if (typeof result[originalIndex] === "undefined") {
                result.index[originalIndex] = void 0;
              } else {
                result.index[originalIndex] = currentStrPos;
              }
            }
            if (regexGroupStructureChildren[i][3]) {
              execInternal(currentStrPos, regexGroupStructureChildren[i][3]);
            }
            if (typeof resultRegex[index2] !== "undefined") {
              currentStrPos += resultRegex[index2].length;
            }
          }
        };
        if (this.regexGroupStructure && this.regexGroupStructure[0][3]) {
          execInternal(resultRegex.index, this.regexGroupStructure[0][3]);
        }
        return result;
      };
      Regex2.prototype[Symbol.match] = function(str) {
        this.lastIndex = 0;
        this.regex.lastIndex = 0;
        var resultExec = this.exec(str);
        if (!resultExec) {
          return null;
        }
        var resultExecArray = [];
        while (resultExec) {
          resultExecArray.push(resultExec);
          if (resultExec[0].length === 0) {
            this.regex.lastIndex++;
          }
          if (!this.global) {
            break;
          }
          resultExec = this.exec(str);
        }
        this.lastIndex = 0;
        this.regex.lastIndex = 0;
        return resultExecArray;
      };
      Regex2.prototype[Symbol.replace] = function(str, newSubstringFunctionArray) {
        this.lastIndex = 0;
        this.regex.lastIndex = 0;
        if (!str) {
          return str;
        }
        var resultExec = this.exec(str);
        if (!resultExec) {
          return str;
        }
        if (!(newSubstringFunctionArray instanceof Array)) {
          newSubstringFunctionArray = [newSubstringFunctionArray];
        }
        var resultString = "";
        var resultStringPosition = 0;
        var computeSubstringFunction = function(newSubstringFunctionIndex) {
          var computedString = "";
          var charAt = "";
          var newSubstringFunction = newSubstringFunctionArray[newSubstringFunctionIndex];
          if (typeof newSubstringFunction === "string") {
            for (var i = 0; i < newSubstringFunction.length; i++) {
              charAt = newSubstringFunction.charAt(i);
              if (charAt === "$") {
                i++;
                charAt = newSubstringFunction.charAt(i);
                if (charAt === "$") {
                  computedString += "$";
                } else if (charAt === "&") {
                  computedString += resultExec[newSubstringFunctionIndex];
                } else if (charAt === "`") {
                  computedString += str.substring(0, resultExec.index[newSubstringFunctionIndex]);
                } else if (charAt === "'") {
                  computedString += str.substring(resultExec.index[newSubstringFunctionIndex] + resultExec[newSubstringFunctionIndex].length);
                } else if (charAt >= "0" && charAt <= "9") {
                  var int = charAt;
                  i++;
                  charAt = newSubstringFunction.charAt(i);
                  while (charAt >= "0" && charAt <= "9") {
                    int += charAt;
                    i++;
                    charAt = newSubstringFunction.charAt(i);
                  }
                  i--;
                  if (resultExec[int]) {
                    computedString += resultExec[int];
                  } else {
                    computedString += "$" + int;
                  }
                } else {
                  computedString += "$" + charAt;
                }
              } else {
                computedString += charAt;
              }
            }
          } else if (newSubstringFunction instanceof Function) {
            var args = [resultExec[newSubstringFunctionIndex]];
            for (var j = 0; j < resultExec.length; j++) {
              args.push(resultExec[j]);
            }
            for (var k2 = 0; j < resultExec.index.length; k2++) {
              args.push(resultExec.index[k2]);
            }
            args.push(str);
            computedString += newSubstringFunction.apply(this, args);
          }
          return computedString;
        };
        var traverseRegexGroupStructure = function(regexGroupStructureChildren) {
          for (var i = 0; i < regexGroupStructureChildren.length; i++) {
            var originalIndex = regexGroupStructureChildren[i][1];
            if (originalIndex) {
              if (newSubstringFunctionArray[originalIndex] || newSubstringFunctionArray[originalIndex] === "") {
                if (resultExec[originalIndex] || resultExec[originalIndex] === "") {
                  resultString += str.substring(resultStringPosition, resultExec.index[originalIndex]) + computeSubstringFunction(originalIndex);
                  resultStringPosition = resultExec.index[originalIndex] + resultExec[originalIndex].length;
                }
              } else if (regexGroupStructureChildren[i][3]) {
                traverseRegexGroupStructure(regexGroupStructureChildren[i][3]);
              }
            } else {
              traverseRegexGroupStructure(regexGroupStructureChildren[i][3]);
            }
          }
        };
        while (resultExec) {
          if (newSubstringFunctionArray[0] || newSubstringFunctionArray[0] === "") {
            resultString += str.substring(resultStringPosition, resultExec.index[0]) + computeSubstringFunction(0);
            resultStringPosition = resultExec.index[0] + resultExec[0].length;
          } else if (this.regexGroupStructure && this.regexGroupStructure[0][3]) {
            traverseRegexGroupStructure(this.regexGroupStructure[0][3]);
          }
          if (resultExec[0].length === 0) {
            this.regex.lastIndex++;
          }
          if (!this.global) {
            break;
          }
          resultExec = this.exec(str);
        }
        this.lastIndex = 0;
        this.regex.lastIndex = 0;
        return resultString + str.substring(resultStringPosition, str.length);
      };
      function getRegexCompleteGroupingStructure(regex) {
        if (!regex) {
          console.error('The "regex" is empty! Returning empty array!');
          return [];
        }
        var indexMap = [];
        var source = [""];
        var containsBackReference = [];
        containsBackReference[0] = false;
        var getRegexCompleteGroupingStructureInternalResult = getRegexCompleteGroupingStructureInternal(regex, [0, 0, 0], true, indexMap, source, containsBackReference);
        if (containsBackReference[0]) {
          var fixIndexOnGroupingStructure = function(groupingStructureElement) {
            var regexForThisGroup = "";
            var charAt;
            for (var i = 0; i < groupingStructureElement[2].length; i++) {
              charAt = groupingStructureElement[2].charAt(i);
              regexForThisGroup += charAt;
              if (charAt === "\\") {
                if (i + 1 === groupingStructureElement[2].length) {
                  continue;
                }
                i++;
                charAt = groupingStructureElement[2].charAt(i);
                var int = "";
                while (charAt >= "0" && charAt <= "9") {
                  int += charAt;
                  i++;
                  charAt = groupingStructureElement[2].charAt(i);
                }
                if (int) {
                  regexForThisGroup += indexMap[int];
                  i--;
                } else {
                  regexForThisGroup += charAt;
                }
                continue;
              }
              if (charAt === "[") {
                if (i + 1 === groupingStructureElement[2].length) {
                  continue;
                }
                i++;
                charAt = groupingStructureElement[2].charAt(i);
                while ((charAt !== "]" || groupingStructureElement[2].charAt(i - 1) === "\\" && groupingStructureElement[2].charAt(i - 2) !== "\\") && i < groupingStructureElement[2].length) {
                  regexForThisGroup += charAt;
                  i++;
                  charAt = groupingStructureElement[2].charAt(i);
                }
                regexForThisGroup += charAt;
                continue;
              }
            }
            groupingStructureElement[2] = regexForThisGroup;
            for (var j = 0; j < groupingStructureElement[3].length; j++) {
              fixIndexOnGroupingStructure(groupingStructureElement[3][j]);
            }
          };
          fixIndexOnGroupingStructure(getRegexCompleteGroupingStructureInternalResult);
        }
        return [getRegexCompleteGroupingStructureInternalResult, indexMap, source];
      }
      function getRegexCompleteGroupingStructureInternal(regex, posIndexOrigIndex, isCapturingGroup, indexMap, source, containsBackReference) {
        var groupStructure;
        if (isCapturingGroup) {
          groupStructure = [posIndexOrigIndex[1], posIndexOrigIndex[2], "", []];
          indexMap[posIndexOrigIndex[2]] = posIndexOrigIndex[1];
        } else {
          groupStructure = [void 0, void 0, "", []];
        }
        var tmpStr = "";
        var charAt;
        for (posIndexOrigIndex[0]; posIndexOrigIndex[0] < regex.length; posIndexOrigIndex[0]++) {
          charAt = regex.charAt(posIndexOrigIndex[0]);
          if (charAt === "\\") {
            if (posIndexOrigIndex[0] + 1 === regex.length) {
              tmpStr += "\\";
              source[0] += "\\";
              continue;
            }
            posIndexOrigIndex[0]++;
            charAt = regex.charAt(posIndexOrigIndex[0]);
            var int = "";
            while (charAt >= "0" && charAt <= "9") {
              int += charAt;
              posIndexOrigIndex[0]++;
              charAt = regex.charAt(posIndexOrigIndex[0]);
            }
            if (int) {
              if (indexMap[int]) {
                tmpStr += "\\" + int;
                containsBackReference[0] = true;
              } else {
                if (int.indexOf("8") >= 0 || int.indexOf("9") >= 0) {
                  tmpStr += int;
                } else {
                  tmpStr += "\\x" + ("0" + parseInt(int, 8).toString(16)).slice(-2).toUpperCase();
                }
              }
              source[0] += "\\" + int;
              posIndexOrigIndex[0]--;
            } else {
              tmpStr += "\\" + charAt;
              source[0] += "\\" + charAt;
            }
            continue;
          }
          if (charAt === "[") {
            tmpStr += "[";
            source[0] += "[";
            if (posIndexOrigIndex[0] + 1 === regex.length) {
              continue;
            }
            posIndexOrigIndex[0]++;
            charAt = regex.charAt(posIndexOrigIndex[0]);
            while ((charAt !== "]" || regex.charAt(posIndexOrigIndex[0] - 1) === "\\" && regex.charAt(posIndexOrigIndex[0] - 2) !== "\\") && posIndexOrigIndex[0] < regex.length) {
              tmpStr += charAt;
              source[0] += charAt;
              posIndexOrigIndex[0]++;
              charAt = regex.charAt(posIndexOrigIndex[0]);
            }
            tmpStr += charAt;
            source[0] += charAt;
            continue;
          }
          if (charAt === "|") {
            groupStructure[2] += tmpStr + "|";
            tmpStr = "";
            source[0] += "|";
            continue;
          }
          if (charAt === ")") {
            groupStructure[2] += tmpStr + ")";
            source[0] += ")";
            return groupStructure;
          }
          if (charAt === "(") {
            if (tmpStr) {
              posIndexOrigIndex[1]++;
              tmpStr = "(" + tmpStr + ")";
              groupStructure[3].push([posIndexOrigIndex[1], void 0, tmpStr, []]);
            }
            posIndexOrigIndex[0]++;
            var regexGroupStructureInternal;
            var idx = posIndexOrigIndex[1] + 1;
            isCapturingGroup = true;
            if (regex.charAt(posIndexOrigIndex[0]) === "?" && posIndexOrigIndex[0] + 1 < regex.length && (regex.charAt(posIndexOrigIndex[0] + 1) === "=" || regex.charAt(posIndexOrigIndex[0] + 1) === "!" || regex.charAt(posIndexOrigIndex[0] + 1) === ":")) {
              posIndexOrigIndex[0]++;
              var assertionChar = regex.charAt(posIndexOrigIndex[0]);
              posIndexOrigIndex[0]++;
              if (assertionChar === ":") {
                isCapturingGroup = false;
              }
              source[0] += "(?" + assertionChar;
              regexGroupStructureInternal = getRegexCompleteGroupingStructureInternal(regex, posIndexOrigIndex, false, indexMap, source, containsBackReference);
              regexGroupStructureInternal[2] = "(?" + assertionChar + regexGroupStructureInternal[2];
            } else {
              posIndexOrigIndex[1]++;
              posIndexOrigIndex[2]++;
              source[0] += "(";
              regexGroupStructureInternal = getRegexCompleteGroupingStructureInternal(regex, posIndexOrigIndex, true, indexMap, source, containsBackReference);
              regexGroupStructureInternal[2] = "(" + regexGroupStructureInternal[2];
            }
            var quantifierStart = posIndexOrigIndex[0];
            var quantifierString = "";
            if (posIndexOrigIndex[0] + 1 < regex.length) {
              charAt = regex.charAt(posIndexOrigIndex[0] + 1);
              if (charAt === "*") {
                posIndexOrigIndex[0]++;
                quantifierString = "*";
              } else if (charAt === "+") {
                posIndexOrigIndex[0]++;
                quantifierString = "+";
              } else if (charAt === "?") {
                posIndexOrigIndex[0]++;
                quantifierString = "?";
              } else if (charAt === "{") {
                posIndexOrigIndex[0]++;
                quantifierString = "{";
                posIndexOrigIndex[0]++;
                charAt = regex.charAt(posIndexOrigIndex[0]);
                while (charAt >= "0" && charAt <= "9" && posIndexOrigIndex[0] < regex.length) {
                  quantifierString += charAt;
                  posIndexOrigIndex[0]++;
                  charAt = regex.charAt(posIndexOrigIndex[0]);
                }
                if (charAt === "}") {
                  quantifierString += "}";
                } else {
                  if (charAt === ",") {
                    quantifierString += ",";
                    posIndexOrigIndex[0]++;
                    charAt = regex.charAt(posIndexOrigIndex[0]);
                    while (charAt >= "0" && charAt <= "9" && posIndexOrigIndex[0] < regex.length) {
                      quantifierString += charAt;
                      posIndexOrigIndex[0]++;
                      charAt = regex.charAt(posIndexOrigIndex[0]);
                    }
                    if (charAt === "}") {
                      quantifierString += "}";
                    } else {
                      quantifierString = "";
                    }
                  } else {
                    quantifierString = "";
                  }
                }
              }
              if (quantifierString.length > 0) {
                regexGroupStructureInternal[2] += quantifierString;
                source[0] += quantifierString;
                if (regex.charAt(posIndexOrigIndex[0] + 1) === "?") {
                  posIndexOrigIndex[0]++;
                  regexGroupStructureInternal[2] += "?";
                  source[0] += "?";
                }
              } else {
                posIndexOrigIndex[0] = quantifierStart;
              }
            }
            if (quantifierString.length > 0 || !isCapturingGroup) {
              incrementRegexGroupStructureIndex(regexGroupStructureInternal, indexMap);
              regexGroupStructureInternal = [idx, void 0, "(" + regexGroupStructureInternal[2] + ")", [regexGroupStructureInternal]];
              posIndexOrigIndex[1]++;
            }
            groupStructure[2] += tmpStr + regexGroupStructureInternal[2];
            groupStructure[3].push(regexGroupStructureInternal);
            tmpStr = "";
          } else {
            charAt = regex.charAt(posIndexOrigIndex[0]);
            tmpStr += charAt;
            if (charAt === "/") {
              source[0] += "\\" + charAt;
            } else {
              source[0] += charAt;
            }
          }
        }
        groupStructure[2] += tmpStr;
        return groupStructure;
      }
      function incrementRegexGroupStructureIndex(regexGroupStructure, indexMap) {
        if (regexGroupStructure[0]) {
          regexGroupStructure[0]++;
          if (regexGroupStructure[1]) {
            indexMap[regexGroupStructure[1]] = regexGroupStructure[0];
          }
        }
        for (var i = 0; i < regexGroupStructure[3].length; i++) {
          incrementRegexGroupStructureIndex(regexGroupStructure[3][i], indexMap);
        }
      }
      function initialize4() {
        if (!(typeof module === "undefined")) {
          module.exports = Regex2;
        }
      }
      initialize4();
    }
  });

  // node_modules/.pnpm/tmp-cache@1.1.0/node_modules/tmp-cache/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/.pnpm/tmp-cache@1.1.0/node_modules/tmp-cache/lib/index.js"(exports, module) {
      var Cache3 = class extends Map {
        constructor(opts = {}) {
          super();
          if (typeof opts === "number") {
            opts = { max: opts };
          }
          let { max: max2, maxAge } = opts;
          this.max = max2 > 0 && max2 || Infinity;
          this.maxAge = maxAge !== void 0 ? maxAge : -1;
          this.stale = !!opts.stale;
        }
        peek(key) {
          return this.get(key, false);
        }
        set(key, content, maxAge = this.maxAge) {
          this.has(key) && this.delete(key);
          this.size + 1 > this.max && this.delete(this.keys().next().value);
          let expires = maxAge > -1 && maxAge + Date.now();
          return super.set(key, { expires, content });
        }
        get(key, mut = true) {
          let x = super.get(key);
          if (x === void 0)
            return x;
          let { expires, content } = x;
          if (expires !== false && Date.now() >= expires) {
            this.delete(key);
            return this.stale ? content : void 0;
          }
          if (mut)
            this.set(key, content);
          return content;
        }
      };
      module.exports = Cache3;
    }
  });

  // node_modules/.pnpm/css.escape@1.5.1/node_modules/css.escape/css.escape.js
  var require_css_escape = __commonJS({
    "node_modules/.pnpm/css.escape@1.5.1/node_modules/css.escape/css.escape.js"(exports, module) {
      (function(root2, factory) {
        if (typeof exports == "object") {
          module.exports = factory(root2);
        } else if (typeof define == "function" && define.amd) {
          define([], factory.bind(root2, root2));
        } else {
          factory(root2);
        }
      })(typeof global != "undefined" ? global : exports, function(root2) {
        if (root2.CSS && root2.CSS.escape) {
          return root2.CSS.escape;
        }
        var cssEscape = function(value2) {
          if (arguments.length == 0) {
            throw new TypeError("`CSS.escape` requires an argument.");
          }
          var string = String(value2);
          var length2 = string.length;
          var index2 = -1;
          var codeUnit;
          var result = "";
          var firstCodeUnit = string.charCodeAt(0);
          while (++index2 < length2) {
            codeUnit = string.charCodeAt(index2);
            if (codeUnit == 0) {
              result += "\uFFFD";
              continue;
            }
            if (
              // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
              // U+007F, []
              codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || // If the character is the first character and is in the range [0-9]
              // (U+0030 to U+0039), []
              index2 == 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9]
              // (U+0030 to U+0039) and the first character is a `-` (U+002D), []
              index2 == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45
            ) {
              result += "\\" + codeUnit.toString(16) + " ";
              continue;
            }
            if (
              // If the character is the first character and is a `-` (U+002D), and
              // there is no second character, []
              index2 == 0 && length2 == 1 && codeUnit == 45
            ) {
              result += "\\" + string.charAt(index2);
              continue;
            }
            if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
              result += string.charAt(index2);
              continue;
            }
            result += "\\" + string.charAt(index2);
          }
          return result;
        };
        if (!root2.CSS) {
          root2.CSS = {};
        }
        root2.CSS.escape = cssEscape;
        return cssEscape;
      });
    }
  });

  // node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/debug.js
  var require_debug = __commonJS({
    "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/debug.js"(exports, module) {
      var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
      };
      module.exports = debug;
    }
  });

  // node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/constants.js
  var require_constants = __commonJS({
    "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/constants.js"(exports, module) {
      var SEMVER_SPEC_VERSION = "2.0.0";
      var MAX_LENGTH = 256;
      var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
      9007199254740991;
      var MAX_SAFE_COMPONENT_LENGTH = 16;
      var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
      var RELEASE_TYPES = [
        "major",
        "premajor",
        "minor",
        "preminor",
        "patch",
        "prepatch",
        "prerelease"
      ];
      module.exports = {
        MAX_LENGTH,
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_SAFE_INTEGER,
        RELEASE_TYPES,
        SEMVER_SPEC_VERSION,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2
      };
    }
  });

  // node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/re.js
  var require_re = __commonJS({
    "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/re.js"(exports, module) {
      var {
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_LENGTH
      } = require_constants();
      var debug = require_debug();
      exports = module.exports = {};
      var re = exports.re = [];
      var safeRe = exports.safeRe = [];
      var src = exports.src = [];
      var t = exports.t = {};
      var R = 0;
      var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
      var safeRegexReplacements = [
        ["\\s", 1],
        ["\\d", MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
      ];
      var makeSafeRegex = (value2) => {
        for (const [token, max2] of safeRegexReplacements) {
          value2 = value2.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
        }
        return value2;
      };
      var createToken = (name, value2, isGlobal) => {
        const safe = makeSafeRegex(value2);
        const index2 = R++;
        debug(name, index2, value2);
        t[name] = index2;
        src[index2] = value2;
        re[index2] = new RegExp(value2, isGlobal ? "g" : void 0);
        safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
      createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
      createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
      createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
      createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
      createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
      createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
      createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
      createToken("FULL", `^${src[t.FULLPLAIN]}$`);
      createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
      createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
      createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
      createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
      createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
      createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
      createToken("COERCERTL", src[t.COERCE], true);
      createToken("COERCERTLFULL", src[t.COERCEFULL], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
      exports.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
      createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
      exports.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
      createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
      createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
      createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
      exports.comparatorTrimReplace = "$1$2$3";
      createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
      createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    }
  });

  // node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/parse-options.js
  var require_parse_options = __commonJS({
    "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/parse-options.js"(exports, module) {
      var looseOption = Object.freeze({ loose: true });
      var emptyOpts = Object.freeze({});
      var parseOptions = (options) => {
        if (!options) {
          return emptyOpts;
        }
        if (typeof options !== "object") {
          return looseOption;
        }
        return options;
      };
      module.exports = parseOptions;
    }
  });

  // node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/identifiers.js
  var require_identifiers = __commonJS({
    "node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/identifiers.js"(exports, module) {
      var numeric = /^[0-9]+$/;
      var compareIdentifiers = (a, b) => {
        const anum = numeric.test(a);
        const bnum = numeric.test(b);
        if (anum && bnum) {
          a = +a;
          b = +b;
        }
        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      };
      var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
      module.exports = {
        compareIdentifiers,
        rcompareIdentifiers
      };
    }
  });

  // node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js
  var require_semver = __commonJS({
    "node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js"(exports, module) {
      var debug = require_debug();
      var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
      var { safeRe: re, t } = require_re();
      var parseOptions = require_parse_options();
      var { compareIdentifiers } = require_identifiers();
      var SemVer = class _SemVer {
        constructor(version2, options) {
          options = parseOptions(options);
          if (version2 instanceof _SemVer) {
            if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
              return version2;
            } else {
              version2 = version2.version;
            }
          } else if (typeof version2 !== "string") {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
          }
          if (version2.length > MAX_LENGTH) {
            throw new TypeError(
              `version is longer than ${MAX_LENGTH} characters`
            );
          }
          debug("SemVer", version2, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m) {
            throw new TypeError(`Invalid Version: ${version2}`);
          }
          this.raw = version2;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num2 = +id;
                if (num2 >= 0 && num2 < MAX_SAFE_INTEGER) {
                  return num2;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof _SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new _SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof _SemVer)) {
            other = new _SemVer(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (!(other instanceof _SemVer)) {
            other = new _SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i = 0;
          do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        compareBuild(other) {
          if (!(other instanceof _SemVer)) {
            other = new _SemVer(other, this.options);
          }
          let i = 0;
          do {
            const a = this.build[i];
            const b = other.build[i];
            debug("build compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.
        inc(release, identifier, identifierBase) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier, identifierBase);
              this.inc("pre", identifier, identifierBase);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier, identifierBase);
              }
              this.inc("pre", identifier, identifierBase);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre": {
              const base = Number(identifierBase) ? 1 : 0;
              if (!identifier && identifierBase === false) {
                throw new Error("invalid increment argument: identifier is empty");
              }
              if (this.prerelease.length === 0) {
                this.prerelease = [base];
              } else {
                let i = this.prerelease.length;
                while (--i >= 0) {
                  if (typeof this.prerelease[i] === "number") {
                    this.prerelease[i]++;
                    i = -2;
                  }
                }
                if (i === -1) {
                  if (identifier === this.prerelease.join(".") && identifierBase === false) {
                    throw new Error("invalid increment argument: identifier already exists");
                  }
                  this.prerelease.push(base);
                }
              }
              if (identifier) {
                let prerelease = [identifier, base];
                if (identifierBase === false) {
                  prerelease = [identifier];
                }
                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = prerelease;
                  }
                } else {
                  this.prerelease = prerelease;
                }
              }
              break;
            }
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.raw = this.format();
          if (this.build.length) {
            this.raw += `+${this.build.join(".")}`;
          }
          return this;
        }
      };
      module.exports = SemVer;
    }
  });

  // node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js
  var require_compare = __commonJS({
    "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js"(exports, module) {
      var SemVer = require_semver();
      var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
      module.exports = compare;
    }
  });

  // node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gte.js
  var require_gte = __commonJS({
    "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gte.js"(exports, module) {
      var compare = require_compare();
      var gte2 = (a, b, loose) => compare(a, b, loose) >= 0;
      module.exports = gte2;
    }
  });

  // node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lte.js
  var require_lte = __commonJS({
    "node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lte.js"(exports, module) {
      var compare = require_compare();
      var lte = (a, b, loose) => compare(a, b, loose) <= 0;
      module.exports = lte;
    }
  });

  // node_modules/.pnpm/sift-string@0.0.2/node_modules/sift-string/index.js
  var require_sift_string = __commonJS({
    "node_modules/.pnpm/sift-string@0.0.2/node_modules/sift-string/index.js"(exports, module) {
      module.exports = function sift2(s1, s2) {
        if (s1 == null || s1.length === 0) {
          if (s2 == null || s2.length === 0) {
            return 0;
          } else {
            return s2.length;
          }
        }
        if (s2 == null || s2.length === 0) {
          return s1.length;
        }
        var c4 = 0;
        var offset1 = 0;
        var offset2 = 0;
        var lcs = 0;
        var maxOffset = 5;
        while (c4 + offset1 < s1.length && c4 + offset2 < s2.length) {
          if (s1.charAt(c4 + offset1) == s2.charAt(c4 + offset2)) {
            lcs++;
          } else {
            offset1 = 0;
            offset2 = 0;
            for (var i = 0; i < maxOffset; i++) {
              if (c4 + i < s1.length && s1.charAt(c4 + i) == s2.charAt(c4)) {
                offset1 = i;
                break;
              }
              if (c4 + i < s2.length && s1.charAt(c4) == s2.charAt(c4 + i)) {
                offset2 = i;
                break;
              }
            }
          }
          c4++;
        }
        return (s1.length + s2.length) / 2 - lcs;
      };
    }
  });

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/errors.js
  var ErrorHandler = class {
    constructor() {
      this.listeners = [];
      this.unexpectedErrorHandler = function(e2) {
        setTimeout(() => {
          if (e2.stack) {
            if (ErrorNoTelemetry.isErrorNoTelemetry(e2)) {
              throw new ErrorNoTelemetry(e2.message + "\n\n" + e2.stack);
            }
            throw new Error(e2.message + "\n\n" + e2.stack);
          }
          throw e2;
        }, 0);
      };
    }
    emit(e2) {
      this.listeners.forEach((listener) => {
        listener(e2);
      });
    }
    onUnexpectedError(e2) {
      this.unexpectedErrorHandler(e2);
      this.emit(e2);
    }
    // For external errors, we don't want the listeners to be called
    onUnexpectedExternalError(e2) {
      this.unexpectedErrorHandler(e2);
    }
  };
  var errorHandler = new ErrorHandler();
  function onUnexpectedError(e2) {
    if (!isCancellationError(e2)) {
      errorHandler.onUnexpectedError(e2);
    }
    return void 0;
  }
  function transformErrorForSerialization(error) {
    if (error instanceof Error) {
      const { name, message } = error;
      const stack = error.stacktrace || error.stack;
      return {
        $isError: true,
        name,
        message,
        stack,
        noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)
      };
    }
    return error;
  }
  var canceledName = "Canceled";
  function isCancellationError(error) {
    if (error instanceof CancellationError) {
      return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
  }
  var CancellationError = class extends Error {
    constructor() {
      super(canceledName);
      this.name = this.message;
    }
  };
  var ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {
    constructor(msg) {
      super(msg);
      this.name = "CodeExpectedError";
    }
    static fromError(err) {
      if (err instanceof _ErrorNoTelemetry) {
        return err;
      }
      const result = new _ErrorNoTelemetry();
      result.message = err.message;
      result.stack = err.stack;
      return result;
    }
    static isErrorNoTelemetry(err) {
      return err.name === "CodeExpectedError";
    }
  };
  var BugIndicatingError = class _BugIndicatingError extends Error {
    constructor(message) {
      super(message || "An unexpected bug occurred.");
      Object.setPrototypeOf(this, _BugIndicatingError.prototype);
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/functional.js
  function createSingleCallFunction(fn2, fnDidRunCallback) {
    const _this = this;
    let didCall = false;
    let result;
    return function() {
      if (didCall) {
        return result;
      }
      didCall = true;
      if (fnDidRunCallback) {
        try {
          result = fn2.apply(_this, arguments);
        } finally {
          fnDidRunCallback();
        }
      } else {
        result = fn2.apply(_this, arguments);
      }
      return result;
    };
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js
  var Iterable;
  (function(Iterable2) {
    function is(thing) {
      return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
    }
    Iterable2.is = is;
    const _empty2 = Object.freeze([]);
    function empty() {
      return _empty2;
    }
    Iterable2.empty = empty;
    function* single(element) {
      yield element;
    }
    Iterable2.single = single;
    function wrap(iterableOrElement) {
      if (is(iterableOrElement)) {
        return iterableOrElement;
      } else {
        return single(iterableOrElement);
      }
    }
    Iterable2.wrap = wrap;
    function from(iterable) {
      return iterable || _empty2;
    }
    Iterable2.from = from;
    function* reverse(array) {
      for (let i = array.length - 1; i >= 0; i--) {
        yield array[i];
      }
    }
    Iterable2.reverse = reverse;
    function isEmpty(iterable) {
      return !iterable || iterable[Symbol.iterator]().next().done === true;
    }
    Iterable2.isEmpty = isEmpty;
    function first(iterable) {
      return iterable[Symbol.iterator]().next().value;
    }
    Iterable2.first = first;
    function some(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          return true;
        }
      }
      return false;
    }
    Iterable2.some = some;
    function find(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          return element;
        }
      }
      return void 0;
    }
    Iterable2.find = find;
    function* filter(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          yield element;
        }
      }
    }
    Iterable2.filter = filter;
    function* map(iterable, fn2) {
      let index2 = 0;
      for (const element of iterable) {
        yield fn2(element, index2++);
      }
    }
    Iterable2.map = map;
    function* concat(...iterables) {
      for (const iterable of iterables) {
        yield* iterable;
      }
    }
    Iterable2.concat = concat;
    function reduce(iterable, reducer, initialValue) {
      let value2 = initialValue;
      for (const element of iterable) {
        value2 = reducer(value2, element);
      }
      return value2;
    }
    Iterable2.reduce = reduce;
    function* slice(arr, from2, to = arr.length) {
      if (from2 < 0) {
        from2 += arr.length;
      }
      if (to < 0) {
        to += arr.length;
      } else if (to > arr.length) {
        to = arr.length;
      }
      for (; from2 < to; from2++) {
        yield arr[from2];
      }
    }
    Iterable2.slice = slice;
    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
      const consumed = [];
      if (atMost === 0) {
        return [consumed, iterable];
      }
      const iterator = iterable[Symbol.iterator]();
      for (let i = 0; i < atMost; i++) {
        const next = iterator.next();
        if (next.done) {
          return [consumed, Iterable2.empty()];
        }
        consumed.push(next.value);
      }
      return [consumed, { [Symbol.iterator]() {
        return iterator;
      } }];
    }
    Iterable2.consume = consume;
    async function asyncToArray(iterable) {
      const result = [];
      for await (const item of iterable) {
        result.push(item);
      }
      return Promise.resolve(result);
    }
    Iterable2.asyncToArray = asyncToArray;
  })(Iterable || (Iterable = {}));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
  var TRACK_DISPOSABLES = false;
  var disposableTracker = null;
  function setDisposableTracker(tracker) {
    disposableTracker = tracker;
  }
  if (TRACK_DISPOSABLES) {
    const __is_disposable_tracked__ = "__is_disposable_tracked__";
    setDisposableTracker(new class {
      trackDisposable(x) {
        const stack = new Error("Potentially leaked disposable").stack;
        setTimeout(() => {
          if (!x[__is_disposable_tracked__]) {
            console.log(stack);
          }
        }, 3e3);
      }
      setParent(child, parent) {
        if (child && child !== Disposable.None) {
          try {
            child[__is_disposable_tracked__] = true;
          } catch (_a4) {
          }
        }
      }
      markAsDisposed(disposable) {
        if (disposable && disposable !== Disposable.None) {
          try {
            disposable[__is_disposable_tracked__] = true;
          } catch (_a4) {
          }
        }
      }
      markAsSingleton(disposable) {
      }
    }());
  }
  function trackDisposable(x) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
    return x;
  }
  function markAsDisposed(disposable) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
  }
  function setParentOfDisposable(child, parent) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
  }
  function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
      return;
    }
    for (const child of children) {
      disposableTracker.setParent(child, parent);
    }
  }
  function dispose(arg) {
    if (Iterable.is(arg)) {
      const errors = [];
      for (const d of arg) {
        if (d) {
          try {
            d.dispose();
          } catch (e2) {
            errors.push(e2);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      } else if (errors.length > 1) {
        throw new AggregateError(errors, "Encountered errors while disposing of store");
      }
      return Array.isArray(arg) ? [] : arg;
    } else if (arg) {
      arg.dispose();
      return arg;
    }
  }
  function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
  }
  function toDisposable(fn2) {
    const self2 = trackDisposable({
      dispose: createSingleCallFunction(() => {
        markAsDisposed(self2);
        fn2();
      })
    });
    return self2;
  }
  var DisposableStore = class _DisposableStore {
    constructor() {
      this._toDispose = /* @__PURE__ */ new Set();
      this._isDisposed = false;
      trackDisposable(this);
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose() {
      if (this._isDisposed) {
        return;
      }
      markAsDisposed(this);
      this._isDisposed = true;
      this.clear();
    }
    /**
     * @return `true` if this object has been disposed of.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear() {
      if (this._toDispose.size === 0) {
        return;
      }
      try {
        dispose(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
    }
    /**
     * Add a new {@link IDisposable disposable} to the collection.
     */
    add(o) {
      if (!o) {
        return o;
      }
      if (o === this) {
        throw new Error("Cannot register a disposable on itself!");
      }
      setParentOfDisposable(o, this);
      if (this._isDisposed) {
        if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
          console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
        }
      } else {
        this._toDispose.add(o);
      }
      return o;
    }
    /**
     * Deletes the value from the store, but does not dispose it.
     */
    deleteAndLeak(o) {
      if (!o) {
        return;
      }
      if (this._toDispose.has(o)) {
        this._toDispose.delete(o);
        setParentOfDisposable(o, null);
      }
    }
  };
  DisposableStore.DISABLE_DISPOSED_WARNING = false;
  var Disposable = class {
    constructor() {
      this._store = new DisposableStore();
      trackDisposable(this);
      setParentOfDisposable(this._store, this);
    }
    dispose() {
      markAsDisposed(this);
      this._store.dispose();
    }
    /**
     * Adds `o` to the collection of disposables managed by this object.
     */
    _register(o) {
      if (o === this) {
        throw new Error("Cannot register a disposable on itself!");
      }
      return this._store.add(o);
    }
  };
  Disposable.None = Object.freeze({ dispose() {
  } });

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js
  var Node = class _Node {
    constructor(element) {
      this.element = element;
      this.next = _Node.Undefined;
      this.prev = _Node.Undefined;
    }
  };
  Node.Undefined = new Node(void 0);
  var LinkedList = class {
    constructor() {
      this._first = Node.Undefined;
      this._last = Node.Undefined;
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    isEmpty() {
      return this._first === Node.Undefined;
    }
    clear() {
      let node = this._first;
      while (node !== Node.Undefined) {
        const next = node.next;
        node.prev = Node.Undefined;
        node.next = Node.Undefined;
        node = next;
      }
      this._first = Node.Undefined;
      this._last = Node.Undefined;
      this._size = 0;
    }
    unshift(element) {
      return this._insert(element, false);
    }
    push(element) {
      return this._insert(element, true);
    }
    _insert(element, atTheEnd) {
      const newNode = new Node(element);
      if (this._first === Node.Undefined) {
        this._first = newNode;
        this._last = newNode;
      } else if (atTheEnd) {
        const oldLast = this._last;
        this._last = newNode;
        newNode.prev = oldLast;
        oldLast.next = newNode;
      } else {
        const oldFirst = this._first;
        this._first = newNode;
        newNode.next = oldFirst;
        oldFirst.prev = newNode;
      }
      this._size += 1;
      let didRemove = false;
      return () => {
        if (!didRemove) {
          didRemove = true;
          this._remove(newNode);
        }
      };
    }
    shift() {
      if (this._first === Node.Undefined) {
        return void 0;
      } else {
        const res = this._first.element;
        this._remove(this._first);
        return res;
      }
    }
    pop() {
      if (this._last === Node.Undefined) {
        return void 0;
      } else {
        const res = this._last.element;
        this._remove(this._last);
        return res;
      }
    }
    _remove(node) {
      if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
        const anchor = node.prev;
        anchor.next = node.next;
        node.next.prev = anchor;
      } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
      } else if (node.next === Node.Undefined) {
        this._last = this._last.prev;
        this._last.next = Node.Undefined;
      } else if (node.prev === Node.Undefined) {
        this._first = this._first.next;
        this._first.prev = Node.Undefined;
      }
      this._size -= 1;
    }
    *[Symbol.iterator]() {
      let node = this._first;
      while (node !== Node.Undefined) {
        yield node.element;
        node = node.next;
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
  var hasPerformanceNow = globalThis.performance && typeof globalThis.performance.now === "function";
  var StopWatch = class _StopWatch {
    static create(highResolution) {
      return new _StopWatch(highResolution);
    }
    constructor(highResolution) {
      this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
      this._startTime = this._now();
      this._stopTime = -1;
    }
    stop() {
      this._stopTime = this._now();
    }
    reset() {
      this._startTime = this._now();
      this._stopTime = -1;
    }
    elapsed() {
      if (this._stopTime !== -1) {
        return this._stopTime - this._startTime;
      }
      return this._now() - this._startTime;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/event.js
  var _enableListenerGCedWarning = false;
  var _enableDisposeWithListenerWarning = false;
  var _enableSnapshotPotentialLeakWarning = false;
  var Event;
  (function(Event2) {
    Event2.None = () => Disposable.None;
    function _addLeakageTraceLogic(options) {
      if (_enableSnapshotPotentialLeakWarning) {
        const { onDidAddListener: origListenerDidAdd } = options;
        const stack = Stacktrace.create();
        let count = 0;
        options.onDidAddListener = () => {
          if (++count === 2) {
            console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
            stack.print();
          }
          origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
        };
      }
    }
    function defer(event, disposable) {
      return debounce(event, () => void 0, 0, void 0, true, void 0, disposable);
    }
    Event2.defer = defer;
    function once(event) {
      return (listener, thisArgs = null, disposables) => {
        let didFire = false;
        let result = void 0;
        result = event((e2) => {
          if (didFire) {
            return;
          } else if (result) {
            result.dispose();
          } else {
            didFire = true;
          }
          return listener.call(thisArgs, e2);
        }, null, disposables);
        if (didFire) {
          result.dispose();
        }
        return result;
      };
    }
    Event2.once = once;
    function map(event, map2, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map2(i)), null, disposables), disposable);
    }
    Event2.map = map;
    function forEach(event, each, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((i) => {
        each(i);
        listener.call(thisArgs, i);
      }, null, disposables), disposable);
    }
    Event2.forEach = forEach;
    function filter(event, filter2, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((e2) => filter2(e2) && listener.call(thisArgs, e2), null, disposables), disposable);
    }
    Event2.filter = filter;
    function signal(event) {
      return event;
    }
    Event2.signal = signal;
    function any2(...events) {
      return (listener, thisArgs = null, disposables) => {
        const disposable = combinedDisposable(...events.map((event) => event((e2) => listener.call(thisArgs, e2))));
        return addAndReturnDisposable(disposable, disposables);
      };
    }
    Event2.any = any2;
    function reduce(event, merge, initial, disposable) {
      let output = initial;
      return map(event, (e2) => {
        output = merge(output, e2);
        return output;
      }, disposable);
    }
    Event2.reduce = reduce;
    function snapshot(event, disposable) {
      let listener;
      const options = {
        onWillAddFirstListener() {
          listener = event(emitter.fire, emitter);
        },
        onDidRemoveLastListener() {
          listener === null || listener === void 0 ? void 0 : listener.dispose();
        }
      };
      if (!disposable) {
        _addLeakageTraceLogic(options);
      }
      const emitter = new Emitter(options);
      disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
      return emitter.event;
    }
    function addAndReturnDisposable(d, store) {
      if (store instanceof Array) {
        store.push(d);
      } else if (store) {
        store.add(d);
      }
      return d;
    }
    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
      let subscription;
      let output = void 0;
      let handle = void 0;
      let numDebouncedCalls = 0;
      let doFire;
      const options = {
        leakWarningThreshold,
        onWillAddFirstListener() {
          subscription = event((cur) => {
            numDebouncedCalls++;
            output = merge(output, cur);
            if (leading && !handle) {
              emitter.fire(output);
              output = void 0;
            }
            doFire = () => {
              const _output = output;
              output = void 0;
              handle = void 0;
              if (!leading || numDebouncedCalls > 1) {
                emitter.fire(_output);
              }
              numDebouncedCalls = 0;
            };
            if (typeof delay === "number") {
              clearTimeout(handle);
              handle = setTimeout(doFire, delay);
            } else {
              if (handle === void 0) {
                handle = 0;
                queueMicrotask(doFire);
              }
            }
          });
        },
        onWillRemoveListener() {
          if (flushOnListenerRemove && numDebouncedCalls > 0) {
            doFire === null || doFire === void 0 ? void 0 : doFire();
          }
        },
        onDidRemoveLastListener() {
          doFire = void 0;
          subscription.dispose();
        }
      };
      if (!disposable) {
        _addLeakageTraceLogic(options);
      }
      const emitter = new Emitter(options);
      disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
      return emitter.event;
    }
    Event2.debounce = debounce;
    function accumulate(event, delay = 0, disposable) {
      return Event2.debounce(event, (last, e2) => {
        if (!last) {
          return [e2];
        }
        last.push(e2);
        return last;
      }, delay, void 0, true, void 0, disposable);
    }
    Event2.accumulate = accumulate;
    function latch(event, equals3 = (a, b) => a === b, disposable) {
      let firstCall = true;
      let cache3;
      return filter(event, (value2) => {
        const shouldEmit = firstCall || !equals3(value2, cache3);
        firstCall = false;
        cache3 = value2;
        return shouldEmit;
      }, disposable);
    }
    Event2.latch = latch;
    function split(event, isT, disposable) {
      return [
        Event2.filter(event, isT, disposable),
        Event2.filter(event, (e2) => !isT(e2), disposable)
      ];
    }
    Event2.split = split;
    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {
      let buffer2 = _buffer.slice();
      let listener = event((e2) => {
        if (buffer2) {
          buffer2.push(e2);
        } else {
          emitter.fire(e2);
        }
      });
      if (disposable) {
        disposable.add(listener);
      }
      const flush = () => {
        buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.forEach((e2) => emitter.fire(e2));
        buffer2 = null;
      };
      const emitter = new Emitter({
        onWillAddFirstListener() {
          if (!listener) {
            listener = event((e2) => emitter.fire(e2));
            if (disposable) {
              disposable.add(listener);
            }
          }
        },
        onDidAddFirstListener() {
          if (buffer2) {
            if (flushAfterTimeout) {
              setTimeout(flush);
            } else {
              flush();
            }
          }
        },
        onDidRemoveLastListener() {
          if (listener) {
            listener.dispose();
          }
          listener = null;
        }
      });
      if (disposable) {
        disposable.add(emitter);
      }
      return emitter.event;
    }
    Event2.buffer = buffer;
    function chain(event, sythensize) {
      const fn2 = (listener, thisArgs, disposables) => {
        const cs = sythensize(new ChainableSynthesis());
        return event(function(value2) {
          const result = cs.evaluate(value2);
          if (result !== HaltChainable) {
            listener.call(thisArgs, result);
          }
        }, void 0, disposables);
      };
      return fn2;
    }
    Event2.chain = chain;
    const HaltChainable = Symbol("HaltChainable");
    class ChainableSynthesis {
      constructor() {
        this.steps = [];
      }
      map(fn2) {
        this.steps.push(fn2);
        return this;
      }
      forEach(fn2) {
        this.steps.push((v) => {
          fn2(v);
          return v;
        });
        return this;
      }
      filter(fn2) {
        this.steps.push((v) => fn2(v) ? v : HaltChainable);
        return this;
      }
      reduce(merge, initial) {
        let last = initial;
        this.steps.push((v) => {
          last = merge(last, v);
          return last;
        });
        return this;
      }
      latch(equals3 = (a, b) => a === b) {
        let firstCall = true;
        let cache3;
        this.steps.push((value2) => {
          const shouldEmit = firstCall || !equals3(value2, cache3);
          firstCall = false;
          cache3 = value2;
          return shouldEmit ? value2 : HaltChainable;
        });
        return this;
      }
      evaluate(value2) {
        for (const step of this.steps) {
          value2 = step(value2);
          if (value2 === HaltChainable) {
            break;
          }
        }
        return value2;
      }
    }
    function fromNodeEventEmitter(emitter, eventName, map2 = (id) => id) {
      const fn2 = (...args) => result.fire(map2(...args));
      const onFirstListenerAdd = () => emitter.on(eventName, fn2);
      const onLastListenerRemove = () => emitter.removeListener(eventName, fn2);
      const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
      return result.event;
    }
    Event2.fromNodeEventEmitter = fromNodeEventEmitter;
    function fromDOMEventEmitter(emitter, eventName, map2 = (id) => id) {
      const fn2 = (...args) => result.fire(map2(...args));
      const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn2);
      const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn2);
      const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
      return result.event;
    }
    Event2.fromDOMEventEmitter = fromDOMEventEmitter;
    function toPromise(event) {
      return new Promise((resolve2) => once(event)(resolve2));
    }
    Event2.toPromise = toPromise;
    function fromPromise(promise) {
      const result = new Emitter();
      promise.then((res) => {
        result.fire(res);
      }, () => {
        result.fire(void 0);
      }).finally(() => {
        result.dispose();
      });
      return result.event;
    }
    Event2.fromPromise = fromPromise;
    function runAndSubscribe(event, handler, initial) {
      handler(initial);
      return event((e2) => handler(e2));
    }
    Event2.runAndSubscribe = runAndSubscribe;
    class EmitterObserver {
      constructor(_observable, store) {
        this._observable = _observable;
        this._counter = 0;
        this._hasChanged = false;
        const options = {
          onWillAddFirstListener: () => {
            _observable.addObserver(this);
          },
          onDidRemoveLastListener: () => {
            _observable.removeObserver(this);
          }
        };
        if (!store) {
          _addLeakageTraceLogic(options);
        }
        this.emitter = new Emitter(options);
        if (store) {
          store.add(this.emitter);
        }
      }
      beginUpdate(_observable) {
        this._counter++;
      }
      handlePossibleChange(_observable) {
      }
      handleChange(_observable, _change) {
        this._hasChanged = true;
      }
      endUpdate(_observable) {
        this._counter--;
        if (this._counter === 0) {
          this._observable.reportChanges();
          if (this._hasChanged) {
            this._hasChanged = false;
            this.emitter.fire(this._observable.get());
          }
        }
      }
    }
    function fromObservable(obs, store) {
      const observer = new EmitterObserver(obs, store);
      return observer.emitter.event;
    }
    Event2.fromObservable = fromObservable;
    function fromObservableLight(observable) {
      return (listener, thisArgs, disposables) => {
        let count = 0;
        let didChange = false;
        const observer = {
          beginUpdate() {
            count++;
          },
          endUpdate() {
            count--;
            if (count === 0) {
              observable.reportChanges();
              if (didChange) {
                didChange = false;
                listener.call(thisArgs);
              }
            }
          },
          handlePossibleChange() {
          },
          handleChange() {
            didChange = true;
          }
        };
        observable.addObserver(observer);
        observable.reportChanges();
        const disposable = {
          dispose() {
            observable.removeObserver(observer);
          }
        };
        if (disposables instanceof DisposableStore) {
          disposables.add(disposable);
        } else if (Array.isArray(disposables)) {
          disposables.push(disposable);
        }
        return disposable;
      };
    }
    Event2.fromObservableLight = fromObservableLight;
  })(Event || (Event = {}));
  var EventProfiling = class _EventProfiling {
    constructor(name) {
      this.listenerCount = 0;
      this.invocationCount = 0;
      this.elapsedOverall = 0;
      this.durations = [];
      this.name = `${name}_${_EventProfiling._idPool++}`;
      _EventProfiling.all.add(this);
    }
    start(listenerCount) {
      this._stopWatch = new StopWatch();
      this.listenerCount = listenerCount;
    }
    stop() {
      if (this._stopWatch) {
        const elapsed = this._stopWatch.elapsed();
        this.durations.push(elapsed);
        this.elapsedOverall += elapsed;
        this.invocationCount += 1;
        this._stopWatch = void 0;
      }
    }
  };
  EventProfiling.all = /* @__PURE__ */ new Set();
  EventProfiling._idPool = 0;
  var _globalLeakWarningThreshold = -1;
  var LeakageMonitor = class {
    constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
      this.threshold = threshold;
      this.name = name;
      this._warnCountdown = 0;
    }
    dispose() {
      var _a4;
      (_a4 = this._stacks) === null || _a4 === void 0 ? void 0 : _a4.clear();
    }
    check(stack, listenerCount) {
      const threshold = this.threshold;
      if (threshold <= 0 || listenerCount < threshold) {
        return void 0;
      }
      if (!this._stacks) {
        this._stacks = /* @__PURE__ */ new Map();
      }
      const count = this._stacks.get(stack.value) || 0;
      this._stacks.set(stack.value, count + 1);
      this._warnCountdown -= 1;
      if (this._warnCountdown <= 0) {
        this._warnCountdown = threshold * 0.5;
        let topStack;
        let topCount = 0;
        for (const [stack2, count2] of this._stacks) {
          if (!topStack || topCount < count2) {
            topStack = stack2;
            topCount = count2;
          }
        }
        console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
        console.warn(topStack);
      }
      return () => {
        const count2 = this._stacks.get(stack.value) || 0;
        this._stacks.set(stack.value, count2 - 1);
      };
    }
  };
  var Stacktrace = class _Stacktrace {
    static create() {
      var _a4;
      return new _Stacktrace((_a4 = new Error().stack) !== null && _a4 !== void 0 ? _a4 : "");
    }
    constructor(value2) {
      this.value = value2;
    }
    print() {
      console.warn(this.value.split("\n").slice(2).join("\n"));
    }
  };
  var UniqueContainer = class {
    constructor(value2) {
      this.value = value2;
    }
  };
  var compactionThreshold = 2;
  var forEachListener = (listeners, fn2) => {
    if (listeners instanceof UniqueContainer) {
      fn2(listeners);
    } else {
      for (let i = 0; i < listeners.length; i++) {
        const l = listeners[i];
        if (l) {
          fn2(l);
        }
      }
    }
  };
  var _listenerFinalizers = _enableListenerGCedWarning ? new FinalizationRegistry((heldValue) => {
    if (typeof heldValue === "string") {
      console.warn("[LEAKING LISTENER] GC'ed a listener that was NOT yet disposed. This is where is was created:");
      console.warn(heldValue);
    }
  }) : void 0;
  var Emitter = class {
    constructor(options) {
      var _a4, _b3, _c, _d, _e;
      this._size = 0;
      this._options = options;
      this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.leakWarningThreshold) ? new LeakageMonitor((_c = (_b3 = this._options) === null || _b3 === void 0 ? void 0 : _b3.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : void 0;
      this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : void 0;
      this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;
    }
    dispose() {
      var _a4, _b3, _c, _d;
      if (!this._disposed) {
        this._disposed = true;
        if (((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) === this) {
          this._deliveryQueue.reset();
        }
        if (this._listeners) {
          if (_enableDisposeWithListenerWarning) {
            const listeners = this._listeners;
            queueMicrotask(() => {
              forEachListener(listeners, (l) => {
                var _a5;
                return (_a5 = l.stack) === null || _a5 === void 0 ? void 0 : _a5.print();
              });
            });
          }
          this._listeners = void 0;
          this._size = 0;
        }
        (_c = (_b3 = this._options) === null || _b3 === void 0 ? void 0 : _b3.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b3);
        (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
      }
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
      var _a4;
      (_a4 = this._event) !== null && _a4 !== void 0 ? _a4 : this._event = (callback, thisArgs, disposables) => {
        var _a5, _b3, _c, _d, _e;
        if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {
          console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);
          return Disposable.None;
        }
        if (this._disposed) {
          return Disposable.None;
        }
        if (thisArgs) {
          callback = callback.bind(thisArgs);
        }
        const contained = new UniqueContainer(callback);
        let removeMonitor;
        let stack;
        if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
          contained.stack = Stacktrace.create();
          removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
        }
        if (_enableDisposeWithListenerWarning) {
          contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
        }
        if (!this._listeners) {
          (_b3 = (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.onWillAddFirstListener) === null || _b3 === void 0 ? void 0 : _b3.call(_a5, this);
          this._listeners = contained;
          (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        } else if (this._listeners instanceof UniqueContainer) {
          (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : this._deliveryQueue = new EventDeliveryQueuePrivate();
          this._listeners = [this._listeners, contained];
        } else {
          this._listeners.push(contained);
        }
        this._size++;
        const result = toDisposable(() => {
          _listenerFinalizers === null || _listenerFinalizers === void 0 ? void 0 : _listenerFinalizers.unregister(result);
          removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();
          this._removeListener(contained);
        });
        if (disposables instanceof DisposableStore) {
          disposables.add(result);
        } else if (Array.isArray(disposables)) {
          disposables.push(result);
        }
        if (_listenerFinalizers) {
          const stack2 = new Error().stack.split("\n").slice(2).join("\n").trim();
          _listenerFinalizers.register(result, stack2, result);
        }
        return result;
      };
      return this._event;
    }
    _removeListener(listener) {
      var _a4, _b3, _c, _d;
      (_b3 = (_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onWillRemoveListener) === null || _b3 === void 0 ? void 0 : _b3.call(_a4, this);
      if (!this._listeners) {
        return;
      }
      if (this._size === 1) {
        this._listeners = void 0;
        (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        this._size = 0;
        return;
      }
      const listeners = this._listeners;
      const index2 = listeners.indexOf(listener);
      if (index2 === -1) {
        console.log("disposed?", this._disposed);
        console.log("size?", this._size);
        console.log("arr?", JSON.stringify(this._listeners));
        throw new Error("Attempted to dispose unknown listener");
      }
      this._size--;
      listeners[index2] = void 0;
      const adjustDeliveryQueue = this._deliveryQueue.current === this;
      if (this._size * compactionThreshold <= listeners.length) {
        let n2 = 0;
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i]) {
            listeners[n2++] = listeners[i];
          } else if (adjustDeliveryQueue) {
            this._deliveryQueue.end--;
            if (n2 < this._deliveryQueue.i) {
              this._deliveryQueue.i--;
            }
          }
        }
        listeners.length = n2;
      }
    }
    _deliver(listener, value2) {
      var _a4;
      if (!listener) {
        return;
      }
      const errorHandler2 = ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onListenerError) || onUnexpectedError;
      if (!errorHandler2) {
        listener.value(value2);
        return;
      }
      try {
        listener.value(value2);
      } catch (e2) {
        errorHandler2(e2);
      }
    }
    /** Delivers items in the queue. Assumes the queue is ready to go. */
    _deliverQueue(dq) {
      const listeners = dq.current._listeners;
      while (dq.i < dq.end) {
        this._deliver(listeners[dq.i++], dq.value);
      }
      dq.reset();
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
      var _a4, _b3, _c, _d;
      if ((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) {
        this._deliverQueue(this._deliveryQueue);
        (_b3 = this._perfMon) === null || _b3 === void 0 ? void 0 : _b3.stop();
      }
      (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);
      if (!this._listeners) {
      } else if (this._listeners instanceof UniqueContainer) {
        this._deliver(this._listeners, event);
      } else {
        const dq = this._deliveryQueue;
        dq.enqueue(this, event, this._listeners.length);
        this._deliverQueue(dq);
      }
      (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();
    }
    hasListeners() {
      return this._size > 0;
    }
  };
  var EventDeliveryQueuePrivate = class {
    constructor() {
      this.i = -1;
      this.end = 0;
    }
    enqueue(emitter, value2, end) {
      this.i = 0;
      this.end = end;
      this.current = emitter;
      this.value = value2;
    }
    reset() {
      this.i = this.end;
      this.current = void 0;
      this.value = void 0;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/types.js
  function isString(str) {
    return typeof str === "string";
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/objects.js
  function getAllPropertyNames(obj) {
    let res = [];
    while (Object.prototype !== obj) {
      res = res.concat(Object.getOwnPropertyNames(obj));
      obj = Object.getPrototypeOf(obj);
    }
    return res;
  }
  function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
      if (typeof obj[prop] === "function") {
        methods.push(prop);
      }
    }
    return methods;
  }
  function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/nls.js
  var isPseudo = typeof document !== "undefined" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
  function _format(message, args) {
    let result;
    if (args.length === 0) {
      result = message;
    } else {
      result = message.replace(/\{(\d+)\}/g, (match, rest) => {
        const index2 = rest[0];
        const arg = args[index2];
        let result2 = match;
        if (typeof arg === "string") {
          result2 = arg;
        } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
          result2 = String(arg);
        }
        return result2;
      });
    }
    if (isPseudo) {
      result = "\uFF3B" + result.replace(/[aouei]/g, "$&$&") + "\uFF3D";
    }
    return result;
  }
  function localize(data, message, ...args) {
    return _format(message, args);
  }
  function getConfiguredDefaultLocale(_) {
    return void 0;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/platform.js
  var _a;
  var _b;
  var LANGUAGE_DEFAULT = "en";
  var _isWindows = false;
  var _isMacintosh = false;
  var _isLinux = false;
  var _isLinuxSnap = false;
  var _isNative = false;
  var _isWeb = false;
  var _isElectron = false;
  var _isIOS = false;
  var _isCI = false;
  var _isMobile = false;
  var _locale = void 0;
  var _language = LANGUAGE_DEFAULT;
  var _platformLocale = LANGUAGE_DEFAULT;
  var _translationsConfigFile = void 0;
  var _userAgent = void 0;
  var $globalThis = globalThis;
  var nodeProcess = void 0;
  if (typeof $globalThis.vscode !== "undefined" && typeof $globalThis.vscode.process !== "undefined") {
    nodeProcess = $globalThis.vscode.process;
  } else if (typeof process !== "undefined" && typeof ((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) === "string") {
    nodeProcess = process;
  }
  var isElectronProcess = typeof ((_b = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _b === void 0 ? void 0 : _b.electron) === "string";
  var isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
  if (typeof nodeProcess === "object") {
    _isWindows = nodeProcess.platform === "win32";
    _isMacintosh = nodeProcess.platform === "darwin";
    _isLinux = nodeProcess.platform === "linux";
    _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
    _isElectron = isElectronProcess;
    _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
    if (rawNlsConfig) {
      try {
        const nlsConfig = JSON.parse(rawNlsConfig);
        const resolved = nlsConfig.availableLanguages["*"];
        _locale = nlsConfig.locale;
        _platformLocale = nlsConfig.osLocale;
        _language = resolved ? resolved : LANGUAGE_DEFAULT;
        _translationsConfigFile = nlsConfig._translationsConfigFile;
      } catch (e2) {
      }
    }
    _isNative = true;
  } else if (typeof navigator === "object" && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _isWindows = _userAgent.indexOf("Windows") >= 0;
    _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
    _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _isLinux = _userAgent.indexOf("Linux") >= 0;
    _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf("Mobi")) >= 0;
    _isWeb = true;
    const configuredLocale = getConfiguredDefaultLocale(
      // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`
      // to ensure that the NLS AMD Loader plugin has been loaded and configured.
      // This is because the loader plugin decides what the default locale is based on
      // how it's able to resolve the strings.
      localize({ key: "ensureLoaderPluginIsLoaded", comment: ["{Locked}"] }, "_")
    );
    _locale = configuredLocale || LANGUAGE_DEFAULT;
    _language = _locale;
    _platformLocale = navigator.language;
  } else {
    console.error("Unable to resolve platform.");
  }
  var _platform = 0;
  if (_isMacintosh) {
    _platform = 1;
  } else if (_isWindows) {
    _platform = 3;
  } else if (_isLinux) {
    _platform = 2;
  }
  var isWindows = _isWindows;
  var isMacintosh = _isMacintosh;
  var isWebWorker = _isWeb && typeof $globalThis.importScripts === "function";
  var webWorkerOrigin = isWebWorker ? $globalThis.origin : void 0;
  var userAgent = _userAgent;
  var setTimeout0IsFaster = typeof $globalThis.postMessage === "function" && !$globalThis.importScripts;
  var setTimeout0 = (() => {
    if (setTimeout0IsFaster) {
      const pending = [];
      $globalThis.addEventListener("message", (e2) => {
        if (e2.data && e2.data.vscodeScheduleAsyncWork) {
          for (let i = 0, len = pending.length; i < len; i++) {
            const candidate = pending[i];
            if (candidate.id === e2.data.vscodeScheduleAsyncWork) {
              pending.splice(i, 1);
              candidate.callback();
              return;
            }
          }
        }
      });
      let lastId = 0;
      return (callback) => {
        const myId = ++lastId;
        pending.push({
          id: myId,
          callback
        });
        $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
      };
    }
    return (callback) => setTimeout(callback);
  })();
  var isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
  var isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
  var isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
  var isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
  var isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/cache.js
  function identity(t) {
    return t;
  }
  var LRUCachedFunction = class {
    constructor(arg1, arg2) {
      this.lastCache = void 0;
      this.lastArgKey = void 0;
      if (typeof arg1 === "function") {
        this._fn = arg1;
        this._computeKey = identity;
      } else {
        this._fn = arg2;
        this._computeKey = arg1.getCacheKey;
      }
    }
    get(arg) {
      const key = this._computeKey(arg);
      if (this.lastArgKey !== key) {
        this.lastArgKey = key;
        this.lastCache = this._fn(arg);
      }
      return this.lastCache;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js
  var Lazy = class {
    constructor(executor) {
      this.executor = executor;
      this._didRun = false;
    }
    /**
     * Get the wrapped value.
     *
     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
     */
    get value() {
      if (!this._didRun) {
        try {
          this._value = this.executor();
        } catch (err) {
          this._error = err;
        } finally {
          this._didRun = true;
        }
      }
      if (this._error) {
        throw this._error;
      }
      return this._value;
    }
    /**
     * Get the wrapped value without forcing evaluation.
     */
    get rawValue() {
      return this._value;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/strings.js
  var _a2;
  function escapeRegExpCharacters(value2) {
    return value2.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function splitLines(str) {
    return str.split(/\r\n|\r|\n/);
  }
  function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function isUpperAsciiLetter(code) {
    return code >= 65 && code <= 90;
  }
  function isHighSurrogate(charCode) {
    return 55296 <= charCode && charCode <= 56319;
  }
  function isLowSurrogate(charCode) {
    return 56320 <= charCode && charCode <= 57343;
  }
  function computeCodePoint(highSurrogate, lowSurrogate) {
    return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
  }
  function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
      const nextCharCode = str.charCodeAt(offset + 1);
      if (isLowSurrogate(nextCharCode)) {
        return computeCodePoint(charCode, nextCharCode);
      }
    }
    return charCode;
  }
  var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
  function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
  }
  var UTF8_BOM_CHARACTER = String.fromCharCode(
    65279
    /* CharCode.UTF8_BOM */
  );
  var GraphemeBreakTree = class _GraphemeBreakTree {
    static getInstance() {
      if (!_GraphemeBreakTree._INSTANCE) {
        _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();
      }
      return _GraphemeBreakTree._INSTANCE;
    }
    constructor() {
      this._data = getGraphemeBreakRawData();
    }
    getGraphemeBreakType(codePoint) {
      if (codePoint < 32) {
        if (codePoint === 10) {
          return 3;
        }
        if (codePoint === 13) {
          return 2;
        }
        return 4;
      }
      if (codePoint < 127) {
        return 0;
      }
      const data = this._data;
      const nodeCount = data.length / 3;
      let nodeIndex = 1;
      while (nodeIndex <= nodeCount) {
        if (codePoint < data[3 * nodeIndex]) {
          nodeIndex = 2 * nodeIndex;
        } else if (codePoint > data[3 * nodeIndex + 1]) {
          nodeIndex = 2 * nodeIndex + 1;
        } else {
          return data[3 * nodeIndex + 2];
        }
      }
      return 0;
    }
  };
  GraphemeBreakTree._INSTANCE = null;
  function getGraphemeBreakRawData() {
    return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
  }
  var AmbiguousCharacters = class {
    static getInstance(locales) {
      return _a2.cache.get(Array.from(locales));
    }
    static getLocales() {
      return _a2._locales.value;
    }
    constructor(confusableDictionary) {
      this.confusableDictionary = confusableDictionary;
    }
    isAmbiguous(codePoint) {
      return this.confusableDictionary.has(codePoint);
    }
    /**
     * Returns the non basic ASCII code point that the given code point can be confused,
     * or undefined if such code point does note exist.
     */
    getPrimaryConfusable(codePoint) {
      return this.confusableDictionary.get(codePoint);
    }
    getConfusableCodePoints() {
      return new Set(this.confusableDictionary.keys());
    }
  };
  _a2 = AmbiguousCharacters;
  AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
    return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
  });
  AmbiguousCharacters.cache = new LRUCachedFunction({ getCacheKey: JSON.stringify }, (locales) => {
    function arrayToMap(arr) {
      const result = /* @__PURE__ */ new Map();
      for (let i = 0; i < arr.length; i += 2) {
        result.set(arr[i], arr[i + 1]);
      }
      return result;
    }
    function mergeMaps(map1, map2) {
      const result = new Map(map1);
      for (const [key, value2] of map2) {
        result.set(key, value2);
      }
      return result;
    }
    function intersectMaps(map1, map2) {
      if (!map1) {
        return map2;
      }
      const result = /* @__PURE__ */ new Map();
      for (const [key, value2] of map1) {
        if (map2.has(key)) {
          result.set(key, value2);
        }
      }
      return result;
    }
    const data = _a2.ambiguousCharacterData.value;
    let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
    if (filteredLocales.length === 0) {
      filteredLocales = ["_default"];
    }
    let languageSpecificMap = void 0;
    for (const locale of filteredLocales) {
      const map2 = arrayToMap(data[locale]);
      languageSpecificMap = intersectMaps(languageSpecificMap, map2);
    }
    const commonMap = arrayToMap(data["_common"]);
    const map = mergeMaps(commonMap, languageSpecificMap);
    return new _a2(map);
  });
  AmbiguousCharacters._locales = new Lazy(() => Object.keys(_a2.ambiguousCharacterData.value).filter((k2) => !k2.startsWith("_")));
  var InvisibleCharacters = class _InvisibleCharacters {
    static getRawData() {
      return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
    }
    static getData() {
      if (!this._data) {
        this._data = new Set(_InvisibleCharacters.getRawData());
      }
      return this._data;
    }
    static isInvisibleCharacter(codePoint) {
      return _InvisibleCharacters.getData().has(codePoint);
    }
    static get codePoints() {
      return _InvisibleCharacters.getData();
    }
  };
  InvisibleCharacters._data = void 0;

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
  var INITIALIZE = "$initialize";
  var RequestMessage = class {
    constructor(vsWorker, req, method, args) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.method = method;
      this.args = args;
      this.type = 0;
    }
  };
  var ReplyMessage = class {
    constructor(vsWorker, seq, res, err) {
      this.vsWorker = vsWorker;
      this.seq = seq;
      this.res = res;
      this.err = err;
      this.type = 1;
    }
  };
  var SubscribeEventMessage = class {
    constructor(vsWorker, req, eventName, arg) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.eventName = eventName;
      this.arg = arg;
      this.type = 2;
    }
  };
  var EventMessage = class {
    constructor(vsWorker, req, event) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.event = event;
      this.type = 3;
    }
  };
  var UnsubscribeEventMessage = class {
    constructor(vsWorker, req) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.type = 4;
    }
  };
  var SimpleWorkerProtocol = class {
    constructor(handler) {
      this._workerId = -1;
      this._handler = handler;
      this._lastSentReq = 0;
      this._pendingReplies = /* @__PURE__ */ Object.create(null);
      this._pendingEmitters = /* @__PURE__ */ new Map();
      this._pendingEvents = /* @__PURE__ */ new Map();
    }
    setWorkerId(workerId) {
      this._workerId = workerId;
    }
    sendMessage(method, args) {
      const req = String(++this._lastSentReq);
      return new Promise((resolve2, reject) => {
        this._pendingReplies[req] = {
          resolve: resolve2,
          reject
        };
        this._send(new RequestMessage(this._workerId, req, method, args));
      });
    }
    listen(eventName, arg) {
      let req = null;
      const emitter = new Emitter({
        onWillAddFirstListener: () => {
          req = String(++this._lastSentReq);
          this._pendingEmitters.set(req, emitter);
          this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
        },
        onDidRemoveLastListener: () => {
          this._pendingEmitters.delete(req);
          this._send(new UnsubscribeEventMessage(this._workerId, req));
          req = null;
        }
      });
      return emitter.event;
    }
    handleMessage(message) {
      if (!message || !message.vsWorker) {
        return;
      }
      if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
        return;
      }
      this._handleMessage(message);
    }
    _handleMessage(msg) {
      switch (msg.type) {
        case 1:
          return this._handleReplyMessage(msg);
        case 0:
          return this._handleRequestMessage(msg);
        case 2:
          return this._handleSubscribeEventMessage(msg);
        case 3:
          return this._handleEventMessage(msg);
        case 4:
          return this._handleUnsubscribeEventMessage(msg);
      }
    }
    _handleReplyMessage(replyMessage) {
      if (!this._pendingReplies[replyMessage.seq]) {
        console.warn("Got reply to unknown seq");
        return;
      }
      const reply = this._pendingReplies[replyMessage.seq];
      delete this._pendingReplies[replyMessage.seq];
      if (replyMessage.err) {
        let err = replyMessage.err;
        if (replyMessage.err.$isError) {
          err = new Error();
          err.name = replyMessage.err.name;
          err.message = replyMessage.err.message;
          err.stack = replyMessage.err.stack;
        }
        reply.reject(err);
        return;
      }
      reply.resolve(replyMessage.res);
    }
    _handleRequestMessage(requestMessage) {
      const req = requestMessage.req;
      const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
      result.then((r2) => {
        this._send(new ReplyMessage(this._workerId, req, r2, void 0));
      }, (e2) => {
        if (e2.detail instanceof Error) {
          e2.detail = transformErrorForSerialization(e2.detail);
        }
        this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e2)));
      });
    }
    _handleSubscribeEventMessage(msg) {
      const req = msg.req;
      const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
        this._send(new EventMessage(this._workerId, req, event));
      });
      this._pendingEvents.set(req, disposable);
    }
    _handleEventMessage(msg) {
      if (!this._pendingEmitters.has(msg.req)) {
        console.warn("Got event for unknown req");
        return;
      }
      this._pendingEmitters.get(msg.req).fire(msg.event);
    }
    _handleUnsubscribeEventMessage(msg) {
      if (!this._pendingEvents.has(msg.req)) {
        console.warn("Got unsubscribe for unknown req");
        return;
      }
      this._pendingEvents.get(msg.req).dispose();
      this._pendingEvents.delete(msg.req);
    }
    _send(msg) {
      const transfer = [];
      if (msg.type === 0) {
        for (let i = 0; i < msg.args.length; i++) {
          if (msg.args[i] instanceof ArrayBuffer) {
            transfer.push(msg.args[i]);
          }
        }
      } else if (msg.type === 1) {
        if (msg.res instanceof ArrayBuffer) {
          transfer.push(msg.res);
        }
      }
      this._handler.sendMessage(msg, transfer);
    }
  };
  function propertyIsEvent(name) {
    return name[0] === "o" && name[1] === "n" && isUpperAsciiLetter(name.charCodeAt(2));
  }
  function propertyIsDynamicEvent(name) {
    return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));
  }
  function createProxyObject2(methodNames, invoke, proxyListen) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const createProxyDynamicEvent = (eventName) => {
      return function(arg) {
        return proxyListen(eventName, arg);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      if (propertyIsDynamicEvent(methodName)) {
        result[methodName] = createProxyDynamicEvent(methodName);
        continue;
      }
      if (propertyIsEvent(methodName)) {
        result[methodName] = proxyListen(methodName, void 0);
        continue;
      }
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  var SimpleWorkerServer = class {
    constructor(postMessage, requestHandlerFactory) {
      this._requestHandlerFactory = requestHandlerFactory;
      this._requestHandler = null;
      this._protocol = new SimpleWorkerProtocol({
        sendMessage: (msg, transfer) => {
          postMessage(msg, transfer);
        },
        handleMessage: (method, args) => this._handleMessage(method, args),
        handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)
      });
    }
    onmessage(msg) {
      this._protocol.handleMessage(msg);
    }
    _handleMessage(method, args) {
      if (method === INITIALIZE) {
        return this.initialize(args[0], args[1], args[2], args[3]);
      }
      if (!this._requestHandler || typeof this._requestHandler[method] !== "function") {
        return Promise.reject(new Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
      } catch (e2) {
        return Promise.reject(e2);
      }
    }
    _handleEvent(eventName, arg) {
      if (!this._requestHandler) {
        throw new Error(`Missing requestHandler`);
      }
      if (propertyIsDynamicEvent(eventName)) {
        const event = this._requestHandler[eventName].call(this._requestHandler, arg);
        if (typeof event !== "function") {
          throw new Error(`Missing dynamic event ${eventName} on request handler.`);
        }
        return event;
      }
      if (propertyIsEvent(eventName)) {
        const event = this._requestHandler[eventName];
        if (typeof event !== "function") {
          throw new Error(`Missing event ${eventName} on request handler.`);
        }
        return event;
      }
      throw new Error(`Malformed event name ${eventName}`);
    }
    initialize(workerId, loaderConfig, moduleId, hostMethods) {
      this._protocol.setWorkerId(workerId);
      const proxyMethodRequest = (method, args) => {
        return this._protocol.sendMessage(method, args);
      };
      const proxyListen = (eventName, arg) => {
        return this._protocol.listen(eventName, arg);
      };
      const hostProxy = createProxyObject2(hostMethods, proxyMethodRequest, proxyListen);
      if (this._requestHandlerFactory) {
        this._requestHandler = this._requestHandlerFactory(hostProxy);
        return Promise.resolve(getAllMethodNames(this._requestHandler));
      }
      if (loaderConfig) {
        if (typeof loaderConfig.baseUrl !== "undefined") {
          delete loaderConfig["baseUrl"];
        }
        if (typeof loaderConfig.paths !== "undefined") {
          if (typeof loaderConfig.paths.vs !== "undefined") {
            delete loaderConfig.paths["vs"];
          }
        }
        if (typeof loaderConfig.trustedTypesPolicy !== "undefined") {
          delete loaderConfig["trustedTypesPolicy"];
        }
        loaderConfig.catchError = true;
        globalThis.require.config(loaderConfig);
      }
      return new Promise((resolve2, reject) => {
        const req = globalThis.require;
        req([moduleId], (module) => {
          this._requestHandler = module.create(hostProxy);
          if (!this._requestHandler) {
            reject(new Error(`No RequestHandler!`));
            return;
          }
          resolve2(getAllMethodNames(this._requestHandler));
        }, reject);
      });
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
  var DiffChange = class {
    /**
     * Constructs a new DiffChange with the given sequence information
     * and content.
     */
    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
      this.originalStart = originalStart;
      this.originalLength = originalLength;
      this.modifiedStart = modifiedStart;
      this.modifiedLength = modifiedLength;
    }
    /**
     * The end point (exclusive) of the change in the original sequence.
     */
    getOriginalEnd() {
      return this.originalStart + this.originalLength;
    }
    /**
     * The end point (exclusive) of the change in the modified sequence.
     */
    getModifiedEnd() {
      return this.modifiedStart + this.modifiedLength;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/hash.js
  function numberHash(val, initialHashVal) {
    return (initialHashVal << 5) - initialHashVal + val | 0;
  }
  function stringHash(s2, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length2 = s2.length; i < length2; i++) {
      hashVal = numberHash(s2.charCodeAt(i), hashVal);
    }
    return hashVal;
  }
  function leftRotate(value2, bits, totalBits = 32) {
    const delta = totalBits - bits;
    const mask = ~((1 << delta) - 1);
    return (value2 << bits | (mask & value2) >>> delta) >>> 0;
  }
  function fill(dest, index2 = 0, count = dest.byteLength, value2 = 0) {
    for (let i = 0; i < count; i++) {
      dest[index2 + i] = value2;
    }
  }
  function leftPad(value2, length2, char = "0") {
    while (value2.length < length2) {
      value2 = char + value2;
    }
    return value2;
  }
  function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
      return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
  }
  var StringSHA1 = class _StringSHA1 {
    constructor() {
      this._h0 = 1732584193;
      this._h1 = 4023233417;
      this._h2 = 2562383102;
      this._h3 = 271733878;
      this._h4 = 3285377520;
      this._buff = new Uint8Array(
        64 + 3
        /* to fit any utf-8 */
      );
      this._buffDV = new DataView(this._buff.buffer);
      this._buffLen = 0;
      this._totalLen = 0;
      this._leftoverHighSurrogate = 0;
      this._finished = false;
    }
    update(str) {
      const strLen = str.length;
      if (strLen === 0) {
        return;
      }
      const buff = this._buff;
      let buffLen = this._buffLen;
      let leftoverHighSurrogate = this._leftoverHighSurrogate;
      let charCode;
      let offset;
      if (leftoverHighSurrogate !== 0) {
        charCode = leftoverHighSurrogate;
        offset = -1;
        leftoverHighSurrogate = 0;
      } else {
        charCode = str.charCodeAt(0);
        offset = 0;
      }
      while (true) {
        let codePoint = charCode;
        if (isHighSurrogate(charCode)) {
          if (offset + 1 < strLen) {
            const nextCharCode = str.charCodeAt(offset + 1);
            if (isLowSurrogate(nextCharCode)) {
              offset++;
              codePoint = computeCodePoint(charCode, nextCharCode);
            } else {
              codePoint = 65533;
            }
          } else {
            leftoverHighSurrogate = charCode;
            break;
          }
        } else if (isLowSurrogate(charCode)) {
          codePoint = 65533;
        }
        buffLen = this._push(buff, buffLen, codePoint);
        offset++;
        if (offset < strLen) {
          charCode = str.charCodeAt(offset);
        } else {
          break;
        }
      }
      this._buffLen = buffLen;
      this._leftoverHighSurrogate = leftoverHighSurrogate;
    }
    _push(buff, buffLen, codePoint) {
      if (codePoint < 128) {
        buff[buffLen++] = codePoint;
      } else if (codePoint < 2048) {
        buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      } else if (codePoint < 65536) {
        buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
        buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      } else {
        buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
        buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
        buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      }
      if (buffLen >= 64) {
        this._step();
        buffLen -= 64;
        this._totalLen += 64;
        buff[0] = buff[64 + 0];
        buff[1] = buff[64 + 1];
        buff[2] = buff[64 + 2];
      }
      return buffLen;
    }
    digest() {
      if (!this._finished) {
        this._finished = true;
        if (this._leftoverHighSurrogate) {
          this._leftoverHighSurrogate = 0;
          this._buffLen = this._push(
            this._buff,
            this._buffLen,
            65533
            /* SHA1Constant.UNICODE_REPLACEMENT */
          );
        }
        this._totalLen += this._buffLen;
        this._wrapUp();
      }
      return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
    }
    _wrapUp() {
      this._buff[this._buffLen++] = 128;
      fill(this._buff, this._buffLen);
      if (this._buffLen > 56) {
        this._step();
        fill(this._buff);
      }
      const ml = 8 * this._totalLen;
      this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
      this._buffDV.setUint32(60, ml % 4294967296, false);
      this._step();
    }
    _step() {
      const bigBlock32 = _StringSHA1._bigBlock32;
      const data = this._buffDV;
      for (let j = 0; j < 64; j += 4) {
        bigBlock32.setUint32(j, data.getUint32(j, false), false);
      }
      for (let j = 64; j < 320; j += 4) {
        bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
      }
      let a = this._h0;
      let b = this._h1;
      let c4 = this._h2;
      let d = this._h3;
      let e2 = this._h4;
      let f2, k2;
      let temp;
      for (let j = 0; j < 80; j++) {
        if (j < 20) {
          f2 = b & c4 | ~b & d;
          k2 = 1518500249;
        } else if (j < 40) {
          f2 = b ^ c4 ^ d;
          k2 = 1859775393;
        } else if (j < 60) {
          f2 = b & c4 | b & d | c4 & d;
          k2 = 2400959708;
        } else {
          f2 = b ^ c4 ^ d;
          k2 = 3395469782;
        }
        temp = leftRotate(a, 5) + f2 + e2 + k2 + bigBlock32.getUint32(j * 4, false) & 4294967295;
        e2 = d;
        d = c4;
        c4 = leftRotate(b, 30);
        b = a;
        a = temp;
      }
      this._h0 = this._h0 + a & 4294967295;
      this._h1 = this._h1 + b & 4294967295;
      this._h2 = this._h2 + c4 & 4294967295;
      this._h3 = this._h3 + d & 4294967295;
      this._h4 = this._h4 + e2 & 4294967295;
    }
  };
  StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
  var StringDiffSequence = class {
    constructor(source) {
      this.source = source;
    }
    getElements() {
      const source = this.source;
      const characters = new Int32Array(source.length);
      for (let i = 0, len = source.length; i < len; i++) {
        characters[i] = source.charCodeAt(i);
      }
      return characters;
    }
  };
  function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
  }
  var Debug = class {
    static Assert(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
  };
  var MyArray = class {
    /**
     * Copies a range of elements from an Array starting at the specified source index and pastes
     * them to another Array starting at the specified destination index. The length and the indexes
     * are specified as 64-bit integers.
     * sourceArray:
     *		The Array that contains the data to copy.
     * sourceIndex:
     *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
     * destinationArray:
     *		The Array that receives the data.
     * destinationIndex:
     *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
     * length:
     *		A 64-bit integer that represents the number of elements to copy.
     */
    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length2) {
      for (let i = 0; i < length2; i++) {
        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
      }
    }
    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length2) {
      for (let i = 0; i < length2; i++) {
        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
      }
    }
  };
  var DiffChangeHelper = class {
    /**
     * Constructs a new DiffChangeHelper for the given DiffSequences.
     */
    constructor() {
      this.m_changes = [];
      this.m_originalStart = 1073741824;
      this.m_modifiedStart = 1073741824;
      this.m_originalCount = 0;
      this.m_modifiedCount = 0;
    }
    /**
     * Marks the beginning of the next change in the set of differences.
     */
    MarkNextChange() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
      }
      this.m_originalCount = 0;
      this.m_modifiedCount = 0;
      this.m_originalStart = 1073741824;
      this.m_modifiedStart = 1073741824;
    }
    /**
     * Adds the original element at the given position to the elements
     * affected by the current change. The modified index gives context
     * to the change position with respect to the original sequence.
     * @param originalIndex The index of the original element to add.
     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
     */
    AddOriginalElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_originalCount++;
    }
    /**
     * Adds the modified element at the given position to the elements
     * affected by the current change. The original index gives context
     * to the change position with respect to the modified sequence.
     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
     * @param modifiedIndex The index of the modified element to add.
     */
    AddModifiedElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_modifiedCount++;
    }
    /**
     * Retrieves all of the changes marked by the class.
     */
    getChanges() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.MarkNextChange();
      }
      return this.m_changes;
    }
    /**
     * Retrieves all of the changes marked by the class in the reverse order
     */
    getReverseChanges() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.MarkNextChange();
      }
      this.m_changes.reverse();
      return this.m_changes;
    }
  };
  var LcsDiff = class _LcsDiff {
    /**
     * Constructs the DiffFinder
     */
    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
      this.ContinueProcessingPredicate = continueProcessingPredicate;
      this._originalSequence = originalSequence;
      this._modifiedSequence = modifiedSequence;
      const [originalStringElements, originalElementsOrHash, originalHasStrings] = _LcsDiff._getElements(originalSequence);
      const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = _LcsDiff._getElements(modifiedSequence);
      this._hasStrings = originalHasStrings && modifiedHasStrings;
      this._originalStringElements = originalStringElements;
      this._originalElementsOrHash = originalElementsOrHash;
      this._modifiedStringElements = modifiedStringElements;
      this._modifiedElementsOrHash = modifiedElementsOrHash;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
    }
    static _isStringArray(arr) {
      return arr.length > 0 && typeof arr[0] === "string";
    }
    static _getElements(sequence) {
      const elements = sequence.getElements();
      if (_LcsDiff._isStringArray(elements)) {
        const hashes = new Int32Array(elements.length);
        for (let i = 0, len = elements.length; i < len; i++) {
          hashes[i] = stringHash(elements[i], 0);
        }
        return [elements, hashes, true];
      }
      if (elements instanceof Int32Array) {
        return [[], elements, false];
      }
      return [[], new Int32Array(elements), false];
    }
    ElementsAreEqual(originalIndex, newIndex) {
      if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
        return false;
      }
      return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
    }
    ElementsAreStrictEqual(originalIndex, newIndex) {
      if (!this.ElementsAreEqual(originalIndex, newIndex)) {
        return false;
      }
      const originalElement = _LcsDiff._getStrictElement(this._originalSequence, originalIndex);
      const modifiedElement = _LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
      return originalElement === modifiedElement;
    }
    static _getStrictElement(sequence, index2) {
      if (typeof sequence.getStrictElement === "function") {
        return sequence.getStrictElement(index2);
      }
      return null;
    }
    OriginalElementsAreEqual(index1, index2) {
      if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
        return false;
      }
      return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
    }
    ModifiedElementsAreEqual(index1, index2) {
      if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
        return false;
      }
      return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
    }
    ComputeDiff(pretty) {
      return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
    }
    /**
     * Computes the differences between the original and modified input
     * sequences on the bounded range.
     * @returns An array of the differences between the two input sequences.
     */
    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
      const quitEarlyArr = [false];
      let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
      if (pretty) {
        changes = this.PrettifyChanges(changes);
      }
      return {
        quitEarly: quitEarlyArr[0],
        changes
      };
    }
    /**
     * Private helper method which computes the differences on the bounded range
     * recursively.
     * @returns An array of the differences between the two input sequences.
     */
    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
      quitEarlyArr[0] = false;
      while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
        originalStart++;
        modifiedStart++;
      }
      while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
        originalEnd--;
        modifiedEnd--;
      }
      if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
        let changes;
        if (modifiedStart <= modifiedEnd) {
          Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
          changes = [
            new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        } else if (originalStart <= originalEnd) {
          Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
          changes = [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
          ];
        } else {
          Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
          Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
          changes = [];
        }
        return changes;
      }
      const midOriginalArr = [0];
      const midModifiedArr = [0];
      const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
      const midOriginal = midOriginalArr[0];
      const midModified = midModifiedArr[0];
      if (result !== null) {
        return result;
      } else if (!quitEarlyArr[0]) {
        const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
        let rightChanges = [];
        if (!quitEarlyArr[0]) {
          rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
        } else {
          rightChanges = [
            new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
          ];
        }
        return this.ConcatenateChanges(leftChanges, rightChanges);
      }
      return [
        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
      ];
    }
    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
      let forwardChanges = null;
      let reverseChanges = null;
      let changeHelper = new DiffChangeHelper();
      let diagonalMin = diagonalForwardStart;
      let diagonalMax = diagonalForwardEnd;
      let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
      let lastOriginalIndex = -1073741824;
      let historyIndex = this.m_forwardHistory.length - 1;
      do {
        const diagonal = diagonalRelative + diagonalForwardBase;
        if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
          originalIndex = forwardPoints[diagonal + 1];
          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
          if (originalIndex < lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex;
          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
          diagonalRelative = diagonal + 1 - diagonalForwardBase;
        } else {
          originalIndex = forwardPoints[diagonal - 1] + 1;
          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
          if (originalIndex < lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex - 1;
          changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
          diagonalRelative = diagonal - 1 - diagonalForwardBase;
        }
        if (historyIndex >= 0) {
          forwardPoints = this.m_forwardHistory[historyIndex];
          diagonalForwardBase = forwardPoints[0];
          diagonalMin = 1;
          diagonalMax = forwardPoints.length - 1;
        }
      } while (--historyIndex >= -1);
      forwardChanges = changeHelper.getReverseChanges();
      if (quitEarlyArr[0]) {
        let originalStartPoint = midOriginalArr[0] + 1;
        let modifiedStartPoint = midModifiedArr[0] + 1;
        if (forwardChanges !== null && forwardChanges.length > 0) {
          const lastForwardChange = forwardChanges[forwardChanges.length - 1];
          originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
          modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
        }
        reverseChanges = [
          new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
        ];
      } else {
        changeHelper = new DiffChangeHelper();
        diagonalMin = diagonalReverseStart;
        diagonalMax = diagonalReverseEnd;
        diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
        lastOriginalIndex = 1073741824;
        historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
        do {
          const diagonal = diagonalRelative + diagonalReverseBase;
          if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
            originalIndex = reversePoints[diagonal + 1] - 1;
            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
            if (originalIndex > lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex + 1;
            changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
            diagonalRelative = diagonal + 1 - diagonalReverseBase;
          } else {
            originalIndex = reversePoints[diagonal - 1];
            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
            if (originalIndex > lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex;
            changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
            diagonalRelative = diagonal - 1 - diagonalReverseBase;
          }
          if (historyIndex >= 0) {
            reversePoints = this.m_reverseHistory[historyIndex];
            diagonalReverseBase = reversePoints[0];
            diagonalMin = 1;
            diagonalMax = reversePoints.length - 1;
          }
        } while (--historyIndex >= -1);
        reverseChanges = changeHelper.getChanges();
      }
      return this.ConcatenateChanges(forwardChanges, reverseChanges);
    }
    /**
     * Given the range to compute the diff on, this method finds the point:
     * (midOriginal, midModified)
     * that exists in the middle of the LCS of the two sequences and
     * is the point at which the LCS problem may be broken down recursively.
     * This method will try to keep the LCS trace in memory. If the LCS recursion
     * point is calculated and the full trace is available in memory, then this method
     * will return the change list.
     * @param originalStart The start bound of the original sequence range
     * @param originalEnd The end bound of the original sequence range
     * @param modifiedStart The start bound of the modified sequence range
     * @param modifiedEnd The end bound of the modified sequence range
     * @param midOriginal The middle point of the original sequence range
     * @param midModified The middle point of the modified sequence range
     * @returns The diff changes, if available, otherwise null
     */
    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
      let originalIndex = 0, modifiedIndex = 0;
      let diagonalForwardStart = 0, diagonalForwardEnd = 0;
      let diagonalReverseStart = 0, diagonalReverseEnd = 0;
      originalStart--;
      modifiedStart--;
      midOriginalArr[0] = 0;
      midModifiedArr[0] = 0;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
      const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
      const numDiagonals = maxDifferences + 1;
      const forwardPoints = new Int32Array(numDiagonals);
      const reversePoints = new Int32Array(numDiagonals);
      const diagonalForwardBase = modifiedEnd - modifiedStart;
      const diagonalReverseBase = originalEnd - originalStart;
      const diagonalForwardOffset = originalStart - modifiedStart;
      const diagonalReverseOffset = originalEnd - modifiedEnd;
      const delta = diagonalReverseBase - diagonalForwardBase;
      const deltaIsEven = delta % 2 === 0;
      forwardPoints[diagonalForwardBase] = originalStart;
      reversePoints[diagonalReverseBase] = originalEnd;
      quitEarlyArr[0] = false;
      for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
        let furthestOriginalIndex = 0;
        let furthestModifiedIndex = 0;
        diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
          if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
            originalIndex = forwardPoints[diagonal + 1];
          } else {
            originalIndex = forwardPoints[diagonal - 1] + 1;
          }
          modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
          const tempOriginalIndex = originalIndex;
          while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
            originalIndex++;
            modifiedIndex++;
          }
          forwardPoints[diagonal] = originalIndex;
          if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
            furthestOriginalIndex = originalIndex;
            furthestModifiedIndex = modifiedIndex;
          }
          if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
            if (originalIndex >= reversePoints[diagonal]) {
              midOriginalArr[0] = originalIndex;
              midModifiedArr[0] = modifiedIndex;
              if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                return null;
              }
            }
          }
        }
        const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
        if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
          quitEarlyArr[0] = true;
          midOriginalArr[0] = furthestOriginalIndex;
          midModifiedArr[0] = furthestModifiedIndex;
          if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
          } else {
            originalStart++;
            modifiedStart++;
            return [
              new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
            ];
          }
        }
        diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
          if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
            originalIndex = reversePoints[diagonal + 1] - 1;
          } else {
            originalIndex = reversePoints[diagonal - 1];
          }
          modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
          const tempOriginalIndex = originalIndex;
          while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
            originalIndex--;
            modifiedIndex--;
          }
          reversePoints[diagonal] = originalIndex;
          if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
            if (originalIndex <= forwardPoints[diagonal]) {
              midOriginalArr[0] = originalIndex;
              midModifiedArr[0] = modifiedIndex;
              if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                return null;
              }
            }
          }
        }
        if (numDifferences <= 1447) {
          let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
          temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
          MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
          this.m_forwardHistory.push(temp);
          temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
          temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
          MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
          this.m_reverseHistory.push(temp);
        }
      }
      return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
    }
    /**
     * Shifts the given changes to provide a more intuitive diff.
     * While the first element in a diff matches the first element after the diff,
     * we shift the diff down.
     *
     * @param changes The list of changes to shift
     * @returns The shifted changes
     */
    PrettifyChanges(changes) {
      for (let i = 0; i < changes.length; i++) {
        const change = changes[i];
        const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
        const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
        const checkOriginal = change.originalLength > 0;
        const checkModified = change.modifiedLength > 0;
        while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
          const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
          const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
          if (endStrictEqual && !startStrictEqual) {
            break;
          }
          change.originalStart++;
          change.modifiedStart++;
        }
        const mergedChangeArr = [null];
        if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
          changes[i] = mergedChangeArr[0];
          changes.splice(i + 1, 1);
          i--;
          continue;
        }
      }
      for (let i = changes.length - 1; i >= 0; i--) {
        const change = changes[i];
        let originalStop = 0;
        let modifiedStop = 0;
        if (i > 0) {
          const prevChange = changes[i - 1];
          originalStop = prevChange.originalStart + prevChange.originalLength;
          modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
        }
        const checkOriginal = change.originalLength > 0;
        const checkModified = change.modifiedLength > 0;
        let bestDelta = 0;
        let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
        for (let delta = 1; ; delta++) {
          const originalStart = change.originalStart - delta;
          const modifiedStart = change.modifiedStart - delta;
          if (originalStart < originalStop || modifiedStart < modifiedStop) {
            break;
          }
          if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
            break;
          }
          if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
            break;
          }
          const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
          const score2 = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
          if (score2 > bestScore) {
            bestScore = score2;
            bestDelta = delta;
          }
        }
        change.originalStart -= bestDelta;
        change.modifiedStart -= bestDelta;
        const mergedChangeArr = [null];
        if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
          changes[i - 1] = mergedChangeArr[0];
          changes.splice(i, 1);
          i++;
          continue;
        }
      }
      if (this._hasStrings) {
        for (let i = 1, len = changes.length; i < len; i++) {
          const aChange = changes[i - 1];
          const bChange = changes[i];
          const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
          const aOriginalStart = aChange.originalStart;
          const bOriginalEnd = bChange.originalStart + bChange.originalLength;
          const abOriginalLength = bOriginalEnd - aOriginalStart;
          const aModifiedStart = aChange.modifiedStart;
          const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
          const abModifiedLength = bModifiedEnd - aModifiedStart;
          if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
            const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
            if (t) {
              const [originalMatchStart, modifiedMatchStart] = t;
              if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                aChange.originalLength = originalMatchStart - aChange.originalStart;
                aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                bChange.originalStart = originalMatchStart + matchedLength;
                bChange.modifiedStart = modifiedMatchStart + matchedLength;
                bChange.originalLength = bOriginalEnd - bChange.originalStart;
                bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
              }
            }
          }
        }
      }
      return changes;
    }
    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
      if (originalLength < desiredLength || modifiedLength < desiredLength) {
        return null;
      }
      const originalMax = originalStart + originalLength - desiredLength + 1;
      const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
      let bestScore = 0;
      let bestOriginalStart = 0;
      let bestModifiedStart = 0;
      for (let i = originalStart; i < originalMax; i++) {
        for (let j = modifiedStart; j < modifiedMax; j++) {
          const score2 = this._contiguousSequenceScore(i, j, desiredLength);
          if (score2 > 0 && score2 > bestScore) {
            bestScore = score2;
            bestOriginalStart = i;
            bestModifiedStart = j;
          }
        }
      }
      if (bestScore > 0) {
        return [bestOriginalStart, bestModifiedStart];
      }
      return null;
    }
    _contiguousSequenceScore(originalStart, modifiedStart, length2) {
      let score2 = 0;
      for (let l = 0; l < length2; l++) {
        if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
          return 0;
        }
        score2 += this._originalStringElements[originalStart + l].length;
      }
      return score2;
    }
    _OriginalIsBoundary(index2) {
      if (index2 <= 0 || index2 >= this._originalElementsOrHash.length - 1) {
        return true;
      }
      return this._hasStrings && /^\s*$/.test(this._originalStringElements[index2]);
    }
    _OriginalRegionIsBoundary(originalStart, originalLength) {
      if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
        return true;
      }
      if (originalLength > 0) {
        const originalEnd = originalStart + originalLength;
        if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
          return true;
        }
      }
      return false;
    }
    _ModifiedIsBoundary(index2) {
      if (index2 <= 0 || index2 >= this._modifiedElementsOrHash.length - 1) {
        return true;
      }
      return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index2]);
    }
    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
      if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
        return true;
      }
      if (modifiedLength > 0) {
        const modifiedEnd = modifiedStart + modifiedLength;
        if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
          return true;
        }
      }
      return false;
    }
    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
      const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
      const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
      return originalScore + modifiedScore;
    }
    /**
     * Concatenates the two input DiffChange lists and returns the resulting
     * list.
     * @param The left changes
     * @param The right changes
     * @returns The concatenated list
     */
    ConcatenateChanges(left, right) {
      const mergedChangeArr = [];
      if (left.length === 0 || right.length === 0) {
        return right.length > 0 ? right : left;
      } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
        const result = new Array(left.length + right.length - 1);
        MyArray.Copy(left, 0, result, 0, left.length - 1);
        result[left.length - 1] = mergedChangeArr[0];
        MyArray.Copy(right, 1, result, left.length, right.length - 1);
        return result;
      } else {
        const result = new Array(left.length + right.length);
        MyArray.Copy(left, 0, result, 0, left.length);
        MyArray.Copy(right, 0, result, left.length, right.length);
        return result;
      }
    }
    /**
     * Returns true if the two changes overlap and can be merged into a single
     * change
     * @param left The left change
     * @param right The right change
     * @param mergedChange The merged change if the two overlap, null otherwise
     * @returns True if the two changes overlap
     */
    ChangesOverlap(left, right, mergedChangeArr) {
      Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
      Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
      if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
        const originalStart = left.originalStart;
        let originalLength = left.originalLength;
        const modifiedStart = left.modifiedStart;
        let modifiedLength = left.modifiedLength;
        if (left.originalStart + left.originalLength >= right.originalStart) {
          originalLength = right.originalStart + right.originalLength - left.originalStart;
        }
        if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
          modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
        }
        mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
        return true;
      } else {
        mergedChangeArr[0] = null;
        return false;
      }
    }
    /**
     * Helper method used to clip a diagonal index to the range of valid
     * diagonals. This also decides whether or not the diagonal index,
     * if it exceeds the boundary, should be clipped to the boundary or clipped
     * one inside the boundary depending on the Even/Odd status of the boundary
     * and numDifferences.
     * @param diagonal The index of the diagonal to clip.
     * @param numDifferences The current number of differences being iterated upon.
     * @param diagonalBaseIndex The base reference diagonal.
     * @param numDiagonals The total number of diagonals.
     * @returns The clipped diagonal index.
     */
    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
      if (diagonal >= 0 && diagonal < numDiagonals) {
        return diagonal;
      }
      const diagonalsBelow = diagonalBaseIndex;
      const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
      const diffEven = numDifferences % 2 === 0;
      if (diagonal < 0) {
        const lowerBoundEven = diagonalsBelow % 2 === 0;
        return diffEven === lowerBoundEven ? 0 : 1;
      } else {
        const upperBoundEven = diagonalsAbove % 2 === 0;
        return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/process.js
  var safeProcess;
  var vscodeGlobal = globalThis.vscode;
  if (typeof vscodeGlobal !== "undefined" && typeof vscodeGlobal.process !== "undefined") {
    const sandboxProcess = vscodeGlobal.process;
    safeProcess = {
      get platform() {
        return sandboxProcess.platform;
      },
      get arch() {
        return sandboxProcess.arch;
      },
      get env() {
        return sandboxProcess.env;
      },
      cwd() {
        return sandboxProcess.cwd();
      }
    };
  } else if (typeof process !== "undefined") {
    safeProcess = {
      get platform() {
        return process.platform;
      },
      get arch() {
        return process.arch;
      },
      get env() {
        return process.env;
      },
      cwd() {
        return process.env["VSCODE_CWD"] || process.cwd();
      }
    };
  } else {
    safeProcess = {
      // Supported
      get platform() {
        return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
      },
      get arch() {
        return void 0;
      },
      // Unsupported
      get env() {
        return {};
      },
      cwd() {
        return "/";
      }
    };
  }
  var cwd = safeProcess.cwd;
  var env = safeProcess.env;
  var platform = safeProcess.platform;

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/path.js
  var CHAR_UPPERCASE_A = 65;
  var CHAR_LOWERCASE_A = 97;
  var CHAR_UPPERCASE_Z = 90;
  var CHAR_LOWERCASE_Z = 122;
  var CHAR_DOT = 46;
  var CHAR_FORWARD_SLASH = 47;
  var CHAR_BACKWARD_SLASH = 92;
  var CHAR_COLON = 58;
  var CHAR_QUESTION_MARK = 63;
  var ErrorInvalidArgType = class extends Error {
    constructor(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && expected.indexOf("not ") === 0) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      const type = name.indexOf(".") !== -1 ? "property" : "argument";
      let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
      msg += `. Received type ${typeof actual}`;
      super(msg);
      this.code = "ERR_INVALID_ARG_TYPE";
    }
  };
  function validateObject(pathObject, name) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new ErrorInvalidArgType(name, "Object", pathObject);
    }
  }
  function validateString(value2, name) {
    if (typeof value2 !== "string") {
      throw new ErrorInvalidArgType(name, "string", value2);
    }
  }
  var platformIsWin32 = platform === "win32";
  function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  }
  function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
  }
  function isWindowsDeviceRoot(code) {
    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        code = path.charCodeAt(i);
      } else if (isPathSeparator2(code)) {
        break;
      } else {
        code = CHAR_FORWARD_SLASH;
      }
      if (isPathSeparator2(code)) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i;
              dots = 0;
              continue;
            } else if (res.length !== 0) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            res += res.length > 0 ? `${separator}..` : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `${separator}${path.slice(lastSlash + 1, i)}`;
          } else {
            res = path.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format2(sep2, pathObject) {
    validateObject(pathObject, "pathObject");
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
    if (!dir) {
      return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
  }
  var win32 = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
      let resolvedDevice = "";
      let resolvedTail = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1; i--) {
        let path;
        if (i >= 0) {
          path = pathSegments[i];
          validateString(path, "path");
          if (path.length === 0) {
            continue;
          }
        } else if (resolvedDevice.length === 0) {
          path = cwd();
        } else {
          path = env[`=${resolvedDevice}`] || cwd();
          if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            path = `${resolvedDevice}\\`;
          }
        }
        const len = path.length;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len === 1) {
          if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
          }
        } else if (isPathSeparator(code)) {
          isAbsolute = true;
          if (isPathSeparator(path.charCodeAt(1))) {
            let j = 2;
            let last = j;
            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              const firstPart = path.slice(last, j);
              last = j;
              while (j < len && isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j === len || j !== last) {
                  device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                  rootEnd = j;
                }
              }
            }
          } else {
            rootEnd = 1;
          }
        } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
            isAbsolute = true;
            rootEnd = 3;
          }
        }
        if (device.length > 0) {
          if (resolvedDevice.length > 0) {
            if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
              continue;
            }
          } else {
            resolvedDevice = device;
          }
        }
        if (resolvedAbsolute) {
          if (resolvedDevice.length > 0) {
            break;
          }
        } else {
          resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
          resolvedAbsolute = isAbsolute;
          if (isAbsolute && resolvedDevice.length > 0) {
            break;
          }
        }
      }
      resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
      return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
    },
    normalize(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = 0;
      let device;
      let isAbsolute = false;
      const code = path.charCodeAt(0);
      if (len === 1) {
        return isPosixPathSeparator(code) ? "\\" : path;
      }
      if (isPathSeparator(code)) {
        isAbsolute = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len) {
                return `\\\\${firstPart}\\${path.slice(last)}\\`;
              }
              if (j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
          isAbsolute = true;
          rootEnd = 3;
        }
      }
      let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator) : "";
      if (tail.length === 0 && !isAbsolute) {
        tail = ".";
      }
      if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
      }
      if (device === void 0) {
        return isAbsolute ? `\\${tail}` : tail;
      }
      return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
    },
    isAbsolute(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return false;
      }
      const code = path.charCodeAt(0);
      return isPathSeparator(code) || // Possible device root
      len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
    },
    join(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      let firstPart;
      for (let i = 0; i < paths.length; ++i) {
        const arg = paths[i];
        validateString(arg, "path");
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = firstPart = arg;
          } else {
            joined += `\\${arg}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      let needsReplace = true;
      let slashCount = 0;
      if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
          ++slashCount;
          if (firstLen > 2) {
            if (isPathSeparator(firstPart.charCodeAt(2))) {
              ++slashCount;
            } else {
              needsReplace = false;
            }
          }
        }
      }
      if (needsReplace) {
        while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
          slashCount++;
        }
        if (slashCount >= 2) {
          joined = `\\${joined.slice(slashCount)}`;
        }
      }
      return win32.normalize(joined);
    },
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    relative(from, to) {
      validateString(from, "from");
      validateString(to, "to");
      if (from === to) {
        return "";
      }
      const fromOrig = win32.resolve(from);
      const toOrig = win32.resolve(to);
      if (fromOrig === toOrig) {
        return "";
      }
      from = fromOrig.toLowerCase();
      to = toOrig.toLowerCase();
      if (from === to) {
        return "";
      }
      let fromStart = 0;
      while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
        fromStart++;
      }
      let fromEnd = from.length;
      while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
        fromEnd--;
      }
      const fromLen = fromEnd - fromStart;
      let toStart = 0;
      while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
        toStart++;
      }
      let toEnd = to.length;
      while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
        toEnd--;
      }
      const toLen = toEnd - toStart;
      const length2 = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i < length2; i++) {
        const fromCode = from.charCodeAt(fromStart + i);
        if (fromCode !== to.charCodeAt(toStart + i)) {
          break;
        } else if (fromCode === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        }
      }
      if (i !== length2) {
        if (lastCommonSep === -1) {
          return toOrig;
        }
      } else {
        if (toLen > length2) {
          if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
            return toOrig.slice(toStart + i + 1);
          }
          if (i === 2) {
            return toOrig.slice(toStart + i);
          }
        }
        if (fromLen > length2) {
          if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
            lastCommonSep = i;
          } else if (i === 2) {
            lastCommonSep = 3;
          }
        }
        if (lastCommonSep === -1) {
          lastCommonSep = 0;
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
          out += out.length === 0 ? ".." : "\\..";
        }
      }
      toStart += lastCommonSep;
      if (out.length > 0) {
        return `${out}${toOrig.slice(toStart, toEnd)}`;
      }
      if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
        ++toStart;
      }
      return toOrig.slice(toStart, toEnd);
    },
    toNamespacedPath(path) {
      if (typeof path !== "string" || path.length === 0) {
        return path;
      }
      const resolvedPath = win32.resolve(path);
      if (resolvedPath.length <= 2) {
        return path;
      }
      if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
        if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
          const code = resolvedPath.charCodeAt(2);
          if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
            return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
          }
        }
      } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
        return `\\\\?\\${resolvedPath}`;
      }
      return path;
    },
    dirname(path) {
      validateString(path, "path");
      const len = path.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = -1;
      let offset = 0;
      const code = path.charCodeAt(0);
      if (len === 1) {
        return isPathSeparator(code) ? path : ".";
      }
      if (isPathSeparator(code)) {
        rootEnd = offset = 1;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len) {
                return path;
              }
              if (j !== last) {
                rootEnd = offset = j + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
        offset = rootEnd;
      }
      let end = -1;
      let matchedSlash = true;
      for (let i = len - 1; i >= offset; --i) {
        if (isPathSeparator(path.charCodeAt(i))) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        if (rootEnd === -1) {
          return ".";
        }
        end = rootEnd;
      }
      return path.slice(0, end);
    },
    basename(path, ext) {
      if (ext !== void 0) {
        validateString(ext, "ext");
      }
      validateString(path, "path");
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
        start = 2;
      }
      if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
        if (ext === path) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path.length - 1; i >= start; --i) {
          const code = path.charCodeAt(i);
          if (isPathSeparator(code)) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path.length;
        }
        return path.slice(start, end);
      }
      for (i = path.length - 1; i >= start; --i) {
        if (isPathSeparator(path.charCodeAt(i))) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1) {
        return "";
      }
      return path.slice(start, end);
    },
    extname(path) {
      validateString(path, "path");
      let start = 0;
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
      }
      for (let i = path.length - 1; i >= start; --i) {
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end);
    },
    format: _format2.bind(null, "\\"),
    parse(path) {
      validateString(path, "path");
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path.length === 0) {
        return ret;
      }
      const len = path.length;
      let rootEnd = 0;
      let code = path.charCodeAt(0);
      if (len === 1) {
        if (isPathSeparator(code)) {
          ret.root = ret.dir = path;
          return ret;
        }
        ret.base = ret.name = path;
        return ret;
      }
      if (isPathSeparator(code)) {
        rootEnd = 1;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len) {
                rootEnd = j;
              } else if (j !== last) {
                rootEnd = j + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        if (len <= 2) {
          ret.root = ret.dir = path;
          return ret;
        }
        rootEnd = 2;
        if (isPathSeparator(path.charCodeAt(2))) {
          if (len === 3) {
            ret.root = ret.dir = path;
            return ret;
          }
          rootEnd = 3;
        }
      }
      if (rootEnd > 0) {
        ret.root = path.slice(0, rootEnd);
      }
      let startDot = -1;
      let startPart = rootEnd;
      let end = -1;
      let matchedSlash = true;
      let i = path.length - 1;
      let preDotState = 0;
      for (; i >= rootEnd; --i) {
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (end !== -1) {
        if (startDot === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          ret.base = ret.name = path.slice(startPart, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
          ret.ext = path.slice(startDot, end);
        }
      }
      if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
      } else {
        ret.dir = ret.root;
      }
      return ret;
    },
    sep: "\\",
    delimiter: ";",
    win32: null,
    posix: null
  };
  var posixCwd = (() => {
    if (platformIsWin32) {
      const regexp = /\\/g;
      return () => {
        const cwd2 = cwd().replace(regexp, "/");
        return cwd2.slice(cwd2.indexOf("/"));
      };
    }
    return () => cwd();
  })();
  var posix = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        const path = i >= 0 ? pathSegments[i] : posixCwd();
        validateString(path, "path");
        if (path.length === 0) {
          continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      }
      resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
      if (resolvedAbsolute) {
        return `/${resolvedPath}`;
      }
      return resolvedPath.length > 0 ? resolvedPath : ".";
    },
    normalize(path) {
      validateString(path, "path");
      if (path.length === 0) {
        return ".";
      }
      const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
      path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
      if (path.length === 0) {
        if (isAbsolute) {
          return "/";
        }
        return trailingSeparator ? "./" : ".";
      }
      if (trailingSeparator) {
        path += "/";
      }
      return isAbsolute ? `/${path}` : path;
    },
    isAbsolute(path) {
      validateString(path, "path");
      return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    },
    join(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      for (let i = 0; i < paths.length; ++i) {
        const arg = paths[i];
        validateString(arg, "path");
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = arg;
          } else {
            joined += `/${arg}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return posix.normalize(joined);
    },
    relative(from, to) {
      validateString(from, "from");
      validateString(to, "to");
      if (from === to) {
        return "";
      }
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) {
        return "";
      }
      const fromStart = 1;
      const fromEnd = from.length;
      const fromLen = fromEnd - fromStart;
      const toStart = 1;
      const toLen = to.length - toStart;
      const length2 = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i < length2; i++) {
        const fromCode = from.charCodeAt(fromStart + i);
        if (fromCode !== to.charCodeAt(toStart + i)) {
          break;
        } else if (fromCode === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        }
      }
      if (i === length2) {
        if (toLen > length2) {
          if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
            return to.slice(toStart + i + 1);
          }
          if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length2) {
          if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          out += out.length === 0 ? ".." : "/..";
        }
      }
      return `${out}${to.slice(toStart + lastCommonSep)}`;
    },
    toNamespacedPath(path) {
      return path;
    },
    dirname(path) {
      validateString(path, "path");
      if (path.length === 0) {
        return ".";
      }
      const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let end = -1;
      let matchedSlash = true;
      for (let i = path.length - 1; i >= 1; --i) {
        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        return hasRoot ? "/" : ".";
      }
      if (hasRoot && end === 1) {
        return "//";
      }
      return path.slice(0, end);
    },
    basename(path, ext) {
      if (ext !== void 0) {
        validateString(ext, "ext");
      }
      validateString(path, "path");
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
        if (ext === path) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path.length - 1; i >= 0; --i) {
          const code = path.charCodeAt(i);
          if (code === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path.length;
        }
        return path.slice(start, end);
      }
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1) {
        return "";
      }
      return path.slice(start, end);
    },
    extname(path) {
      validateString(path, "path");
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end);
    },
    format: _format2.bind(null, "/"),
    parse(path) {
      validateString(path, "path");
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path.length === 0) {
        return ret;
      }
      const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let start;
      if (isAbsolute) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let i = path.length - 1;
      let preDotState = 0;
      for (; i >= start; --i) {
        const code = path.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (end !== -1) {
        const start2 = startPart === 0 && isAbsolute ? 1 : startPart;
        if (startDot === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          ret.base = ret.name = path.slice(start2, end);
        } else {
          ret.name = path.slice(start2, startDot);
          ret.base = path.slice(start2, end);
          ret.ext = path.slice(startDot, end);
        }
      }
      if (startPart > 0) {
        ret.dir = path.slice(0, startPart - 1);
      } else if (isAbsolute) {
        ret.dir = "/";
      }
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.win32 = win32.win32 = win32;
  posix.posix = win32.posix = posix;
  var normalize = platformIsWin32 ? win32.normalize : posix.normalize;
  var resolve = platformIsWin32 ? win32.resolve : posix.resolve;
  var relative = platformIsWin32 ? win32.relative : posix.relative;
  var dirname = platformIsWin32 ? win32.dirname : posix.dirname;
  var basename = platformIsWin32 ? win32.basename : posix.basename;
  var extname = platformIsWin32 ? win32.extname : posix.extname;
  var sep = platformIsWin32 ? win32.sep : posix.sep;

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/uri.js
  var _schemePattern = /^\w[\w\d+.-]*$/;
  var _singleSlashStart = /^\//;
  var _doubleSlashStart = /^\/\//;
  function _validateUri(ret, _strict) {
    if (!ret.scheme && _strict) {
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
      throw new Error("[UriError]: Scheme contains illegal characters.");
    }
    if (ret.path) {
      if (ret.authority) {
        if (!_singleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        }
      } else {
        if (_doubleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
    }
  }
  function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
      return "file";
    }
    return scheme;
  }
  function _referenceResolution(scheme, path) {
    switch (scheme) {
      case "https":
      case "http":
      case "file":
        if (!path) {
          path = _slash;
        } else if (path[0] !== _slash) {
          path = _slash + path;
        }
        break;
    }
    return path;
  }
  var _empty = "";
  var _slash = "/";
  var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  var URI = class _URI {
    static isUri(thing) {
      if (thing instanceof _URI) {
        return true;
      }
      if (!thing) {
        return false;
      }
      return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
    }
    /**
     * @internal
     */
    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
      if (typeof schemeOrData === "object") {
        this.scheme = schemeOrData.scheme || _empty;
        this.authority = schemeOrData.authority || _empty;
        this.path = schemeOrData.path || _empty;
        this.query = schemeOrData.query || _empty;
        this.fragment = schemeOrData.fragment || _empty;
      } else {
        this.scheme = _schemeFix(schemeOrData, _strict);
        this.authority = authority || _empty;
        this.path = _referenceResolution(this.scheme, path || _empty);
        this.query = query || _empty;
        this.fragment = fragment || _empty;
        _validateUri(this, _strict);
      }
    }
    // ---- filesystem path -----------------------
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath() {
      return uriToFsPath(this, false);
    }
    // ---- modify to new -------------------------
    with(change) {
      if (!change) {
        return this;
      }
      let { scheme, authority, path, query, fragment } = change;
      if (scheme === void 0) {
        scheme = this.scheme;
      } else if (scheme === null) {
        scheme = _empty;
      }
      if (authority === void 0) {
        authority = this.authority;
      } else if (authority === null) {
        authority = _empty;
      }
      if (path === void 0) {
        path = this.path;
      } else if (path === null) {
        path = _empty;
      }
      if (query === void 0) {
        query = this.query;
      } else if (query === null) {
        query = _empty;
      }
      if (fragment === void 0) {
        fragment = this.fragment;
      } else if (fragment === null) {
        fragment = _empty;
      }
      if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
        return this;
      }
      return new Uri(scheme, authority, path, query, fragment);
    }
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value2, _strict = false) {
      const match = _regexp.exec(value2);
      if (!match) {
        return new Uri(_empty, _empty, _empty, _empty, _empty);
      }
      return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
    }
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path) {
      let authority = _empty;
      if (isWindows) {
        path = path.replace(/\\/g, _slash);
      }
      if (path[0] === _slash && path[1] === _slash) {
        const idx = path.indexOf(_slash, 2);
        if (idx === -1) {
          authority = path.substring(2);
          path = _slash;
        } else {
          authority = path.substring(2, idx);
          path = path.substring(idx) || _slash;
        }
      }
      return new Uri("file", authority, path, _empty, _empty);
    }
    /**
     * Creates new URI from uri components.
     *
     * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
     * validation and should be used for untrusted uri components retrieved from storage,
     * user input, command arguments etc
     */
    static from(components, strict) {
      const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
      return result;
    }
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri, ...pathFragment) {
      if (!uri.path) {
        throw new Error(`[UriError]: cannot call joinPath on URI without path`);
      }
      let newPath;
      if (isWindows && uri.scheme === "file") {
        newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
      } else {
        newPath = posix.join(uri.path, ...pathFragment);
      }
      return uri.with({ path: newPath });
    }
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding = false) {
      return _asFormatted(this, skipEncoding);
    }
    toJSON() {
      return this;
    }
    static revive(data) {
      var _a4, _b3;
      if (!data) {
        return data;
      } else if (data instanceof _URI) {
        return data;
      } else {
        const result = new Uri(data);
        result._formatted = (_a4 = data.external) !== null && _a4 !== void 0 ? _a4 : null;
        result._fsPath = data._sep === _pathSepMarker ? (_b3 = data.fsPath) !== null && _b3 !== void 0 ? _b3 : null : null;
        return result;
      }
    }
  };
  var _pathSepMarker = isWindows ? 1 : void 0;
  var Uri = class extends URI {
    constructor() {
      super(...arguments);
      this._formatted = null;
      this._fsPath = null;
    }
    get fsPath() {
      if (!this._fsPath) {
        this._fsPath = uriToFsPath(this, false);
      }
      return this._fsPath;
    }
    toString(skipEncoding = false) {
      if (!skipEncoding) {
        if (!this._formatted) {
          this._formatted = _asFormatted(this, false);
        }
        return this._formatted;
      } else {
        return _asFormatted(this, true);
      }
    }
    toJSON() {
      const res = {
        $mid: 1
        /* MarshalledId.Uri */
      };
      if (this._fsPath) {
        res.fsPath = this._fsPath;
        res._sep = _pathSepMarker;
      }
      if (this._formatted) {
        res.external = this._formatted;
      }
      if (this.path) {
        res.path = this.path;
      }
      if (this.scheme) {
        res.scheme = this.scheme;
      }
      if (this.authority) {
        res.authority = this.authority;
      }
      if (this.query) {
        res.query = this.query;
      }
      if (this.fragment) {
        res.fragment = this.fragment;
      }
      return res;
    }
  };
  var encodeTable = {
    [
      58
      /* CharCode.Colon */
    ]: "%3A",
    // gen-delims
    [
      47
      /* CharCode.Slash */
    ]: "%2F",
    [
      63
      /* CharCode.QuestionMark */
    ]: "%3F",
    [
      35
      /* CharCode.Hash */
    ]: "%23",
    [
      91
      /* CharCode.OpenSquareBracket */
    ]: "%5B",
    [
      93
      /* CharCode.CloseSquareBracket */
    ]: "%5D",
    [
      64
      /* CharCode.AtSign */
    ]: "%40",
    [
      33
      /* CharCode.ExclamationMark */
    ]: "%21",
    // sub-delims
    [
      36
      /* CharCode.DollarSign */
    ]: "%24",
    [
      38
      /* CharCode.Ampersand */
    ]: "%26",
    [
      39
      /* CharCode.SingleQuote */
    ]: "%27",
    [
      40
      /* CharCode.OpenParen */
    ]: "%28",
    [
      41
      /* CharCode.CloseParen */
    ]: "%29",
    [
      42
      /* CharCode.Asterisk */
    ]: "%2A",
    [
      43
      /* CharCode.Plus */
    ]: "%2B",
    [
      44
      /* CharCode.Comma */
    ]: "%2C",
    [
      59
      /* CharCode.Semicolon */
    ]: "%3B",
    [
      61
      /* CharCode.Equals */
    ]: "%3D",
    [
      32
      /* CharCode.Space */
    ]: "%20"
  };
  function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
    let res = void 0;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
      const code = uriComponent.charCodeAt(pos);
      if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        if (res !== void 0) {
          res += uriComponent.charAt(pos);
        }
      } else {
        if (res === void 0) {
          res = uriComponent.substr(0, pos);
        }
        const escaped = encodeTable[code];
        if (escaped !== void 0) {
          if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
            nativeEncodePos = -1;
          }
          res += escaped;
        } else if (nativeEncodePos === -1) {
          nativeEncodePos = pos;
        }
      }
    }
    if (nativeEncodePos !== -1) {
      res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== void 0 ? res : uriComponent;
  }
  function encodeURIComponentMinimal(path) {
    let res = void 0;
    for (let pos = 0; pos < path.length; pos++) {
      const code = path.charCodeAt(pos);
      if (code === 35 || code === 63) {
        if (res === void 0) {
          res = path.substr(0, pos);
        }
        res += encodeTable[code];
      } else {
        if (res !== void 0) {
          res += path[pos];
        }
      }
    }
    return res !== void 0 ? res : path;
  }
  function uriToFsPath(uri, keepDriveLetterCasing) {
    let value2;
    if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
      value2 = `//${uri.authority}${uri.path}`;
    } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
      if (!keepDriveLetterCasing) {
        value2 = uri.path[1].toLowerCase() + uri.path.substr(2);
      } else {
        value2 = uri.path.substr(1);
      }
    } else {
      value2 = uri.path;
    }
    if (isWindows) {
      value2 = value2.replace(/\//g, "\\");
    }
    return value2;
  }
  function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
    let res = "";
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
      res += scheme;
      res += ":";
    }
    if (authority || scheme === "file") {
      res += _slash;
      res += _slash;
    }
    if (authority) {
      let idx = authority.indexOf("@");
      if (idx !== -1) {
        const userinfo = authority.substr(0, idx);
        authority = authority.substr(idx + 1);
        idx = userinfo.lastIndexOf(":");
        if (idx === -1) {
          res += encoder(userinfo, false, false);
        } else {
          res += encoder(userinfo.substr(0, idx), false, false);
          res += ":";
          res += encoder(userinfo.substr(idx + 1), false, true);
        }
        res += "@";
      }
      authority = authority.toLowerCase();
      idx = authority.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(authority, false, true);
      } else {
        res += encoder(authority.substr(0, idx), false, true);
        res += authority.substr(idx);
      }
    }
    if (path) {
      if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
        const code = path.charCodeAt(1);
        if (code >= 65 && code <= 90) {
          path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
        }
      } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
        const code = path.charCodeAt(0);
        if (code >= 65 && code <= 90) {
          path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
        }
      }
      res += encoder(path, true, false);
    }
    if (query) {
      res += "?";
      res += encoder(query, false, false);
    }
    if (fragment) {
      res += "#";
      res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
    }
    return res;
  }
  function decodeURIComponentGraceful(str) {
    try {
      return decodeURIComponent(str);
    } catch (_a4) {
      if (str.length > 3) {
        return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
      } else {
        return str;
      }
    }
  }
  var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
      return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js
  var Position = class _Position {
    constructor(lineNumber, column) {
      this.lineNumber = lineNumber;
      this.column = column;
    }
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber = this.lineNumber, newColumn = this.column) {
      if (newLineNumber === this.lineNumber && newColumn === this.column) {
        return this;
      } else {
        return new _Position(newLineNumber, newColumn);
      }
    }
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber = 0, deltaColumn = 0) {
      return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
    }
    /**
     * Test if this position equals other position
     */
    equals(other) {
      return _Position.equals(this, other);
    }
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a, b) {
      if (!a && !b) {
        return true;
      }
      return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other) {
      return _Position.isBefore(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a, b) {
      if (a.lineNumber < b.lineNumber) {
        return true;
      }
      if (b.lineNumber < a.lineNumber) {
        return false;
      }
      return a.column < b.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other) {
      return _Position.isBeforeOrEqual(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a, b) {
      if (a.lineNumber < b.lineNumber) {
        return true;
      }
      if (b.lineNumber < a.lineNumber) {
        return false;
      }
      return a.column <= b.column;
    }
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a, b) {
      const aLineNumber = a.lineNumber | 0;
      const bLineNumber = b.lineNumber | 0;
      if (aLineNumber === bLineNumber) {
        const aColumn = a.column | 0;
        const bColumn = b.column | 0;
        return aColumn - bColumn;
      }
      return aLineNumber - bLineNumber;
    }
    /**
     * Clone this position.
     */
    clone() {
      return new _Position(this.lineNumber, this.column);
    }
    /**
     * Convert to a human-readable representation.
     */
    toString() {
      return "(" + this.lineNumber + "," + this.column + ")";
    }
    // ---
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos) {
      return new _Position(pos.lineNumber, pos.column);
    }
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj) {
      return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
    }
    toJSON() {
      return {
        lineNumber: this.lineNumber,
        column: this.column
      };
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js
  var Range = class _Range {
    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
      if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
        this.startLineNumber = endLineNumber;
        this.startColumn = endColumn;
        this.endLineNumber = startLineNumber;
        this.endColumn = startColumn;
      } else {
        this.startLineNumber = startLineNumber;
        this.startColumn = startColumn;
        this.endLineNumber = endLineNumber;
        this.endColumn = endColumn;
      }
    }
    /**
     * Test if this range is empty.
     */
    isEmpty() {
      return _Range.isEmpty(this);
    }
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range) {
      return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
    }
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position2) {
      return _Range.containsPosition(this, position2);
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range, position2) {
      if (position2.lineNumber < range.startLineNumber || position2.lineNumber > range.endLineNumber) {
        return false;
      }
      if (position2.lineNumber === range.startLineNumber && position2.column < range.startColumn) {
        return false;
      }
      if (position2.lineNumber === range.endLineNumber && position2.column > range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return false.
     * @internal
     */
    static strictContainsPosition(range, position2) {
      if (position2.lineNumber < range.startLineNumber || position2.lineNumber > range.endLineNumber) {
        return false;
      }
      if (position2.lineNumber === range.startLineNumber && position2.column <= range.startColumn) {
        return false;
      }
      if (position2.lineNumber === range.endLineNumber && position2.column >= range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range) {
      return _Range.containsRange(this, range);
    }
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range, otherRange) {
      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
        return false;
      }
      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range) {
      return _Range.strictContainsRange(this, range);
    }
    /**
     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range, otherRange) {
      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
        return false;
      }
      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range) {
      return _Range.plusRange(this, range);
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a, b) {
      let startLineNumber;
      let startColumn;
      let endLineNumber;
      let endColumn;
      if (b.startLineNumber < a.startLineNumber) {
        startLineNumber = b.startLineNumber;
        startColumn = b.startColumn;
      } else if (b.startLineNumber === a.startLineNumber) {
        startLineNumber = b.startLineNumber;
        startColumn = Math.min(b.startColumn, a.startColumn);
      } else {
        startLineNumber = a.startLineNumber;
        startColumn = a.startColumn;
      }
      if (b.endLineNumber > a.endLineNumber) {
        endLineNumber = b.endLineNumber;
        endColumn = b.endColumn;
      } else if (b.endLineNumber === a.endLineNumber) {
        endLineNumber = b.endLineNumber;
        endColumn = Math.max(b.endColumn, a.endColumn);
      } else {
        endLineNumber = a.endLineNumber;
        endColumn = a.endColumn;
      }
      return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range) {
      return _Range.intersectRanges(this, range);
    }
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a, b) {
      let resultStartLineNumber = a.startLineNumber;
      let resultStartColumn = a.startColumn;
      let resultEndLineNumber = a.endLineNumber;
      let resultEndColumn = a.endColumn;
      const otherStartLineNumber = b.startLineNumber;
      const otherStartColumn = b.startColumn;
      const otherEndLineNumber = b.endLineNumber;
      const otherEndColumn = b.endColumn;
      if (resultStartLineNumber < otherStartLineNumber) {
        resultStartLineNumber = otherStartLineNumber;
        resultStartColumn = otherStartColumn;
      } else if (resultStartLineNumber === otherStartLineNumber) {
        resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
      }
      if (resultEndLineNumber > otherEndLineNumber) {
        resultEndLineNumber = otherEndLineNumber;
        resultEndColumn = otherEndColumn;
      } else if (resultEndLineNumber === otherEndLineNumber) {
        resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
      }
      if (resultStartLineNumber > resultEndLineNumber) {
        return null;
      }
      if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
        return null;
      }
      return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
    }
    /**
     * Test if this range equals other.
     */
    equalsRange(other) {
      return _Range.equalsRange(this, other);
    }
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a, b) {
      if (!a && !b) {
        return true;
      }
      return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition() {
      return _Range.getEndPosition(this);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range) {
      return new Position(range.endLineNumber, range.endColumn);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition() {
      return _Range.getStartPosition(this);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range) {
      return new Position(range.startLineNumber, range.startColumn);
    }
    /**
     * Transform to a user presentable string representation.
     */
    toString() {
      return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
    }
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber, endColumn) {
      return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber, startColumn) {
      return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart() {
      return _Range.collapseToStart(this);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range) {
      return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    collapseToEnd() {
      return _Range.collapseToEnd(this);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    static collapseToEnd(range) {
      return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Moves the range by the given amount of lines.
     */
    delta(lineCount) {
      return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
    }
    // ---
    static fromPositions(start, end = start) {
      return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    static lift(range) {
      if (!range) {
        return null;
      }
      return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj) {
      return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
    }
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a, b) {
      if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {
        return false;
      }
      if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a, b) {
      if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
        return false;
      }
      if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
        return false;
      }
      return true;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a, b) {
      if (a && b) {
        const aStartLineNumber = a.startLineNumber | 0;
        const bStartLineNumber = b.startLineNumber | 0;
        if (aStartLineNumber === bStartLineNumber) {
          const aStartColumn = a.startColumn | 0;
          const bStartColumn = b.startColumn | 0;
          if (aStartColumn === bStartColumn) {
            const aEndLineNumber = a.endLineNumber | 0;
            const bEndLineNumber = b.endLineNumber | 0;
            if (aEndLineNumber === bEndLineNumber) {
              const aEndColumn = a.endColumn | 0;
              const bEndColumn = b.endColumn | 0;
              return aEndColumn - bEndColumn;
            }
            return aEndLineNumber - bEndLineNumber;
          }
          return aStartColumn - bStartColumn;
        }
        return aStartLineNumber - bStartLineNumber;
      }
      const aExists = a ? 1 : 0;
      const bExists = b ? 1 : 0;
      return aExists - bExists;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a, b) {
      if (a.endLineNumber === b.endLineNumber) {
        if (a.endColumn === b.endColumn) {
          if (a.startLineNumber === b.startLineNumber) {
            return a.startColumn - b.startColumn;
          }
          return a.startLineNumber - b.startLineNumber;
        }
        return a.endColumn - b.endColumn;
      }
      return a.endLineNumber - b.endLineNumber;
    }
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range) {
      return range.endLineNumber > range.startLineNumber;
    }
    toJSON() {
      return this;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js
  function equals(one, other, itemEquals = (a, b) => a === b) {
    if (one === other) {
      return true;
    }
    if (!one || !other) {
      return false;
    }
    if (one.length !== other.length) {
      return false;
    }
    for (let i = 0, len = one.length; i < len; i++) {
      if (!itemEquals(one[i], other[i])) {
        return false;
      }
    }
    return true;
  }
  function* groupAdjacentBy(items, shouldBeGrouped) {
    let currentGroup;
    let last;
    for (const item of items) {
      if (last !== void 0 && shouldBeGrouped(last, item)) {
        currentGroup.push(item);
      } else {
        if (currentGroup) {
          yield currentGroup;
        }
        currentGroup = [item];
      }
      last = item;
    }
    if (currentGroup) {
      yield currentGroup;
    }
  }
  function forEachAdjacent(arr, f2) {
    for (let i = 0; i <= arr.length; i++) {
      f2(i === 0 ? void 0 : arr[i - 1], i === arr.length ? void 0 : arr[i]);
    }
  }
  function forEachWithNeighbors(arr, f2) {
    for (let i = 0; i < arr.length; i++) {
      f2(i === 0 ? void 0 : arr[i - 1], arr[i], i + 1 === arr.length ? void 0 : arr[i + 1]);
    }
  }
  function pushMany(arr, items) {
    for (const item of items) {
      arr.push(item);
    }
  }
  var CompareResult;
  (function(CompareResult2) {
    function isLessThan(result) {
      return result < 0;
    }
    CompareResult2.isLessThan = isLessThan;
    function isLessThanOrEqual(result) {
      return result <= 0;
    }
    CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
    function isGreaterThan(result) {
      return result > 0;
    }
    CompareResult2.isGreaterThan = isGreaterThan;
    function isNeitherLessOrGreaterThan(result) {
      return result === 0;
    }
    CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
    CompareResult2.greaterThan = 1;
    CompareResult2.lessThan = -1;
    CompareResult2.neitherLessOrGreaterThan = 0;
  })(CompareResult || (CompareResult = {}));
  function compareBy(selector, comparator) {
    return (a, b) => comparator(selector(a), selector(b));
  }
  var numberComparator = (a, b) => a - b;
  function reverseOrder(comparator) {
    return (a, b) => -comparator(a, b);
  }
  var CallbackIterable = class _CallbackIterable {
    constructor(iterate) {
      this.iterate = iterate;
    }
    toArray() {
      const result = [];
      this.iterate((item) => {
        result.push(item);
        return true;
      });
      return result;
    }
    filter(predicate) {
      return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
    }
    map(mapFn) {
      return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
    }
    findLast(predicate) {
      let result;
      this.iterate((item) => {
        if (predicate(item)) {
          result = item;
        }
        return true;
      });
      return result;
    }
    findLastMaxBy(comparator) {
      let result;
      let first = true;
      this.iterate((item) => {
        if (first || CompareResult.isGreaterThan(comparator(item, result))) {
          first = false;
          result = item;
        }
        return true;
      });
      return result;
    }
  };
  CallbackIterable.empty = new CallbackIterable((_callback) => {
  });

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/uint.js
  function toUint8(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 255) {
      return 255;
    }
    return v | 0;
  }
  function toUint32(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 4294967295) {
      return 4294967295;
    }
    return v | 0;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js
  var PrefixSumComputer = class {
    constructor(values) {
      this.values = values;
      this.prefixSum = new Uint32Array(values.length);
      this.prefixSumValidIndex = new Int32Array(1);
      this.prefixSumValidIndex[0] = -1;
    }
    insertValues(insertIndex, insertValues) {
      insertIndex = toUint32(insertIndex);
      const oldValues = this.values;
      const oldPrefixSum = this.prefixSum;
      const insertValuesLen = insertValues.length;
      if (insertValuesLen === 0) {
        return false;
      }
      this.values = new Uint32Array(oldValues.length + insertValuesLen);
      this.values.set(oldValues.subarray(0, insertIndex), 0);
      this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
      this.values.set(insertValues, insertIndex);
      if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = insertIndex - 1;
      }
      this.prefixSum = new Uint32Array(this.values.length);
      if (this.prefixSumValidIndex[0] >= 0) {
        this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
      }
      return true;
    }
    setValue(index2, value2) {
      index2 = toUint32(index2);
      value2 = toUint32(value2);
      if (this.values[index2] === value2) {
        return false;
      }
      this.values[index2] = value2;
      if (index2 - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = index2 - 1;
      }
      return true;
    }
    removeValues(startIndex, count) {
      startIndex = toUint32(startIndex);
      count = toUint32(count);
      const oldValues = this.values;
      const oldPrefixSum = this.prefixSum;
      if (startIndex >= oldValues.length) {
        return false;
      }
      const maxCount = oldValues.length - startIndex;
      if (count >= maxCount) {
        count = maxCount;
      }
      if (count === 0) {
        return false;
      }
      this.values = new Uint32Array(oldValues.length - count);
      this.values.set(oldValues.subarray(0, startIndex), 0);
      this.values.set(oldValues.subarray(startIndex + count), startIndex);
      this.prefixSum = new Uint32Array(this.values.length);
      if (startIndex - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = startIndex - 1;
      }
      if (this.prefixSumValidIndex[0] >= 0) {
        this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
      }
      return true;
    }
    getTotalSum() {
      if (this.values.length === 0) {
        return 0;
      }
      return this._getPrefixSum(this.values.length - 1);
    }
    /**
     * Returns the sum of the first `index + 1` many items.
     * @returns `SUM(0 <= j <= index, values[j])`.
     */
    getPrefixSum(index2) {
      if (index2 < 0) {
        return 0;
      }
      index2 = toUint32(index2);
      return this._getPrefixSum(index2);
    }
    _getPrefixSum(index2) {
      if (index2 <= this.prefixSumValidIndex[0]) {
        return this.prefixSum[index2];
      }
      let startIndex = this.prefixSumValidIndex[0] + 1;
      if (startIndex === 0) {
        this.prefixSum[0] = this.values[0];
        startIndex++;
      }
      if (index2 >= this.values.length) {
        index2 = this.values.length - 1;
      }
      for (let i = startIndex; i <= index2; i++) {
        this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
      }
      this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index2);
      return this.prefixSum[index2];
    }
    getIndexOf(sum) {
      sum = Math.floor(sum);
      this.getTotalSum();
      let low = 0;
      let high = this.values.length - 1;
      let mid = 0;
      let midStop = 0;
      let midStart = 0;
      while (low <= high) {
        mid = low + (high - low) / 2 | 0;
        midStop = this.prefixSum[mid];
        midStart = midStop - this.values[mid];
        if (sum < midStart) {
          high = mid - 1;
        } else if (sum >= midStop) {
          low = mid + 1;
        } else {
          break;
        }
      }
      return new PrefixSumIndexOfResult(mid, sum - midStart);
    }
  };
  var PrefixSumIndexOfResult = class {
    constructor(index2, remainder) {
      this.index = index2;
      this.remainder = remainder;
      this._prefixSumIndexOfResultBrand = void 0;
      this.index = index2;
      this.remainder = remainder;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
  var MirrorTextModel = class {
    constructor(uri, lines, eol, versionId) {
      this._uri = uri;
      this._lines = lines;
      this._eol = eol;
      this._versionId = versionId;
      this._lineStarts = null;
      this._cachedTextValue = null;
    }
    dispose() {
      this._lines.length = 0;
    }
    get version() {
      return this._versionId;
    }
    getText() {
      if (this._cachedTextValue === null) {
        this._cachedTextValue = this._lines.join(this._eol);
      }
      return this._cachedTextValue;
    }
    onEvents(e2) {
      if (e2.eol && e2.eol !== this._eol) {
        this._eol = e2.eol;
        this._lineStarts = null;
      }
      const changes = e2.changes;
      for (const change of changes) {
        this._acceptDeleteRange(change.range);
        this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
      }
      this._versionId = e2.versionId;
      this._cachedTextValue = null;
    }
    _ensureLineStarts() {
      if (!this._lineStarts) {
        const eolLength = this._eol.length;
        const linesLength = this._lines.length;
        const lineStartValues = new Uint32Array(linesLength);
        for (let i = 0; i < linesLength; i++) {
          lineStartValues[i] = this._lines[i].length + eolLength;
        }
        this._lineStarts = new PrefixSumComputer(lineStartValues);
      }
    }
    /**
     * All changes to a line's text go through this method
     */
    _setLineText(lineIndex, newValue) {
      this._lines[lineIndex] = newValue;
      if (this._lineStarts) {
        this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
      }
    }
    _acceptDeleteRange(range) {
      if (range.startLineNumber === range.endLineNumber) {
        if (range.startColumn === range.endColumn) {
          return;
        }
        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
        return;
      }
      this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
      this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
      if (this._lineStarts) {
        this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
      }
    }
    _acceptInsertText(position2, insertText) {
      if (insertText.length === 0) {
        return;
      }
      const insertLines = splitLines(insertText);
      if (insertLines.length === 1) {
        this._setLineText(position2.lineNumber - 1, this._lines[position2.lineNumber - 1].substring(0, position2.column - 1) + insertLines[0] + this._lines[position2.lineNumber - 1].substring(position2.column - 1));
        return;
      }
      insertLines[insertLines.length - 1] += this._lines[position2.lineNumber - 1].substring(position2.column - 1);
      this._setLineText(position2.lineNumber - 1, this._lines[position2.lineNumber - 1].substring(0, position2.column - 1) + insertLines[0]);
      const newLengths = new Uint32Array(insertLines.length - 1);
      for (let i = 1; i < insertLines.length; i++) {
        this._lines.splice(position2.lineNumber + i - 1, 0, insertLines[i]);
        newLengths[i - 1] = insertLines[i].length + this._eol.length;
      }
      if (this._lineStarts) {
        this._lineStarts.insertValues(position2.lineNumber, newLengths);
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
  var USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
  function createWordRegExp(allowInWords = "") {
    let source = "(-?\\d*\\.\\d\\w*)|([^";
    for (const sep2 of USUAL_WORD_SEPARATORS) {
      if (allowInWords.indexOf(sep2) >= 0) {
        continue;
      }
      source += "\\" + sep2;
    }
    source += "\\s]+)";
    return new RegExp(source, "g");
  }
  var DEFAULT_WORD_REGEXP = createWordRegExp();
  function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && wordDefinition instanceof RegExp) {
      if (!wordDefinition.global) {
        let flags = "g";
        if (wordDefinition.ignoreCase) {
          flags += "i";
        }
        if (wordDefinition.multiline) {
          flags += "m";
        }
        if (wordDefinition.unicode) {
          flags += "u";
        }
        result = new RegExp(wordDefinition.source, flags);
      } else {
        result = wordDefinition;
      }
    }
    result.lastIndex = 0;
    return result;
  }
  var _defaultConfig = new LinkedList();
  _defaultConfig.unshift({
    maxLen: 1e3,
    windowSize: 15,
    timeBudget: 150
  });
  function getWordAtText(column, wordDefinition, text2, textOffset, config) {
    wordDefinition = ensureValidWordDefinition(wordDefinition);
    if (!config) {
      config = Iterable.first(_defaultConfig);
    }
    if (text2.length > config.maxLen) {
      let start = column - config.maxLen / 2;
      if (start < 0) {
        start = 0;
      } else {
        textOffset += start;
      }
      text2 = text2.substring(start, column + config.maxLen / 2);
      return getWordAtText(column, wordDefinition, text2, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i = 1; ; i++) {
      if (Date.now() - t1 >= config.timeBudget) {
        break;
      }
      const regexIndex = pos - config.windowSize * i;
      wordDefinition.lastIndex = Math.max(0, regexIndex);
      const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text2, pos, prevRegexIndex);
      if (!thisMatch && match) {
        break;
      }
      match = thisMatch;
      if (regexIndex <= 0) {
        break;
      }
      prevRegexIndex = regexIndex;
    }
    if (match) {
      const result = {
        word: match[0],
        startColumn: textOffset + 1 + match.index,
        endColumn: textOffset + 1 + match.index + match[0].length
      };
      wordDefinition.lastIndex = 0;
      return result;
    }
    return null;
  }
  function _findRegexMatchEnclosingPosition(wordDefinition, text2, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text2)) {
      const matchIndex = match.index || 0;
      if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
        return match;
      } else if (stopPos > 0 && matchIndex > stopPos) {
        return null;
      }
    }
    return null;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
  var CharacterClassifier = class _CharacterClassifier {
    constructor(_defaultValue) {
      const defaultValue = toUint8(_defaultValue);
      this._defaultValue = defaultValue;
      this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);
      this._map = /* @__PURE__ */ new Map();
    }
    static _createAsciiMap(defaultValue) {
      const asciiMap = new Uint8Array(256);
      asciiMap.fill(defaultValue);
      return asciiMap;
    }
    set(charCode, _value) {
      const value2 = toUint8(_value);
      if (charCode >= 0 && charCode < 256) {
        this._asciiMap[charCode] = value2;
      } else {
        this._map.set(charCode, value2);
      }
    }
    get(charCode) {
      if (charCode >= 0 && charCode < 256) {
        return this._asciiMap[charCode];
      } else {
        return this._map.get(charCode) || this._defaultValue;
      }
    }
    clear() {
      this._asciiMap.fill(this._defaultValue);
      this._map.clear();
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js
  var Uint8Matrix = class {
    constructor(rows, cols, defaultValue) {
      const data = new Uint8Array(rows * cols);
      for (let i = 0, len = rows * cols; i < len; i++) {
        data[i] = defaultValue;
      }
      this._data = data;
      this.rows = rows;
      this.cols = cols;
    }
    get(row, col) {
      return this._data[row * this.cols + col];
    }
    set(row, col, value2) {
      this._data[row * this.cols + col] = value2;
    }
  };
  var StateMachine = class {
    constructor(edges) {
      let maxCharCode = 0;
      let maxState = 0;
      for (let i = 0, len = edges.length; i < len; i++) {
        const [from, chCode, to] = edges[i];
        if (chCode > maxCharCode) {
          maxCharCode = chCode;
        }
        if (from > maxState) {
          maxState = from;
        }
        if (to > maxState) {
          maxState = to;
        }
      }
      maxCharCode++;
      maxState++;
      const states2 = new Uint8Matrix(
        maxState,
        maxCharCode,
        0
        /* State.Invalid */
      );
      for (let i = 0, len = edges.length; i < len; i++) {
        const [from, chCode, to] = edges[i];
        states2.set(from, chCode, to);
      }
      this._states = states2;
      this._maxCharCode = maxCharCode;
    }
    nextState(currentState, chCode) {
      if (chCode < 0 || chCode >= this._maxCharCode) {
        return 0;
      }
      return this._states.get(currentState, chCode);
    }
  };
  var _stateMachine = null;
  function getStateMachine() {
    if (_stateMachine === null) {
      _stateMachine = new StateMachine([
        [
          1,
          104,
          2
          /* State.H */
        ],
        [
          1,
          72,
          2
          /* State.H */
        ],
        [
          1,
          102,
          6
          /* State.F */
        ],
        [
          1,
          70,
          6
          /* State.F */
        ],
        [
          2,
          116,
          3
          /* State.HT */
        ],
        [
          2,
          84,
          3
          /* State.HT */
        ],
        [
          3,
          116,
          4
          /* State.HTT */
        ],
        [
          3,
          84,
          4
          /* State.HTT */
        ],
        [
          4,
          112,
          5
          /* State.HTTP */
        ],
        [
          4,
          80,
          5
          /* State.HTTP */
        ],
        [
          5,
          115,
          9
          /* State.BeforeColon */
        ],
        [
          5,
          83,
          9
          /* State.BeforeColon */
        ],
        [
          5,
          58,
          10
          /* State.AfterColon */
        ],
        [
          6,
          105,
          7
          /* State.FI */
        ],
        [
          6,
          73,
          7
          /* State.FI */
        ],
        [
          7,
          108,
          8
          /* State.FIL */
        ],
        [
          7,
          76,
          8
          /* State.FIL */
        ],
        [
          8,
          101,
          9
          /* State.BeforeColon */
        ],
        [
          8,
          69,
          9
          /* State.BeforeColon */
        ],
        [
          9,
          58,
          10
          /* State.AfterColon */
        ],
        [
          10,
          47,
          11
          /* State.AlmostThere */
        ],
        [
          11,
          47,
          12
          /* State.End */
        ]
      ]);
    }
    return _stateMachine;
  }
  var _classifier = null;
  function getClassifier() {
    if (_classifier === null) {
      _classifier = new CharacterClassifier(
        0
        /* CharacterClass.None */
      );
      const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
      for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
        _classifier.set(
          FORCE_TERMINATION_CHARACTERS.charCodeAt(i),
          1
          /* CharacterClass.ForceTermination */
        );
      }
      const CANNOT_END_WITH_CHARACTERS = ".,;:";
      for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
        _classifier.set(
          CANNOT_END_WITH_CHARACTERS.charCodeAt(i),
          2
          /* CharacterClass.CannotEndIn */
        );
      }
    }
    return _classifier;
  }
  var LinkComputer = class _LinkComputer {
    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
      let lastIncludedCharIndex = linkEndIndex - 1;
      do {
        const chCode = line.charCodeAt(lastIncludedCharIndex);
        const chClass = classifier.get(chCode);
        if (chClass !== 2) {
          break;
        }
        lastIncludedCharIndex--;
      } while (lastIncludedCharIndex > linkBeginIndex);
      if (linkBeginIndex > 0) {
        const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
        const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
        if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
          lastIncludedCharIndex--;
        }
      }
      return {
        range: {
          startLineNumber: lineNumber,
          startColumn: linkBeginIndex + 1,
          endLineNumber: lineNumber,
          endColumn: lastIncludedCharIndex + 2
        },
        url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
      };
    }
    static computeLinks(model, stateMachine = getStateMachine()) {
      const classifier = getClassifier();
      const result = [];
      for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
        const line = model.getLineContent(i);
        const len = line.length;
        let j = 0;
        let linkBeginIndex = 0;
        let linkBeginChCode = 0;
        let state = 1;
        let hasOpenParens = false;
        let hasOpenSquareBracket = false;
        let inSquareBrackets = false;
        let hasOpenCurlyBracket = false;
        while (j < len) {
          let resetStateMachine = false;
          const chCode = line.charCodeAt(j);
          if (state === 13) {
            let chClass;
            switch (chCode) {
              case 40:
                hasOpenParens = true;
                chClass = 0;
                break;
              case 41:
                chClass = hasOpenParens ? 0 : 1;
                break;
              case 91:
                inSquareBrackets = true;
                hasOpenSquareBracket = true;
                chClass = 0;
                break;
              case 93:
                inSquareBrackets = false;
                chClass = hasOpenSquareBracket ? 0 : 1;
                break;
              case 123:
                hasOpenCurlyBracket = true;
                chClass = 0;
                break;
              case 125:
                chClass = hasOpenCurlyBracket ? 0 : 1;
                break;
              case 39:
              case 34:
              case 96:
                if (linkBeginChCode === chCode) {
                  chClass = 1;
                } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {
                  chClass = 0;
                } else {
                  chClass = 1;
                }
                break;
              case 42:
                chClass = linkBeginChCode === 42 ? 1 : 0;
                break;
              case 124:
                chClass = linkBeginChCode === 124 ? 1 : 0;
                break;
              case 32:
                chClass = inSquareBrackets ? 0 : 1;
                break;
              default:
                chClass = classifier.get(chCode);
            }
            if (chClass === 1) {
              result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
              resetStateMachine = true;
            }
          } else if (state === 12) {
            let chClass;
            if (chCode === 91) {
              hasOpenSquareBracket = true;
              chClass = 0;
            } else {
              chClass = classifier.get(chCode);
            }
            if (chClass === 1) {
              resetStateMachine = true;
            } else {
              state = 13;
            }
          } else {
            state = stateMachine.nextState(state, chCode);
            if (state === 0) {
              resetStateMachine = true;
            }
          }
          if (resetStateMachine) {
            state = 1;
            hasOpenParens = false;
            hasOpenSquareBracket = false;
            hasOpenCurlyBracket = false;
            linkBeginIndex = j + 1;
            linkBeginChCode = chCode;
          }
          j++;
        }
        if (state === 13) {
          result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
        }
      }
      return result;
    }
  };
  function computeLinks(model) {
    if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
      return [];
    }
    return LinkComputer.computeLinks(model);
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
  var BasicInplaceReplace = class {
    constructor() {
      this._defaultValueSet = [
        ["true", "false"],
        ["True", "False"],
        ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
        ["public", "protected", "private"]
      ];
    }
    navigateValueSet(range1, text1, range2, text2, up) {
      if (range1 && text1) {
        const result = this.doNavigateValueSet(text1, up);
        if (result) {
          return {
            range: range1,
            value: result
          };
        }
      }
      if (range2 && text2) {
        const result = this.doNavigateValueSet(text2, up);
        if (result) {
          return {
            range: range2,
            value: result
          };
        }
      }
      return null;
    }
    doNavigateValueSet(text2, up) {
      const numberResult = this.numberReplace(text2, up);
      if (numberResult !== null) {
        return numberResult;
      }
      return this.textReplace(text2, up);
    }
    numberReplace(value2, up) {
      const precision = Math.pow(10, value2.length - (value2.lastIndexOf(".") + 1));
      let n1 = Number(value2);
      const n2 = parseFloat(value2);
      if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
        if (n1 === 0 && !up) {
          return null;
        } else {
          n1 = Math.floor(n1 * precision);
          n1 += up ? precision : -precision;
          return String(n1 / precision);
        }
      }
      return null;
    }
    textReplace(value2, up) {
      return this.valueSetsReplace(this._defaultValueSet, value2, up);
    }
    valueSetsReplace(valueSets, value2, up) {
      let result = null;
      for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
        result = this.valueSetReplace(valueSets[i], value2, up);
      }
      return result;
    }
    valueSetReplace(valueSet, value2, up) {
      let idx = valueSet.indexOf(value2);
      if (idx >= 0) {
        idx += up ? 1 : -1;
        if (idx < 0) {
          idx = valueSet.length - 1;
        } else {
          idx %= valueSet.length;
        }
        return valueSet[idx];
      }
      return null;
    }
  };
  BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js
  var shortcutEvent = Object.freeze(function(callback, context) {
    const handle = setTimeout(callback.bind(context), 0);
    return { dispose() {
      clearTimeout(handle);
    } };
  });
  var CancellationToken;
  (function(CancellationToken2) {
    function isCancellationToken(thing) {
      if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
        return true;
      }
      if (thing instanceof MutableToken) {
        return true;
      }
      if (!thing || typeof thing !== "object") {
        return false;
      }
      return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
    }
    CancellationToken2.isCancellationToken = isCancellationToken;
    CancellationToken2.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: Event.None
    });
    CancellationToken2.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: shortcutEvent
    });
  })(CancellationToken || (CancellationToken = {}));
  var MutableToken = class {
    constructor() {
      this._isCancelled = false;
      this._emitter = null;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(void 0);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new Emitter();
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = null;
      }
    }
  };
  var CancellationTokenSource = class {
    constructor(parent) {
      this._token = void 0;
      this._parentListener = void 0;
      this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
    }
    get token() {
      if (!this._token) {
        this._token = new MutableToken();
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken.Cancelled;
      } else if (this._token instanceof MutableToken) {
        this._token.cancel();
      }
    }
    dispose(cancel = false) {
      var _a4;
      if (cancel) {
        this.cancel();
      }
      (_a4 = this._parentListener) === null || _a4 === void 0 ? void 0 : _a4.dispose();
      if (!this._token) {
        this._token = CancellationToken.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
  var KeyCodeStrMap = class {
    constructor() {
      this._keyCodeToStr = [];
      this._strToKeyCode = /* @__PURE__ */ Object.create(null);
    }
    define(keyCode, str) {
      this._keyCodeToStr[keyCode] = str;
      this._strToKeyCode[str.toLowerCase()] = keyCode;
    }
    keyCodeToStr(keyCode) {
      return this._keyCodeToStr[keyCode];
    }
    strToKeyCode(str) {
      return this._strToKeyCode[str.toLowerCase()] || 0;
    }
  };
  var uiMap = new KeyCodeStrMap();
  var userSettingsUSMap = new KeyCodeStrMap();
  var userSettingsGeneralMap = new KeyCodeStrMap();
  var EVENT_KEY_CODE_MAP = new Array(230);
  var NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
  var scanCodeIntToStr = [];
  var scanCodeStrToInt = /* @__PURE__ */ Object.create(null);
  var scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);
  var IMMUTABLE_CODE_TO_KEY_CODE = [];
  var IMMUTABLE_KEY_CODE_TO_CODE = [];
  for (let i = 0; i <= 193; i++) {
    IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
  }
  for (let i = 0; i <= 132; i++) {
    IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
  }
  (function() {
    const empty = "";
    const mappings = [
      // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
      [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", empty, empty],
      [1, 1, "Hyper", 0, empty, 0, empty, empty, empty],
      [1, 2, "Super", 0, empty, 0, empty, empty, empty],
      [1, 3, "Fn", 0, empty, 0, empty, empty, empty],
      [1, 4, "FnLock", 0, empty, 0, empty, empty, empty],
      [1, 5, "Suspend", 0, empty, 0, empty, empty, empty],
      [1, 6, "Resume", 0, empty, 0, empty, empty, empty],
      [1, 7, "Turbo", 0, empty, 0, empty, empty, empty],
      [1, 8, "Sleep", 0, empty, 0, "VK_SLEEP", empty, empty],
      [1, 9, "WakeUp", 0, empty, 0, empty, empty, empty],
      [0, 10, "KeyA", 31, "A", 65, "VK_A", empty, empty],
      [0, 11, "KeyB", 32, "B", 66, "VK_B", empty, empty],
      [0, 12, "KeyC", 33, "C", 67, "VK_C", empty, empty],
      [0, 13, "KeyD", 34, "D", 68, "VK_D", empty, empty],
      [0, 14, "KeyE", 35, "E", 69, "VK_E", empty, empty],
      [0, 15, "KeyF", 36, "F", 70, "VK_F", empty, empty],
      [0, 16, "KeyG", 37, "G", 71, "VK_G", empty, empty],
      [0, 17, "KeyH", 38, "H", 72, "VK_H", empty, empty],
      [0, 18, "KeyI", 39, "I", 73, "VK_I", empty, empty],
      [0, 19, "KeyJ", 40, "J", 74, "VK_J", empty, empty],
      [0, 20, "KeyK", 41, "K", 75, "VK_K", empty, empty],
      [0, 21, "KeyL", 42, "L", 76, "VK_L", empty, empty],
      [0, 22, "KeyM", 43, "M", 77, "VK_M", empty, empty],
      [0, 23, "KeyN", 44, "N", 78, "VK_N", empty, empty],
      [0, 24, "KeyO", 45, "O", 79, "VK_O", empty, empty],
      [0, 25, "KeyP", 46, "P", 80, "VK_P", empty, empty],
      [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", empty, empty],
      [0, 27, "KeyR", 48, "R", 82, "VK_R", empty, empty],
      [0, 28, "KeyS", 49, "S", 83, "VK_S", empty, empty],
      [0, 29, "KeyT", 50, "T", 84, "VK_T", empty, empty],
      [0, 30, "KeyU", 51, "U", 85, "VK_U", empty, empty],
      [0, 31, "KeyV", 52, "V", 86, "VK_V", empty, empty],
      [0, 32, "KeyW", 53, "W", 87, "VK_W", empty, empty],
      [0, 33, "KeyX", 54, "X", 88, "VK_X", empty, empty],
      [0, 34, "KeyY", 55, "Y", 89, "VK_Y", empty, empty],
      [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", empty, empty],
      [0, 36, "Digit1", 22, "1", 49, "VK_1", empty, empty],
      [0, 37, "Digit2", 23, "2", 50, "VK_2", empty, empty],
      [0, 38, "Digit3", 24, "3", 51, "VK_3", empty, empty],
      [0, 39, "Digit4", 25, "4", 52, "VK_4", empty, empty],
      [0, 40, "Digit5", 26, "5", 53, "VK_5", empty, empty],
      [0, 41, "Digit6", 27, "6", 54, "VK_6", empty, empty],
      [0, 42, "Digit7", 28, "7", 55, "VK_7", empty, empty],
      [0, 43, "Digit8", 29, "8", 56, "VK_8", empty, empty],
      [0, 44, "Digit9", 30, "9", 57, "VK_9", empty, empty],
      [0, 45, "Digit0", 21, "0", 48, "VK_0", empty, empty],
      [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", empty, empty],
      [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", empty, empty],
      [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", empty, empty],
      [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", empty, empty],
      [1, 50, "Space", 10, "Space", 32, "VK_SPACE", empty, empty],
      [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
      [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
      [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
      [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
      [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
      [0, 56, "IntlHash", 0, empty, 0, empty, empty, empty],
      // has been dropped from the w3c spec
      [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
      [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
      [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
      [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
      [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
      [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
      [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", empty, empty],
      [1, 64, "F1", 59, "F1", 112, "VK_F1", empty, empty],
      [1, 65, "F2", 60, "F2", 113, "VK_F2", empty, empty],
      [1, 66, "F3", 61, "F3", 114, "VK_F3", empty, empty],
      [1, 67, "F4", 62, "F4", 115, "VK_F4", empty, empty],
      [1, 68, "F5", 63, "F5", 116, "VK_F5", empty, empty],
      [1, 69, "F6", 64, "F6", 117, "VK_F6", empty, empty],
      [1, 70, "F7", 65, "F7", 118, "VK_F7", empty, empty],
      [1, 71, "F8", 66, "F8", 119, "VK_F8", empty, empty],
      [1, 72, "F9", 67, "F9", 120, "VK_F9", empty, empty],
      [1, 73, "F10", 68, "F10", 121, "VK_F10", empty, empty],
      [1, 74, "F11", 69, "F11", 122, "VK_F11", empty, empty],
      [1, 75, "F12", 70, "F12", 123, "VK_F12", empty, empty],
      [1, 76, "PrintScreen", 0, empty, 0, empty, empty, empty],
      [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", empty, empty],
      [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", empty, empty],
      [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", empty, empty],
      [1, 80, "Home", 14, "Home", 36, "VK_HOME", empty, empty],
      [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", empty, empty],
      [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", empty, empty],
      [1, 83, "End", 13, "End", 35, "VK_END", empty, empty],
      [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", empty, empty],
      [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", empty],
      [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", empty],
      [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", empty],
      [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", empty],
      [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", empty, empty],
      [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", empty, empty],
      [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", empty, empty],
      [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", empty, empty],
      [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", empty, empty],
      [1, 94, "NumpadEnter", 3, empty, 0, empty, empty, empty],
      [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", empty, empty],
      [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", empty, empty],
      [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", empty, empty],
      [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", empty, empty],
      [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", empty, empty],
      [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", empty, empty],
      [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", empty, empty],
      [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", empty, empty],
      [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", empty, empty],
      [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", empty, empty],
      [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", empty, empty],
      [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", empty, empty],
      [1, 107, "ContextMenu", 58, "ContextMenu", 93, empty, empty, empty],
      [1, 108, "Power", 0, empty, 0, empty, empty, empty],
      [1, 109, "NumpadEqual", 0, empty, 0, empty, empty, empty],
      [1, 110, "F13", 71, "F13", 124, "VK_F13", empty, empty],
      [1, 111, "F14", 72, "F14", 125, "VK_F14", empty, empty],
      [1, 112, "F15", 73, "F15", 126, "VK_F15", empty, empty],
      [1, 113, "F16", 74, "F16", 127, "VK_F16", empty, empty],
      [1, 114, "F17", 75, "F17", 128, "VK_F17", empty, empty],
      [1, 115, "F18", 76, "F18", 129, "VK_F18", empty, empty],
      [1, 116, "F19", 77, "F19", 130, "VK_F19", empty, empty],
      [1, 117, "F20", 78, "F20", 131, "VK_F20", empty, empty],
      [1, 118, "F21", 79, "F21", 132, "VK_F21", empty, empty],
      [1, 119, "F22", 80, "F22", 133, "VK_F22", empty, empty],
      [1, 120, "F23", 81, "F23", 134, "VK_F23", empty, empty],
      [1, 121, "F24", 82, "F24", 135, "VK_F24", empty, empty],
      [1, 122, "Open", 0, empty, 0, empty, empty, empty],
      [1, 123, "Help", 0, empty, 0, empty, empty, empty],
      [1, 124, "Select", 0, empty, 0, empty, empty, empty],
      [1, 125, "Again", 0, empty, 0, empty, empty, empty],
      [1, 126, "Undo", 0, empty, 0, empty, empty, empty],
      [1, 127, "Cut", 0, empty, 0, empty, empty, empty],
      [1, 128, "Copy", 0, empty, 0, empty, empty, empty],
      [1, 129, "Paste", 0, empty, 0, empty, empty, empty],
      [1, 130, "Find", 0, empty, 0, empty, empty, empty],
      [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", empty, empty],
      [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", empty, empty],
      [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", empty, empty],
      [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", empty, empty],
      [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", empty, empty],
      [1, 136, "KanaMode", 0, empty, 0, empty, empty, empty],
      [0, 137, "IntlYen", 0, empty, 0, empty, empty, empty],
      [1, 138, "Convert", 0, empty, 0, empty, empty, empty],
      [1, 139, "NonConvert", 0, empty, 0, empty, empty, empty],
      [1, 140, "Lang1", 0, empty, 0, empty, empty, empty],
      [1, 141, "Lang2", 0, empty, 0, empty, empty, empty],
      [1, 142, "Lang3", 0, empty, 0, empty, empty, empty],
      [1, 143, "Lang4", 0, empty, 0, empty, empty, empty],
      [1, 144, "Lang5", 0, empty, 0, empty, empty, empty],
      [1, 145, "Abort", 0, empty, 0, empty, empty, empty],
      [1, 146, "Props", 0, empty, 0, empty, empty, empty],
      [1, 147, "NumpadParenLeft", 0, empty, 0, empty, empty, empty],
      [1, 148, "NumpadParenRight", 0, empty, 0, empty, empty, empty],
      [1, 149, "NumpadBackspace", 0, empty, 0, empty, empty, empty],
      [1, 150, "NumpadMemoryStore", 0, empty, 0, empty, empty, empty],
      [1, 151, "NumpadMemoryRecall", 0, empty, 0, empty, empty, empty],
      [1, 152, "NumpadMemoryClear", 0, empty, 0, empty, empty, empty],
      [1, 153, "NumpadMemoryAdd", 0, empty, 0, empty, empty, empty],
      [1, 154, "NumpadMemorySubtract", 0, empty, 0, empty, empty, empty],
      [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", empty, empty],
      [1, 156, "NumpadClearEntry", 0, empty, 0, empty, empty, empty],
      [1, 0, empty, 5, "Ctrl", 17, "VK_CONTROL", empty, empty],
      [1, 0, empty, 4, "Shift", 16, "VK_SHIFT", empty, empty],
      [1, 0, empty, 6, "Alt", 18, "VK_MENU", empty, empty],
      [1, 0, empty, 57, "Meta", 91, "VK_COMMAND", empty, empty],
      [1, 157, "ControlLeft", 5, empty, 0, "VK_LCONTROL", empty, empty],
      [1, 158, "ShiftLeft", 4, empty, 0, "VK_LSHIFT", empty, empty],
      [1, 159, "AltLeft", 6, empty, 0, "VK_LMENU", empty, empty],
      [1, 160, "MetaLeft", 57, empty, 0, "VK_LWIN", empty, empty],
      [1, 161, "ControlRight", 5, empty, 0, "VK_RCONTROL", empty, empty],
      [1, 162, "ShiftRight", 4, empty, 0, "VK_RSHIFT", empty, empty],
      [1, 163, "AltRight", 6, empty, 0, "VK_RMENU", empty, empty],
      [1, 164, "MetaRight", 57, empty, 0, "VK_RWIN", empty, empty],
      [1, 165, "BrightnessUp", 0, empty, 0, empty, empty, empty],
      [1, 166, "BrightnessDown", 0, empty, 0, empty, empty, empty],
      [1, 167, "MediaPlay", 0, empty, 0, empty, empty, empty],
      [1, 168, "MediaRecord", 0, empty, 0, empty, empty, empty],
      [1, 169, "MediaFastForward", 0, empty, 0, empty, empty, empty],
      [1, 170, "MediaRewind", 0, empty, 0, empty, empty, empty],
      [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", empty, empty],
      [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", empty, empty],
      [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", empty, empty],
      [1, 174, "Eject", 0, empty, 0, empty, empty, empty],
      [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", empty, empty],
      [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", empty, empty],
      [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", empty, empty],
      [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", empty, empty],
      [1, 179, "LaunchApp1", 0, empty, 0, "VK_MEDIA_LAUNCH_APP1", empty, empty],
      [1, 180, "SelectTask", 0, empty, 0, empty, empty, empty],
      [1, 181, "LaunchScreenSaver", 0, empty, 0, empty, empty, empty],
      [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", empty, empty],
      [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", empty, empty],
      [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", empty, empty],
      [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", empty, empty],
      [1, 186, "BrowserStop", 0, empty, 0, "VK_BROWSER_STOP", empty, empty],
      [1, 187, "BrowserRefresh", 0, empty, 0, "VK_BROWSER_REFRESH", empty, empty],
      [1, 188, "BrowserFavorites", 0, empty, 0, "VK_BROWSER_FAVORITES", empty, empty],
      [1, 189, "ZoomToggle", 0, empty, 0, empty, empty, empty],
      [1, 190, "MailReply", 0, empty, 0, empty, empty, empty],
      [1, 191, "MailForward", 0, empty, 0, empty, empty, empty],
      [1, 192, "MailSend", 0, empty, 0, empty, empty, empty],
      // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
      // If an Input Method Editor is processing key input and the event is keydown, return 229.
      [1, 0, empty, 114, "KeyInComposition", 229, empty, empty, empty],
      [1, 0, empty, 116, "ABNT_C2", 194, "VK_ABNT_C2", empty, empty],
      [1, 0, empty, 96, "OEM_8", 223, "VK_OEM_8", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_KANA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HANGUL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_JUNJA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_FINAL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HANJA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_KANJI", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_CONVERT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_NONCONVERT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ACCEPT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_MODECHANGE", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_SELECT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PRINT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EXECUTE", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_SNAPSHOT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HELP", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_APPS", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PROCESSKEY", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PACKET", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_DBE_SBCSCHAR", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_DBE_DBCSCHAR", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ATTN", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_CRSEL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EXSEL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EREOF", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PLAY", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ZOOM", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_NONAME", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PA1", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_OEM_CLEAR", empty, empty]
    ];
    const seenKeyCode = [];
    const seenScanCode = [];
    for (const mapping of mappings) {
      const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
      if (!seenScanCode[scanCode]) {
        seenScanCode[scanCode] = true;
        scanCodeIntToStr[scanCode] = scanCodeStr;
        scanCodeStrToInt[scanCodeStr] = scanCode;
        scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
        if (immutable) {
          IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
          if (keyCode !== 0 && keyCode !== 3 && keyCode !== 5 && keyCode !== 4 && keyCode !== 6 && keyCode !== 57) {
            IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
          }
        }
      }
      if (!seenKeyCode[keyCode]) {
        seenKeyCode[keyCode] = true;
        if (!keyCodeStr) {
          throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
        }
        uiMap.define(keyCode, keyCodeStr);
        userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
        userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
      }
      if (eventKeyCode) {
        EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
      }
      if (vkey) {
        NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
      }
    }
    IMMUTABLE_KEY_CODE_TO_CODE[
      3
      /* KeyCode.Enter */
    ] = 46;
  })();
  var KeyCodeUtils;
  (function(KeyCodeUtils2) {
    function toString2(keyCode) {
      return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toString = toString2;
    function fromString(key) {
      return uiMap.strToKeyCode(key);
    }
    KeyCodeUtils2.fromString = fromString;
    function toUserSettingsUS(keyCode) {
      return userSettingsUSMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
    function toUserSettingsGeneral(keyCode) {
      return userSettingsGeneralMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
    function fromUserSettings(key) {
      return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
    }
    KeyCodeUtils2.fromUserSettings = fromUserSettings;
    function toElectronAccelerator(keyCode) {
      if (keyCode >= 98 && keyCode <= 113) {
        return null;
      }
      switch (keyCode) {
        case 16:
          return "Up";
        case 18:
          return "Down";
        case 15:
          return "Left";
        case 17:
          return "Right";
      }
      return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;
  })(KeyCodeUtils || (KeyCodeUtils = {}));
  function KeyChord(firstPart, secondPart) {
    const chordPart = (secondPart & 65535) << 16 >>> 0;
    return (firstPart | chordPart) >>> 0;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
  var Selection = class _Selection extends Range {
    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
      super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
      this.selectionStartLineNumber = selectionStartLineNumber;
      this.selectionStartColumn = selectionStartColumn;
      this.positionLineNumber = positionLineNumber;
      this.positionColumn = positionColumn;
    }
    /**
     * Transform to a human-readable representation.
     */
    toString() {
      return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
    }
    /**
     * Test if equals other selection.
     */
    equalsSelection(other) {
      return _Selection.selectionsEqual(this, other);
    }
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a, b) {
      return a.selectionStartLineNumber === b.selectionStartLineNumber && a.selectionStartColumn === b.selectionStartColumn && a.positionLineNumber === b.positionLineNumber && a.positionColumn === b.positionColumn;
    }
    /**
     * Get directions (LTR or RTL).
     */
    getDirection() {
      if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
        return 0;
      }
      return 1;
    }
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber, endColumn) {
      if (this.getDirection() === 0) {
        return new _Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
      }
      return new _Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
    }
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition() {
      return new Position(this.positionLineNumber, this.positionColumn);
    }
    /**
     * Get the position at the start of the selection.
    */
    getSelectionStart() {
      return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
    }
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber, startColumn) {
      if (this.getDirection() === 0) {
        return new _Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
      }
      return new _Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
    }
    // ----
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start, end = start) {
      return new _Selection(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    /**
     * Creates a `Selection` from a range, given a direction.
     */
    static fromRange(range, direction) {
      if (direction === 0) {
        return new _Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
      } else {
        return new _Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
      }
    }
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel) {
      return new _Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
    }
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a, b) {
      if (a && !b || !a && b) {
        return false;
      }
      if (!a && !b) {
        return true;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0, len = a.length; i < len; i++) {
        if (!this.selectionsEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj) {
      return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
    }
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
      if (direction === 0) {
        return new _Selection(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      return new _Selection(endLineNumber, endColumn, startLineNumber, startColumn);
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js
  var _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
  function register(id, fontCharacter) {
    if (isString(fontCharacter)) {
      const val = _codiconFontCharacters[fontCharacter];
      if (val === void 0) {
        throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);
      }
      fontCharacter = val;
    }
    _codiconFontCharacters[id] = fontCharacter;
    return { id };
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js
  var codiconsLibrary = {
    add: register("add", 6e4),
    plus: register("plus", 6e4),
    gistNew: register("gist-new", 6e4),
    repoCreate: register("repo-create", 6e4),
    lightbulb: register("lightbulb", 60001),
    lightBulb: register("light-bulb", 60001),
    repo: register("repo", 60002),
    repoDelete: register("repo-delete", 60002),
    gistFork: register("gist-fork", 60003),
    repoForked: register("repo-forked", 60003),
    gitPullRequest: register("git-pull-request", 60004),
    gitPullRequestAbandoned: register("git-pull-request-abandoned", 60004),
    recordKeys: register("record-keys", 60005),
    keyboard: register("keyboard", 60005),
    tag: register("tag", 60006),
    gitPullRequestLabel: register("git-pull-request-label", 60006),
    tagAdd: register("tag-add", 60006),
    tagRemove: register("tag-remove", 60006),
    person: register("person", 60007),
    personFollow: register("person-follow", 60007),
    personOutline: register("person-outline", 60007),
    personFilled: register("person-filled", 60007),
    gitBranch: register("git-branch", 60008),
    gitBranchCreate: register("git-branch-create", 60008),
    gitBranchDelete: register("git-branch-delete", 60008),
    sourceControl: register("source-control", 60008),
    mirror: register("mirror", 60009),
    mirrorPublic: register("mirror-public", 60009),
    star: register("star", 60010),
    starAdd: register("star-add", 60010),
    starDelete: register("star-delete", 60010),
    starEmpty: register("star-empty", 60010),
    comment: register("comment", 60011),
    commentAdd: register("comment-add", 60011),
    alert: register("alert", 60012),
    warning: register("warning", 60012),
    search: register("search", 60013),
    searchSave: register("search-save", 60013),
    logOut: register("log-out", 60014),
    signOut: register("sign-out", 60014),
    logIn: register("log-in", 60015),
    signIn: register("sign-in", 60015),
    eye: register("eye", 60016),
    eyeUnwatch: register("eye-unwatch", 60016),
    eyeWatch: register("eye-watch", 60016),
    circleFilled: register("circle-filled", 60017),
    primitiveDot: register("primitive-dot", 60017),
    closeDirty: register("close-dirty", 60017),
    debugBreakpoint: register("debug-breakpoint", 60017),
    debugBreakpointDisabled: register("debug-breakpoint-disabled", 60017),
    debugHint: register("debug-hint", 60017),
    terminalDecorationSuccess: register("terminal-decoration-success", 60017),
    primitiveSquare: register("primitive-square", 60018),
    edit: register("edit", 60019),
    pencil: register("pencil", 60019),
    info: register("info", 60020),
    issueOpened: register("issue-opened", 60020),
    gistPrivate: register("gist-private", 60021),
    gitForkPrivate: register("git-fork-private", 60021),
    lock: register("lock", 60021),
    mirrorPrivate: register("mirror-private", 60021),
    close: register("close", 60022),
    removeClose: register("remove-close", 60022),
    x: register("x", 60022),
    repoSync: register("repo-sync", 60023),
    sync: register("sync", 60023),
    clone: register("clone", 60024),
    desktopDownload: register("desktop-download", 60024),
    beaker: register("beaker", 60025),
    microscope: register("microscope", 60025),
    vm: register("vm", 60026),
    deviceDesktop: register("device-desktop", 60026),
    file: register("file", 60027),
    fileText: register("file-text", 60027),
    more: register("more", 60028),
    ellipsis: register("ellipsis", 60028),
    kebabHorizontal: register("kebab-horizontal", 60028),
    mailReply: register("mail-reply", 60029),
    reply: register("reply", 60029),
    organization: register("organization", 60030),
    organizationFilled: register("organization-filled", 60030),
    organizationOutline: register("organization-outline", 60030),
    newFile: register("new-file", 60031),
    fileAdd: register("file-add", 60031),
    newFolder: register("new-folder", 60032),
    fileDirectoryCreate: register("file-directory-create", 60032),
    trash: register("trash", 60033),
    trashcan: register("trashcan", 60033),
    history: register("history", 60034),
    clock: register("clock", 60034),
    folder: register("folder", 60035),
    fileDirectory: register("file-directory", 60035),
    symbolFolder: register("symbol-folder", 60035),
    logoGithub: register("logo-github", 60036),
    markGithub: register("mark-github", 60036),
    github: register("github", 60036),
    terminal: register("terminal", 60037),
    console: register("console", 60037),
    repl: register("repl", 60037),
    zap: register("zap", 60038),
    symbolEvent: register("symbol-event", 60038),
    error: register("error", 60039),
    stop: register("stop", 60039),
    variable: register("variable", 60040),
    symbolVariable: register("symbol-variable", 60040),
    array: register("array", 60042),
    symbolArray: register("symbol-array", 60042),
    symbolModule: register("symbol-module", 60043),
    symbolPackage: register("symbol-package", 60043),
    symbolNamespace: register("symbol-namespace", 60043),
    symbolObject: register("symbol-object", 60043),
    symbolMethod: register("symbol-method", 60044),
    symbolFunction: register("symbol-function", 60044),
    symbolConstructor: register("symbol-constructor", 60044),
    symbolBoolean: register("symbol-boolean", 60047),
    symbolNull: register("symbol-null", 60047),
    symbolNumeric: register("symbol-numeric", 60048),
    symbolNumber: register("symbol-number", 60048),
    symbolStructure: register("symbol-structure", 60049),
    symbolStruct: register("symbol-struct", 60049),
    symbolParameter: register("symbol-parameter", 60050),
    symbolTypeParameter: register("symbol-type-parameter", 60050),
    symbolKey: register("symbol-key", 60051),
    symbolText: register("symbol-text", 60051),
    symbolReference: register("symbol-reference", 60052),
    goToFile: register("go-to-file", 60052),
    symbolEnum: register("symbol-enum", 60053),
    symbolValue: register("symbol-value", 60053),
    symbolRuler: register("symbol-ruler", 60054),
    symbolUnit: register("symbol-unit", 60054),
    activateBreakpoints: register("activate-breakpoints", 60055),
    archive: register("archive", 60056),
    arrowBoth: register("arrow-both", 60057),
    arrowDown: register("arrow-down", 60058),
    arrowLeft: register("arrow-left", 60059),
    arrowRight: register("arrow-right", 60060),
    arrowSmallDown: register("arrow-small-down", 60061),
    arrowSmallLeft: register("arrow-small-left", 60062),
    arrowSmallRight: register("arrow-small-right", 60063),
    arrowSmallUp: register("arrow-small-up", 60064),
    arrowUp: register("arrow-up", 60065),
    bell: register("bell", 60066),
    bold: register("bold", 60067),
    book: register("book", 60068),
    bookmark: register("bookmark", 60069),
    debugBreakpointConditionalUnverified: register("debug-breakpoint-conditional-unverified", 60070),
    debugBreakpointConditional: register("debug-breakpoint-conditional", 60071),
    debugBreakpointConditionalDisabled: register("debug-breakpoint-conditional-disabled", 60071),
    debugBreakpointDataUnverified: register("debug-breakpoint-data-unverified", 60072),
    debugBreakpointData: register("debug-breakpoint-data", 60073),
    debugBreakpointDataDisabled: register("debug-breakpoint-data-disabled", 60073),
    debugBreakpointLogUnverified: register("debug-breakpoint-log-unverified", 60074),
    debugBreakpointLog: register("debug-breakpoint-log", 60075),
    debugBreakpointLogDisabled: register("debug-breakpoint-log-disabled", 60075),
    briefcase: register("briefcase", 60076),
    broadcast: register("broadcast", 60077),
    browser: register("browser", 60078),
    bug: register("bug", 60079),
    calendar: register("calendar", 60080),
    caseSensitive: register("case-sensitive", 60081),
    check: register("check", 60082),
    checklist: register("checklist", 60083),
    chevronDown: register("chevron-down", 60084),
    chevronLeft: register("chevron-left", 60085),
    chevronRight: register("chevron-right", 60086),
    chevronUp: register("chevron-up", 60087),
    chromeClose: register("chrome-close", 60088),
    chromeMaximize: register("chrome-maximize", 60089),
    chromeMinimize: register("chrome-minimize", 60090),
    chromeRestore: register("chrome-restore", 60091),
    circleOutline: register("circle-outline", 60092),
    circle: register("circle", 60092),
    debugBreakpointUnverified: register("debug-breakpoint-unverified", 60092),
    terminalDecorationIncomplete: register("terminal-decoration-incomplete", 60092),
    circleSlash: register("circle-slash", 60093),
    circuitBoard: register("circuit-board", 60094),
    clearAll: register("clear-all", 60095),
    clippy: register("clippy", 60096),
    closeAll: register("close-all", 60097),
    cloudDownload: register("cloud-download", 60098),
    cloudUpload: register("cloud-upload", 60099),
    code: register("code", 60100),
    collapseAll: register("collapse-all", 60101),
    colorMode: register("color-mode", 60102),
    commentDiscussion: register("comment-discussion", 60103),
    creditCard: register("credit-card", 60105),
    dash: register("dash", 60108),
    dashboard: register("dashboard", 60109),
    database: register("database", 60110),
    debugContinue: register("debug-continue", 60111),
    debugDisconnect: register("debug-disconnect", 60112),
    debugPause: register("debug-pause", 60113),
    debugRestart: register("debug-restart", 60114),
    debugStart: register("debug-start", 60115),
    debugStepInto: register("debug-step-into", 60116),
    debugStepOut: register("debug-step-out", 60117),
    debugStepOver: register("debug-step-over", 60118),
    debugStop: register("debug-stop", 60119),
    debug: register("debug", 60120),
    deviceCameraVideo: register("device-camera-video", 60121),
    deviceCamera: register("device-camera", 60122),
    deviceMobile: register("device-mobile", 60123),
    diffAdded: register("diff-added", 60124),
    diffIgnored: register("diff-ignored", 60125),
    diffModified: register("diff-modified", 60126),
    diffRemoved: register("diff-removed", 60127),
    diffRenamed: register("diff-renamed", 60128),
    diff: register("diff", 60129),
    diffSidebyside: register("diff-sidebyside", 60129),
    discard: register("discard", 60130),
    editorLayout: register("editor-layout", 60131),
    emptyWindow: register("empty-window", 60132),
    exclude: register("exclude", 60133),
    extensions: register("extensions", 60134),
    eyeClosed: register("eye-closed", 60135),
    fileBinary: register("file-binary", 60136),
    fileCode: register("file-code", 60137),
    fileMedia: register("file-media", 60138),
    filePdf: register("file-pdf", 60139),
    fileSubmodule: register("file-submodule", 60140),
    fileSymlinkDirectory: register("file-symlink-directory", 60141),
    fileSymlinkFile: register("file-symlink-file", 60142),
    fileZip: register("file-zip", 60143),
    files: register("files", 60144),
    filter: register("filter", 60145),
    flame: register("flame", 60146),
    foldDown: register("fold-down", 60147),
    foldUp: register("fold-up", 60148),
    fold: register("fold", 60149),
    folderActive: register("folder-active", 60150),
    folderOpened: register("folder-opened", 60151),
    gear: register("gear", 60152),
    gift: register("gift", 60153),
    gistSecret: register("gist-secret", 60154),
    gist: register("gist", 60155),
    gitCommit: register("git-commit", 60156),
    gitCompare: register("git-compare", 60157),
    compareChanges: register("compare-changes", 60157),
    gitMerge: register("git-merge", 60158),
    githubAction: register("github-action", 60159),
    githubAlt: register("github-alt", 60160),
    globe: register("globe", 60161),
    grabber: register("grabber", 60162),
    graph: register("graph", 60163),
    gripper: register("gripper", 60164),
    heart: register("heart", 60165),
    home: register("home", 60166),
    horizontalRule: register("horizontal-rule", 60167),
    hubot: register("hubot", 60168),
    inbox: register("inbox", 60169),
    issueReopened: register("issue-reopened", 60171),
    issues: register("issues", 60172),
    italic: register("italic", 60173),
    jersey: register("jersey", 60174),
    json: register("json", 60175),
    kebabVertical: register("kebab-vertical", 60176),
    key: register("key", 60177),
    law: register("law", 60178),
    lightbulbAutofix: register("lightbulb-autofix", 60179),
    linkExternal: register("link-external", 60180),
    link: register("link", 60181),
    listOrdered: register("list-ordered", 60182),
    listUnordered: register("list-unordered", 60183),
    liveShare: register("live-share", 60184),
    loading: register("loading", 60185),
    location: register("location", 60186),
    mailRead: register("mail-read", 60187),
    mail: register("mail", 60188),
    markdown: register("markdown", 60189),
    megaphone: register("megaphone", 60190),
    mention: register("mention", 60191),
    milestone: register("milestone", 60192),
    gitPullRequestMilestone: register("git-pull-request-milestone", 60192),
    mortarBoard: register("mortar-board", 60193),
    move: register("move", 60194),
    multipleWindows: register("multiple-windows", 60195),
    mute: register("mute", 60196),
    noNewline: register("no-newline", 60197),
    note: register("note", 60198),
    octoface: register("octoface", 60199),
    openPreview: register("open-preview", 60200),
    package: register("package", 60201),
    paintcan: register("paintcan", 60202),
    pin: register("pin", 60203),
    play: register("play", 60204),
    run: register("run", 60204),
    plug: register("plug", 60205),
    preserveCase: register("preserve-case", 60206),
    preview: register("preview", 60207),
    project: register("project", 60208),
    pulse: register("pulse", 60209),
    question: register("question", 60210),
    quote: register("quote", 60211),
    radioTower: register("radio-tower", 60212),
    reactions: register("reactions", 60213),
    references: register("references", 60214),
    refresh: register("refresh", 60215),
    regex: register("regex", 60216),
    remoteExplorer: register("remote-explorer", 60217),
    remote: register("remote", 60218),
    remove: register("remove", 60219),
    replaceAll: register("replace-all", 60220),
    replace: register("replace", 60221),
    repoClone: register("repo-clone", 60222),
    repoForcePush: register("repo-force-push", 60223),
    repoPull: register("repo-pull", 60224),
    repoPush: register("repo-push", 60225),
    report: register("report", 60226),
    requestChanges: register("request-changes", 60227),
    rocket: register("rocket", 60228),
    rootFolderOpened: register("root-folder-opened", 60229),
    rootFolder: register("root-folder", 60230),
    rss: register("rss", 60231),
    ruby: register("ruby", 60232),
    saveAll: register("save-all", 60233),
    saveAs: register("save-as", 60234),
    save: register("save", 60235),
    screenFull: register("screen-full", 60236),
    screenNormal: register("screen-normal", 60237),
    searchStop: register("search-stop", 60238),
    server: register("server", 60240),
    settingsGear: register("settings-gear", 60241),
    settings: register("settings", 60242),
    shield: register("shield", 60243),
    smiley: register("smiley", 60244),
    sortPrecedence: register("sort-precedence", 60245),
    splitHorizontal: register("split-horizontal", 60246),
    splitVertical: register("split-vertical", 60247),
    squirrel: register("squirrel", 60248),
    starFull: register("star-full", 60249),
    starHalf: register("star-half", 60250),
    symbolClass: register("symbol-class", 60251),
    symbolColor: register("symbol-color", 60252),
    symbolConstant: register("symbol-constant", 60253),
    symbolEnumMember: register("symbol-enum-member", 60254),
    symbolField: register("symbol-field", 60255),
    symbolFile: register("symbol-file", 60256),
    symbolInterface: register("symbol-interface", 60257),
    symbolKeyword: register("symbol-keyword", 60258),
    symbolMisc: register("symbol-misc", 60259),
    symbolOperator: register("symbol-operator", 60260),
    symbolProperty: register("symbol-property", 60261),
    wrench: register("wrench", 60261),
    wrenchSubaction: register("wrench-subaction", 60261),
    symbolSnippet: register("symbol-snippet", 60262),
    tasklist: register("tasklist", 60263),
    telescope: register("telescope", 60264),
    textSize: register("text-size", 60265),
    threeBars: register("three-bars", 60266),
    thumbsdown: register("thumbsdown", 60267),
    thumbsup: register("thumbsup", 60268),
    tools: register("tools", 60269),
    triangleDown: register("triangle-down", 60270),
    triangleLeft: register("triangle-left", 60271),
    triangleRight: register("triangle-right", 60272),
    triangleUp: register("triangle-up", 60273),
    twitter: register("twitter", 60274),
    unfold: register("unfold", 60275),
    unlock: register("unlock", 60276),
    unmute: register("unmute", 60277),
    unverified: register("unverified", 60278),
    verified: register("verified", 60279),
    versions: register("versions", 60280),
    vmActive: register("vm-active", 60281),
    vmOutline: register("vm-outline", 60282),
    vmRunning: register("vm-running", 60283),
    watch: register("watch", 60284),
    whitespace: register("whitespace", 60285),
    wholeWord: register("whole-word", 60286),
    window: register("window", 60287),
    wordWrap: register("word-wrap", 60288),
    zoomIn: register("zoom-in", 60289),
    zoomOut: register("zoom-out", 60290),
    listFilter: register("list-filter", 60291),
    listFlat: register("list-flat", 60292),
    listSelection: register("list-selection", 60293),
    selection: register("selection", 60293),
    listTree: register("list-tree", 60294),
    debugBreakpointFunctionUnverified: register("debug-breakpoint-function-unverified", 60295),
    debugBreakpointFunction: register("debug-breakpoint-function", 60296),
    debugBreakpointFunctionDisabled: register("debug-breakpoint-function-disabled", 60296),
    debugStackframeActive: register("debug-stackframe-active", 60297),
    circleSmallFilled: register("circle-small-filled", 60298),
    debugStackframeDot: register("debug-stackframe-dot", 60298),
    terminalDecorationMark: register("terminal-decoration-mark", 60298),
    debugStackframe: register("debug-stackframe", 60299),
    debugStackframeFocused: register("debug-stackframe-focused", 60299),
    debugBreakpointUnsupported: register("debug-breakpoint-unsupported", 60300),
    symbolString: register("symbol-string", 60301),
    debugReverseContinue: register("debug-reverse-continue", 60302),
    debugStepBack: register("debug-step-back", 60303),
    debugRestartFrame: register("debug-restart-frame", 60304),
    debugAlt: register("debug-alt", 60305),
    callIncoming: register("call-incoming", 60306),
    callOutgoing: register("call-outgoing", 60307),
    menu: register("menu", 60308),
    expandAll: register("expand-all", 60309),
    feedback: register("feedback", 60310),
    gitPullRequestReviewer: register("git-pull-request-reviewer", 60310),
    groupByRefType: register("group-by-ref-type", 60311),
    ungroupByRefType: register("ungroup-by-ref-type", 60312),
    account: register("account", 60313),
    gitPullRequestAssignee: register("git-pull-request-assignee", 60313),
    bellDot: register("bell-dot", 60314),
    debugConsole: register("debug-console", 60315),
    library: register("library", 60316),
    output: register("output", 60317),
    runAll: register("run-all", 60318),
    syncIgnored: register("sync-ignored", 60319),
    pinned: register("pinned", 60320),
    githubInverted: register("github-inverted", 60321),
    serverProcess: register("server-process", 60322),
    serverEnvironment: register("server-environment", 60323),
    pass: register("pass", 60324),
    issueClosed: register("issue-closed", 60324),
    stopCircle: register("stop-circle", 60325),
    playCircle: register("play-circle", 60326),
    record: register("record", 60327),
    debugAltSmall: register("debug-alt-small", 60328),
    vmConnect: register("vm-connect", 60329),
    cloud: register("cloud", 60330),
    merge: register("merge", 60331),
    export: register("export", 60332),
    graphLeft: register("graph-left", 60333),
    magnet: register("magnet", 60334),
    notebook: register("notebook", 60335),
    redo: register("redo", 60336),
    checkAll: register("check-all", 60337),
    pinnedDirty: register("pinned-dirty", 60338),
    passFilled: register("pass-filled", 60339),
    circleLargeFilled: register("circle-large-filled", 60340),
    circleLarge: register("circle-large", 60341),
    circleLargeOutline: register("circle-large-outline", 60341),
    combine: register("combine", 60342),
    gather: register("gather", 60342),
    table: register("table", 60343),
    variableGroup: register("variable-group", 60344),
    typeHierarchy: register("type-hierarchy", 60345),
    typeHierarchySub: register("type-hierarchy-sub", 60346),
    typeHierarchySuper: register("type-hierarchy-super", 60347),
    gitPullRequestCreate: register("git-pull-request-create", 60348),
    runAbove: register("run-above", 60349),
    runBelow: register("run-below", 60350),
    notebookTemplate: register("notebook-template", 60351),
    debugRerun: register("debug-rerun", 60352),
    workspaceTrusted: register("workspace-trusted", 60353),
    workspaceUntrusted: register("workspace-untrusted", 60354),
    workspaceUnknown: register("workspace-unknown", 60355),
    terminalCmd: register("terminal-cmd", 60356),
    terminalDebian: register("terminal-debian", 60357),
    terminalLinux: register("terminal-linux", 60358),
    terminalPowershell: register("terminal-powershell", 60359),
    terminalTmux: register("terminal-tmux", 60360),
    terminalUbuntu: register("terminal-ubuntu", 60361),
    terminalBash: register("terminal-bash", 60362),
    arrowSwap: register("arrow-swap", 60363),
    copy: register("copy", 60364),
    personAdd: register("person-add", 60365),
    filterFilled: register("filter-filled", 60366),
    wand: register("wand", 60367),
    debugLineByLine: register("debug-line-by-line", 60368),
    inspect: register("inspect", 60369),
    layers: register("layers", 60370),
    layersDot: register("layers-dot", 60371),
    layersActive: register("layers-active", 60372),
    compass: register("compass", 60373),
    compassDot: register("compass-dot", 60374),
    compassActive: register("compass-active", 60375),
    azure: register("azure", 60376),
    issueDraft: register("issue-draft", 60377),
    gitPullRequestClosed: register("git-pull-request-closed", 60378),
    gitPullRequestDraft: register("git-pull-request-draft", 60379),
    debugAll: register("debug-all", 60380),
    debugCoverage: register("debug-coverage", 60381),
    runErrors: register("run-errors", 60382),
    folderLibrary: register("folder-library", 60383),
    debugContinueSmall: register("debug-continue-small", 60384),
    beakerStop: register("beaker-stop", 60385),
    graphLine: register("graph-line", 60386),
    graphScatter: register("graph-scatter", 60387),
    pieChart: register("pie-chart", 60388),
    bracket: register("bracket", 60175),
    bracketDot: register("bracket-dot", 60389),
    bracketError: register("bracket-error", 60390),
    lockSmall: register("lock-small", 60391),
    azureDevops: register("azure-devops", 60392),
    verifiedFilled: register("verified-filled", 60393),
    newline: register("newline", 60394),
    layout: register("layout", 60395),
    layoutActivitybarLeft: register("layout-activitybar-left", 60396),
    layoutActivitybarRight: register("layout-activitybar-right", 60397),
    layoutPanelLeft: register("layout-panel-left", 60398),
    layoutPanelCenter: register("layout-panel-center", 60399),
    layoutPanelJustify: register("layout-panel-justify", 60400),
    layoutPanelRight: register("layout-panel-right", 60401),
    layoutPanel: register("layout-panel", 60402),
    layoutSidebarLeft: register("layout-sidebar-left", 60403),
    layoutSidebarRight: register("layout-sidebar-right", 60404),
    layoutStatusbar: register("layout-statusbar", 60405),
    layoutMenubar: register("layout-menubar", 60406),
    layoutCentered: register("layout-centered", 60407),
    target: register("target", 60408),
    indent: register("indent", 60409),
    recordSmall: register("record-small", 60410),
    errorSmall: register("error-small", 60411),
    terminalDecorationError: register("terminal-decoration-error", 60411),
    arrowCircleDown: register("arrow-circle-down", 60412),
    arrowCircleLeft: register("arrow-circle-left", 60413),
    arrowCircleRight: register("arrow-circle-right", 60414),
    arrowCircleUp: register("arrow-circle-up", 60415),
    layoutSidebarRightOff: register("layout-sidebar-right-off", 60416),
    layoutPanelOff: register("layout-panel-off", 60417),
    layoutSidebarLeftOff: register("layout-sidebar-left-off", 60418),
    blank: register("blank", 60419),
    heartFilled: register("heart-filled", 60420),
    map: register("map", 60421),
    mapHorizontal: register("map-horizontal", 60421),
    foldHorizontal: register("fold-horizontal", 60421),
    mapFilled: register("map-filled", 60422),
    mapHorizontalFilled: register("map-horizontal-filled", 60422),
    foldHorizontalFilled: register("fold-horizontal-filled", 60422),
    circleSmall: register("circle-small", 60423),
    bellSlash: register("bell-slash", 60424),
    bellSlashDot: register("bell-slash-dot", 60425),
    commentUnresolved: register("comment-unresolved", 60426),
    gitPullRequestGoToChanges: register("git-pull-request-go-to-changes", 60427),
    gitPullRequestNewChanges: register("git-pull-request-new-changes", 60428),
    searchFuzzy: register("search-fuzzy", 60429),
    commentDraft: register("comment-draft", 60430),
    send: register("send", 60431),
    sparkle: register("sparkle", 60432),
    insert: register("insert", 60433),
    mic: register("mic", 60434),
    thumbsdownFilled: register("thumbsdown-filled", 60435),
    thumbsupFilled: register("thumbsup-filled", 60436),
    coffee: register("coffee", 60437),
    snake: register("snake", 60438),
    game: register("game", 60439),
    vr: register("vr", 60440),
    chip: register("chip", 60441),
    piano: register("piano", 60442),
    music: register("music", 60443),
    micFilled: register("mic-filled", 60444),
    repoFetch: register("repo-fetch", 60445),
    copilot: register("copilot", 60446),
    lightbulbSparkle: register("lightbulb-sparkle", 60447),
    robot: register("robot", 60448),
    sparkleFilled: register("sparkle-filled", 60449),
    diffSingle: register("diff-single", 60450),
    diffMultiple: register("diff-multiple", 60451),
    surroundWith: register("surround-with", 60452),
    share: register("share", 60453),
    gitStash: register("git-stash", 60454),
    gitStashApply: register("git-stash-apply", 60455),
    gitStashPop: register("git-stash-pop", 60456),
    vscode: register("vscode", 60457),
    vscodeInsiders: register("vscode-insiders", 60458),
    codeOss: register("code-oss", 60459),
    runCoverage: register("run-coverage", 60460),
    runAllCoverage: register("run-all-coverage", 60461),
    coverage: register("coverage", 60462),
    githubProject: register("github-project", 60463),
    mapVertical: register("map-vertical", 60464),
    foldVertical: register("fold-vertical", 60464),
    mapVerticalFilled: register("map-vertical-filled", 60465),
    foldVerticalFilled: register("fold-vertical-filled", 60465),
    goToSearch: register("go-to-search", 60466),
    percentage: register("percentage", 60467),
    sortPercentage: register("sort-percentage", 60467)
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js
  var codiconsDerived = {
    dialogError: register("dialog-error", "error"),
    dialogWarning: register("dialog-warning", "warning"),
    dialogInfo: register("dialog-info", "info"),
    dialogClose: register("dialog-close", "close"),
    treeItemExpanded: register("tree-item-expanded", "chevron-down"),
    // collapsed is done with rotation
    treeFilterOnTypeOn: register("tree-filter-on-type-on", "list-filter"),
    treeFilterOnTypeOff: register("tree-filter-on-type-off", "list-selection"),
    treeFilterClear: register("tree-filter-clear", "close"),
    treeItemLoading: register("tree-item-loading", "loading"),
    menuSelection: register("menu-selection", "check"),
    menuSubmenu: register("menu-submenu", "chevron-right"),
    menuBarMore: register("menubar-more", "more"),
    scrollbarButtonLeft: register("scrollbar-button-left", "triangle-left"),
    scrollbarButtonRight: register("scrollbar-button-right", "triangle-right"),
    scrollbarButtonUp: register("scrollbar-button-up", "triangle-up"),
    scrollbarButtonDown: register("scrollbar-button-down", "triangle-down"),
    toolBarMore: register("toolbar-more", "more"),
    quickInputBack: register("quick-input-back", "arrow-left"),
    dropDownButton: register("drop-down-button", 60084),
    symbolCustomColor: register("symbol-customcolor", 60252),
    exportIcon: register("export", 60332),
    workspaceUnspecified: register("workspace-unspecified", 60355),
    newLine: register("newline", 60394),
    thumbsDownFilled: register("thumbsdown-filled", 60435),
    thumbsUpFilled: register("thumbsup-filled", 60436),
    gitFetch: register("git-fetch", 60445),
    lightbulbSparkleAutofix: register("lightbulb-sparkle-autofix", 60447),
    debugBreakpointPending: register("debug-breakpoint-pending", 60377)
  };
  var Codicon = {
    ...codiconsLibrary,
    ...codiconsDerived
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js
  var TokenizationRegistry = class {
    constructor() {
      this._tokenizationSupports = /* @__PURE__ */ new Map();
      this._factories = /* @__PURE__ */ new Map();
      this._onDidChange = new Emitter();
      this.onDidChange = this._onDidChange.event;
      this._colorMap = null;
    }
    handleChange(languageIds) {
      this._onDidChange.fire({
        changedLanguages: languageIds,
        changedColorMap: false
      });
    }
    register(languageId, support) {
      this._tokenizationSupports.set(languageId, support);
      this.handleChange([languageId]);
      return toDisposable(() => {
        if (this._tokenizationSupports.get(languageId) !== support) {
          return;
        }
        this._tokenizationSupports.delete(languageId);
        this.handleChange([languageId]);
      });
    }
    get(languageId) {
      return this._tokenizationSupports.get(languageId) || null;
    }
    registerFactory(languageId, factory) {
      var _a4;
      (_a4 = this._factories.get(languageId)) === null || _a4 === void 0 ? void 0 : _a4.dispose();
      const myData = new TokenizationSupportFactoryData(this, languageId, factory);
      this._factories.set(languageId, myData);
      return toDisposable(() => {
        const v = this._factories.get(languageId);
        if (!v || v !== myData) {
          return;
        }
        this._factories.delete(languageId);
        v.dispose();
      });
    }
    async getOrCreate(languageId) {
      const tokenizationSupport = this.get(languageId);
      if (tokenizationSupport) {
        return tokenizationSupport;
      }
      const factory = this._factories.get(languageId);
      if (!factory || factory.isResolved) {
        return null;
      }
      await factory.resolve();
      return this.get(languageId);
    }
    isResolved(languageId) {
      const tokenizationSupport = this.get(languageId);
      if (tokenizationSupport) {
        return true;
      }
      const factory = this._factories.get(languageId);
      if (!factory || factory.isResolved) {
        return true;
      }
      return false;
    }
    setColorMap(colorMap) {
      this._colorMap = colorMap;
      this._onDidChange.fire({
        changedLanguages: Array.from(this._tokenizationSupports.keys()),
        changedColorMap: true
      });
    }
    getColorMap() {
      return this._colorMap;
    }
    getDefaultBackground() {
      if (this._colorMap && this._colorMap.length > 2) {
        return this._colorMap[
          2
          /* ColorId.DefaultBackground */
        ];
      }
      return null;
    }
  };
  var TokenizationSupportFactoryData = class extends Disposable {
    get isResolved() {
      return this._isResolved;
    }
    constructor(_registry, _languageId, _factory) {
      super();
      this._registry = _registry;
      this._languageId = _languageId;
      this._factory = _factory;
      this._isDisposed = false;
      this._resolvePromise = null;
      this._isResolved = false;
    }
    dispose() {
      this._isDisposed = true;
      super.dispose();
    }
    async resolve() {
      if (!this._resolvePromise) {
        this._resolvePromise = this._create();
      }
      return this._resolvePromise;
    }
    async _create() {
      const value2 = await this._factory.tokenizationSupport;
      this._isResolved = true;
      if (value2 && !this._isDisposed) {
        this._register(this._registry.register(this._languageId, value2));
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js
  var Token = class {
    constructor(offset, type, language) {
      this.offset = offset;
      this.type = type;
      this.language = language;
      this._tokenBrand = void 0;
    }
    toString() {
      return "(" + this.offset + ", " + this.type + ")";
    }
  };
  var HoverVerbosityAction;
  (function(HoverVerbosityAction3) {
    HoverVerbosityAction3[HoverVerbosityAction3["Increase"] = 0] = "Increase";
    HoverVerbosityAction3[HoverVerbosityAction3["Decrease"] = 1] = "Decrease";
  })(HoverVerbosityAction || (HoverVerbosityAction = {}));
  var CompletionItemKinds;
  (function(CompletionItemKinds2) {
    const byKind = /* @__PURE__ */ new Map();
    byKind.set(0, Codicon.symbolMethod);
    byKind.set(1, Codicon.symbolFunction);
    byKind.set(2, Codicon.symbolConstructor);
    byKind.set(3, Codicon.symbolField);
    byKind.set(4, Codicon.symbolVariable);
    byKind.set(5, Codicon.symbolClass);
    byKind.set(6, Codicon.symbolStruct);
    byKind.set(7, Codicon.symbolInterface);
    byKind.set(8, Codicon.symbolModule);
    byKind.set(9, Codicon.symbolProperty);
    byKind.set(10, Codicon.symbolEvent);
    byKind.set(11, Codicon.symbolOperator);
    byKind.set(12, Codicon.symbolUnit);
    byKind.set(13, Codicon.symbolValue);
    byKind.set(15, Codicon.symbolEnum);
    byKind.set(14, Codicon.symbolConstant);
    byKind.set(15, Codicon.symbolEnum);
    byKind.set(16, Codicon.symbolEnumMember);
    byKind.set(17, Codicon.symbolKeyword);
    byKind.set(27, Codicon.symbolSnippet);
    byKind.set(18, Codicon.symbolText);
    byKind.set(19, Codicon.symbolColor);
    byKind.set(20, Codicon.symbolFile);
    byKind.set(21, Codicon.symbolReference);
    byKind.set(22, Codicon.symbolCustomColor);
    byKind.set(23, Codicon.symbolFolder);
    byKind.set(24, Codicon.symbolTypeParameter);
    byKind.set(25, Codicon.account);
    byKind.set(26, Codicon.issues);
    function toIcon(kind) {
      let codicon = byKind.get(kind);
      if (!codicon) {
        console.info("No codicon found for CompletionItemKind " + kind);
        codicon = Codicon.symbolProperty;
      }
      return codicon;
    }
    CompletionItemKinds2.toIcon = toIcon;
    const data = /* @__PURE__ */ new Map();
    data.set(
      "method",
      0
      /* CompletionItemKind.Method */
    );
    data.set(
      "function",
      1
      /* CompletionItemKind.Function */
    );
    data.set(
      "constructor",
      2
      /* CompletionItemKind.Constructor */
    );
    data.set(
      "field",
      3
      /* CompletionItemKind.Field */
    );
    data.set(
      "variable",
      4
      /* CompletionItemKind.Variable */
    );
    data.set(
      "class",
      5
      /* CompletionItemKind.Class */
    );
    data.set(
      "struct",
      6
      /* CompletionItemKind.Struct */
    );
    data.set(
      "interface",
      7
      /* CompletionItemKind.Interface */
    );
    data.set(
      "module",
      8
      /* CompletionItemKind.Module */
    );
    data.set(
      "property",
      9
      /* CompletionItemKind.Property */
    );
    data.set(
      "event",
      10
      /* CompletionItemKind.Event */
    );
    data.set(
      "operator",
      11
      /* CompletionItemKind.Operator */
    );
    data.set(
      "unit",
      12
      /* CompletionItemKind.Unit */
    );
    data.set(
      "value",
      13
      /* CompletionItemKind.Value */
    );
    data.set(
      "constant",
      14
      /* CompletionItemKind.Constant */
    );
    data.set(
      "enum",
      15
      /* CompletionItemKind.Enum */
    );
    data.set(
      "enum-member",
      16
      /* CompletionItemKind.EnumMember */
    );
    data.set(
      "enumMember",
      16
      /* CompletionItemKind.EnumMember */
    );
    data.set(
      "keyword",
      17
      /* CompletionItemKind.Keyword */
    );
    data.set(
      "snippet",
      27
      /* CompletionItemKind.Snippet */
    );
    data.set(
      "text",
      18
      /* CompletionItemKind.Text */
    );
    data.set(
      "color",
      19
      /* CompletionItemKind.Color */
    );
    data.set(
      "file",
      20
      /* CompletionItemKind.File */
    );
    data.set(
      "reference",
      21
      /* CompletionItemKind.Reference */
    );
    data.set(
      "customcolor",
      22
      /* CompletionItemKind.Customcolor */
    );
    data.set(
      "folder",
      23
      /* CompletionItemKind.Folder */
    );
    data.set(
      "type-parameter",
      24
      /* CompletionItemKind.TypeParameter */
    );
    data.set(
      "typeParameter",
      24
      /* CompletionItemKind.TypeParameter */
    );
    data.set(
      "account",
      25
      /* CompletionItemKind.User */
    );
    data.set(
      "issue",
      26
      /* CompletionItemKind.Issue */
    );
    function fromString(value2, strict) {
      let res = data.get(value2);
      if (typeof res === "undefined" && !strict) {
        res = 9;
      }
      return res;
    }
    CompletionItemKinds2.fromString = fromString;
  })(CompletionItemKinds || (CompletionItemKinds = {}));
  var InlineCompletionTriggerKind;
  (function(InlineCompletionTriggerKind3) {
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
  })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
  var DocumentPasteTriggerKind;
  (function(DocumentPasteTriggerKind2) {
    DocumentPasteTriggerKind2[DocumentPasteTriggerKind2["Automatic"] = 0] = "Automatic";
    DocumentPasteTriggerKind2[DocumentPasteTriggerKind2["PasteAs"] = 1] = "PasteAs";
  })(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));
  var SignatureHelpTriggerKind;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
  })(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
  var DocumentHighlightKind;
  (function(DocumentHighlightKind3) {
    DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
    DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
    DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
  })(DocumentHighlightKind || (DocumentHighlightKind = {}));
  var symbolKindNames = {
    [
      17
      /* SymbolKind.Array */
    ]: localize("Array", "array"),
    [
      16
      /* SymbolKind.Boolean */
    ]: localize("Boolean", "boolean"),
    [
      4
      /* SymbolKind.Class */
    ]: localize("Class", "class"),
    [
      13
      /* SymbolKind.Constant */
    ]: localize("Constant", "constant"),
    [
      8
      /* SymbolKind.Constructor */
    ]: localize("Constructor", "constructor"),
    [
      9
      /* SymbolKind.Enum */
    ]: localize("Enum", "enumeration"),
    [
      21
      /* SymbolKind.EnumMember */
    ]: localize("EnumMember", "enumeration member"),
    [
      23
      /* SymbolKind.Event */
    ]: localize("Event", "event"),
    [
      7
      /* SymbolKind.Field */
    ]: localize("Field", "field"),
    [
      0
      /* SymbolKind.File */
    ]: localize("File", "file"),
    [
      11
      /* SymbolKind.Function */
    ]: localize("Function", "function"),
    [
      10
      /* SymbolKind.Interface */
    ]: localize("Interface", "interface"),
    [
      19
      /* SymbolKind.Key */
    ]: localize("Key", "key"),
    [
      5
      /* SymbolKind.Method */
    ]: localize("Method", "method"),
    [
      1
      /* SymbolKind.Module */
    ]: localize("Module", "module"),
    [
      2
      /* SymbolKind.Namespace */
    ]: localize("Namespace", "namespace"),
    [
      20
      /* SymbolKind.Null */
    ]: localize("Null", "null"),
    [
      15
      /* SymbolKind.Number */
    ]: localize("Number", "number"),
    [
      18
      /* SymbolKind.Object */
    ]: localize("Object", "object"),
    [
      24
      /* SymbolKind.Operator */
    ]: localize("Operator", "operator"),
    [
      3
      /* SymbolKind.Package */
    ]: localize("Package", "package"),
    [
      6
      /* SymbolKind.Property */
    ]: localize("Property", "property"),
    [
      14
      /* SymbolKind.String */
    ]: localize("String", "string"),
    [
      22
      /* SymbolKind.Struct */
    ]: localize("Struct", "struct"),
    [
      25
      /* SymbolKind.TypeParameter */
    ]: localize("TypeParameter", "type parameter"),
    [
      12
      /* SymbolKind.Variable */
    ]: localize("Variable", "variable")
  };
  var SymbolKinds;
  (function(SymbolKinds2) {
    const byKind = /* @__PURE__ */ new Map();
    byKind.set(0, Codicon.symbolFile);
    byKind.set(1, Codicon.symbolModule);
    byKind.set(2, Codicon.symbolNamespace);
    byKind.set(3, Codicon.symbolPackage);
    byKind.set(4, Codicon.symbolClass);
    byKind.set(5, Codicon.symbolMethod);
    byKind.set(6, Codicon.symbolProperty);
    byKind.set(7, Codicon.symbolField);
    byKind.set(8, Codicon.symbolConstructor);
    byKind.set(9, Codicon.symbolEnum);
    byKind.set(10, Codicon.symbolInterface);
    byKind.set(11, Codicon.symbolFunction);
    byKind.set(12, Codicon.symbolVariable);
    byKind.set(13, Codicon.symbolConstant);
    byKind.set(14, Codicon.symbolString);
    byKind.set(15, Codicon.symbolNumber);
    byKind.set(16, Codicon.symbolBoolean);
    byKind.set(17, Codicon.symbolArray);
    byKind.set(18, Codicon.symbolObject);
    byKind.set(19, Codicon.symbolKey);
    byKind.set(20, Codicon.symbolNull);
    byKind.set(21, Codicon.symbolEnumMember);
    byKind.set(22, Codicon.symbolStruct);
    byKind.set(23, Codicon.symbolEvent);
    byKind.set(24, Codicon.symbolOperator);
    byKind.set(25, Codicon.symbolTypeParameter);
    function toIcon(kind) {
      let icon = byKind.get(kind);
      if (!icon) {
        console.info("No codicon found for SymbolKind " + kind);
        icon = Codicon.symbolProperty;
      }
      return icon;
    }
    SymbolKinds2.toIcon = toIcon;
  })(SymbolKinds || (SymbolKinds = {}));
  var FoldingRangeKind = class _FoldingRangeKind {
    /**
     * Returns a {@link FoldingRangeKind} for the given value.
     *
     * @param value of the kind.
     */
    static fromValue(value2) {
      switch (value2) {
        case "comment":
          return _FoldingRangeKind.Comment;
        case "imports":
          return _FoldingRangeKind.Imports;
        case "region":
          return _FoldingRangeKind.Region;
      }
      return new _FoldingRangeKind(value2);
    }
    /**
     * Creates a new {@link FoldingRangeKind}.
     *
     * @param value of the kind.
     */
    constructor(value2) {
      this.value = value2;
    }
  };
  FoldingRangeKind.Comment = new FoldingRangeKind("comment");
  FoldingRangeKind.Imports = new FoldingRangeKind("imports");
  FoldingRangeKind.Region = new FoldingRangeKind("region");
  var NewSymbolNameTag;
  (function(NewSymbolNameTag3) {
    NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
  })(NewSymbolNameTag || (NewSymbolNameTag = {}));
  var NewSymbolNameTriggerKind;
  (function(NewSymbolNameTriggerKind3) {
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Invoke"] = 0] = "Invoke";
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Automatic"] = 1] = "Automatic";
  })(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));
  var Command;
  (function(Command2) {
    function is(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return typeof obj.id === "string" && typeof obj.title === "string";
    }
    Command2.is = is;
  })(Command || (Command = {}));
  var InlayHintKind;
  (function(InlayHintKind3) {
    InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
    InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
  })(InlayHintKind || (InlayHintKind = {}));
  var TokenizationRegistry2 = new TokenizationRegistry();
  var InlineEditTriggerKind;
  (function(InlineEditTriggerKind3) {
    InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
    InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
  })(InlineEditTriggerKind || (InlineEditTriggerKind = {}));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
  var AccessibilitySupport;
  (function(AccessibilitySupport2) {
    AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
    AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
    AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
  })(AccessibilitySupport || (AccessibilitySupport = {}));
  var CodeActionTriggerType;
  (function(CodeActionTriggerType2) {
    CodeActionTriggerType2[CodeActionTriggerType2["Invoke"] = 1] = "Invoke";
    CodeActionTriggerType2[CodeActionTriggerType2["Auto"] = 2] = "Auto";
  })(CodeActionTriggerType || (CodeActionTriggerType = {}));
  var CompletionItemInsertTextRule;
  (function(CompletionItemInsertTextRule2) {
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["None"] = 0] = "None";
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
  })(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
  var CompletionItemKind;
  (function(CompletionItemKind2) {
    CompletionItemKind2[CompletionItemKind2["Method"] = 0] = "Method";
    CompletionItemKind2[CompletionItemKind2["Function"] = 1] = "Function";
    CompletionItemKind2[CompletionItemKind2["Constructor"] = 2] = "Constructor";
    CompletionItemKind2[CompletionItemKind2["Field"] = 3] = "Field";
    CompletionItemKind2[CompletionItemKind2["Variable"] = 4] = "Variable";
    CompletionItemKind2[CompletionItemKind2["Class"] = 5] = "Class";
    CompletionItemKind2[CompletionItemKind2["Struct"] = 6] = "Struct";
    CompletionItemKind2[CompletionItemKind2["Interface"] = 7] = "Interface";
    CompletionItemKind2[CompletionItemKind2["Module"] = 8] = "Module";
    CompletionItemKind2[CompletionItemKind2["Property"] = 9] = "Property";
    CompletionItemKind2[CompletionItemKind2["Event"] = 10] = "Event";
    CompletionItemKind2[CompletionItemKind2["Operator"] = 11] = "Operator";
    CompletionItemKind2[CompletionItemKind2["Unit"] = 12] = "Unit";
    CompletionItemKind2[CompletionItemKind2["Value"] = 13] = "Value";
    CompletionItemKind2[CompletionItemKind2["Constant"] = 14] = "Constant";
    CompletionItemKind2[CompletionItemKind2["Enum"] = 15] = "Enum";
    CompletionItemKind2[CompletionItemKind2["EnumMember"] = 16] = "EnumMember";
    CompletionItemKind2[CompletionItemKind2["Keyword"] = 17] = "Keyword";
    CompletionItemKind2[CompletionItemKind2["Text"] = 18] = "Text";
    CompletionItemKind2[CompletionItemKind2["Color"] = 19] = "Color";
    CompletionItemKind2[CompletionItemKind2["File"] = 20] = "File";
    CompletionItemKind2[CompletionItemKind2["Reference"] = 21] = "Reference";
    CompletionItemKind2[CompletionItemKind2["Customcolor"] = 22] = "Customcolor";
    CompletionItemKind2[CompletionItemKind2["Folder"] = 23] = "Folder";
    CompletionItemKind2[CompletionItemKind2["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind2[CompletionItemKind2["User"] = 25] = "User";
    CompletionItemKind2[CompletionItemKind2["Issue"] = 26] = "Issue";
    CompletionItemKind2[CompletionItemKind2["Snippet"] = 27] = "Snippet";
  })(CompletionItemKind || (CompletionItemKind = {}));
  var CompletionItemTag;
  (function(CompletionItemTag2) {
    CompletionItemTag2[CompletionItemTag2["Deprecated"] = 1] = "Deprecated";
  })(CompletionItemTag || (CompletionItemTag = {}));
  var CompletionTriggerKind;
  (function(CompletionTriggerKind2) {
    CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
  })(CompletionTriggerKind || (CompletionTriggerKind = {}));
  var ContentWidgetPositionPreference;
  (function(ContentWidgetPositionPreference2) {
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
  })(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
  var CursorChangeReason;
  (function(CursorChangeReason2) {
    CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
    CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
    CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
    CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
    CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
    CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
    CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
  })(CursorChangeReason || (CursorChangeReason = {}));
  var DefaultEndOfLine;
  (function(DefaultEndOfLine2) {
    DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
    DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
  })(DefaultEndOfLine || (DefaultEndOfLine = {}));
  var DocumentHighlightKind2;
  (function(DocumentHighlightKind3) {
    DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
    DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
    DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
  })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
  var EditorAutoIndentStrategy;
  (function(EditorAutoIndentStrategy2) {
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
  })(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
  var EditorOption;
  (function(EditorOption2) {
    EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
    EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
    EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
    EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
    EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
    EditorOption2[EditorOption2["ariaRequired"] = 5] = "ariaRequired";
    EditorOption2[EditorOption2["autoClosingBrackets"] = 6] = "autoClosingBrackets";
    EditorOption2[EditorOption2["autoClosingComments"] = 7] = "autoClosingComments";
    EditorOption2[EditorOption2["screenReaderAnnounceInlineSuggestion"] = 8] = "screenReaderAnnounceInlineSuggestion";
    EditorOption2[EditorOption2["autoClosingDelete"] = 9] = "autoClosingDelete";
    EditorOption2[EditorOption2["autoClosingOvertype"] = 10] = "autoClosingOvertype";
    EditorOption2[EditorOption2["autoClosingQuotes"] = 11] = "autoClosingQuotes";
    EditorOption2[EditorOption2["autoIndent"] = 12] = "autoIndent";
    EditorOption2[EditorOption2["automaticLayout"] = 13] = "automaticLayout";
    EditorOption2[EditorOption2["autoSurround"] = 14] = "autoSurround";
    EditorOption2[EditorOption2["bracketPairColorization"] = 15] = "bracketPairColorization";
    EditorOption2[EditorOption2["guides"] = 16] = "guides";
    EditorOption2[EditorOption2["codeLens"] = 17] = "codeLens";
    EditorOption2[EditorOption2["codeLensFontFamily"] = 18] = "codeLensFontFamily";
    EditorOption2[EditorOption2["codeLensFontSize"] = 19] = "codeLensFontSize";
    EditorOption2[EditorOption2["colorDecorators"] = 20] = "colorDecorators";
    EditorOption2[EditorOption2["colorDecoratorsLimit"] = 21] = "colorDecoratorsLimit";
    EditorOption2[EditorOption2["columnSelection"] = 22] = "columnSelection";
    EditorOption2[EditorOption2["comments"] = 23] = "comments";
    EditorOption2[EditorOption2["contextmenu"] = 24] = "contextmenu";
    EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 25] = "copyWithSyntaxHighlighting";
    EditorOption2[EditorOption2["cursorBlinking"] = 26] = "cursorBlinking";
    EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 27] = "cursorSmoothCaretAnimation";
    EditorOption2[EditorOption2["cursorStyle"] = 28] = "cursorStyle";
    EditorOption2[EditorOption2["cursorSurroundingLines"] = 29] = "cursorSurroundingLines";
    EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 30] = "cursorSurroundingLinesStyle";
    EditorOption2[EditorOption2["cursorWidth"] = 31] = "cursorWidth";
    EditorOption2[EditorOption2["disableLayerHinting"] = 32] = "disableLayerHinting";
    EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 33] = "disableMonospaceOptimizations";
    EditorOption2[EditorOption2["domReadOnly"] = 34] = "domReadOnly";
    EditorOption2[EditorOption2["dragAndDrop"] = 35] = "dragAndDrop";
    EditorOption2[EditorOption2["dropIntoEditor"] = 36] = "dropIntoEditor";
    EditorOption2[EditorOption2["emptySelectionClipboard"] = 37] = "emptySelectionClipboard";
    EditorOption2[EditorOption2["experimentalWhitespaceRendering"] = 38] = "experimentalWhitespaceRendering";
    EditorOption2[EditorOption2["extraEditorClassName"] = 39] = "extraEditorClassName";
    EditorOption2[EditorOption2["fastScrollSensitivity"] = 40] = "fastScrollSensitivity";
    EditorOption2[EditorOption2["find"] = 41] = "find";
    EditorOption2[EditorOption2["fixedOverflowWidgets"] = 42] = "fixedOverflowWidgets";
    EditorOption2[EditorOption2["folding"] = 43] = "folding";
    EditorOption2[EditorOption2["foldingStrategy"] = 44] = "foldingStrategy";
    EditorOption2[EditorOption2["foldingHighlight"] = 45] = "foldingHighlight";
    EditorOption2[EditorOption2["foldingImportsByDefault"] = 46] = "foldingImportsByDefault";
    EditorOption2[EditorOption2["foldingMaximumRegions"] = 47] = "foldingMaximumRegions";
    EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 48] = "unfoldOnClickAfterEndOfLine";
    EditorOption2[EditorOption2["fontFamily"] = 49] = "fontFamily";
    EditorOption2[EditorOption2["fontInfo"] = 50] = "fontInfo";
    EditorOption2[EditorOption2["fontLigatures"] = 51] = "fontLigatures";
    EditorOption2[EditorOption2["fontSize"] = 52] = "fontSize";
    EditorOption2[EditorOption2["fontWeight"] = 53] = "fontWeight";
    EditorOption2[EditorOption2["fontVariations"] = 54] = "fontVariations";
    EditorOption2[EditorOption2["formatOnPaste"] = 55] = "formatOnPaste";
    EditorOption2[EditorOption2["formatOnType"] = 56] = "formatOnType";
    EditorOption2[EditorOption2["glyphMargin"] = 57] = "glyphMargin";
    EditorOption2[EditorOption2["gotoLocation"] = 58] = "gotoLocation";
    EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 59] = "hideCursorInOverviewRuler";
    EditorOption2[EditorOption2["hover"] = 60] = "hover";
    EditorOption2[EditorOption2["inDiffEditor"] = 61] = "inDiffEditor";
    EditorOption2[EditorOption2["inlineSuggest"] = 62] = "inlineSuggest";
    EditorOption2[EditorOption2["inlineEdit"] = 63] = "inlineEdit";
    EditorOption2[EditorOption2["letterSpacing"] = 64] = "letterSpacing";
    EditorOption2[EditorOption2["lightbulb"] = 65] = "lightbulb";
    EditorOption2[EditorOption2["lineDecorationsWidth"] = 66] = "lineDecorationsWidth";
    EditorOption2[EditorOption2["lineHeight"] = 67] = "lineHeight";
    EditorOption2[EditorOption2["lineNumbers"] = 68] = "lineNumbers";
    EditorOption2[EditorOption2["lineNumbersMinChars"] = 69] = "lineNumbersMinChars";
    EditorOption2[EditorOption2["linkedEditing"] = 70] = "linkedEditing";
    EditorOption2[EditorOption2["links"] = 71] = "links";
    EditorOption2[EditorOption2["matchBrackets"] = 72] = "matchBrackets";
    EditorOption2[EditorOption2["minimap"] = 73] = "minimap";
    EditorOption2[EditorOption2["mouseStyle"] = 74] = "mouseStyle";
    EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 75] = "mouseWheelScrollSensitivity";
    EditorOption2[EditorOption2["mouseWheelZoom"] = 76] = "mouseWheelZoom";
    EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 77] = "multiCursorMergeOverlapping";
    EditorOption2[EditorOption2["multiCursorModifier"] = 78] = "multiCursorModifier";
    EditorOption2[EditorOption2["multiCursorPaste"] = 79] = "multiCursorPaste";
    EditorOption2[EditorOption2["multiCursorLimit"] = 80] = "multiCursorLimit";
    EditorOption2[EditorOption2["occurrencesHighlight"] = 81] = "occurrencesHighlight";
    EditorOption2[EditorOption2["overviewRulerBorder"] = 82] = "overviewRulerBorder";
    EditorOption2[EditorOption2["overviewRulerLanes"] = 83] = "overviewRulerLanes";
    EditorOption2[EditorOption2["padding"] = 84] = "padding";
    EditorOption2[EditorOption2["pasteAs"] = 85] = "pasteAs";
    EditorOption2[EditorOption2["parameterHints"] = 86] = "parameterHints";
    EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 87] = "peekWidgetDefaultFocus";
    EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 88] = "definitionLinkOpensInPeek";
    EditorOption2[EditorOption2["quickSuggestions"] = 89] = "quickSuggestions";
    EditorOption2[EditorOption2["quickSuggestionsDelay"] = 90] = "quickSuggestionsDelay";
    EditorOption2[EditorOption2["readOnly"] = 91] = "readOnly";
    EditorOption2[EditorOption2["readOnlyMessage"] = 92] = "readOnlyMessage";
    EditorOption2[EditorOption2["renameOnType"] = 93] = "renameOnType";
    EditorOption2[EditorOption2["renderControlCharacters"] = 94] = "renderControlCharacters";
    EditorOption2[EditorOption2["renderFinalNewline"] = 95] = "renderFinalNewline";
    EditorOption2[EditorOption2["renderLineHighlight"] = 96] = "renderLineHighlight";
    EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 97] = "renderLineHighlightOnlyWhenFocus";
    EditorOption2[EditorOption2["renderValidationDecorations"] = 98] = "renderValidationDecorations";
    EditorOption2[EditorOption2["renderWhitespace"] = 99] = "renderWhitespace";
    EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 100] = "revealHorizontalRightPadding";
    EditorOption2[EditorOption2["roundedSelection"] = 101] = "roundedSelection";
    EditorOption2[EditorOption2["rulers"] = 102] = "rulers";
    EditorOption2[EditorOption2["scrollbar"] = 103] = "scrollbar";
    EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 104] = "scrollBeyondLastColumn";
    EditorOption2[EditorOption2["scrollBeyondLastLine"] = 105] = "scrollBeyondLastLine";
    EditorOption2[EditorOption2["scrollPredominantAxis"] = 106] = "scrollPredominantAxis";
    EditorOption2[EditorOption2["selectionClipboard"] = 107] = "selectionClipboard";
    EditorOption2[EditorOption2["selectionHighlight"] = 108] = "selectionHighlight";
    EditorOption2[EditorOption2["selectOnLineNumbers"] = 109] = "selectOnLineNumbers";
    EditorOption2[EditorOption2["showFoldingControls"] = 110] = "showFoldingControls";
    EditorOption2[EditorOption2["showUnused"] = 111] = "showUnused";
    EditorOption2[EditorOption2["snippetSuggestions"] = 112] = "snippetSuggestions";
    EditorOption2[EditorOption2["smartSelect"] = 113] = "smartSelect";
    EditorOption2[EditorOption2["smoothScrolling"] = 114] = "smoothScrolling";
    EditorOption2[EditorOption2["stickyScroll"] = 115] = "stickyScroll";
    EditorOption2[EditorOption2["stickyTabStops"] = 116] = "stickyTabStops";
    EditorOption2[EditorOption2["stopRenderingLineAfter"] = 117] = "stopRenderingLineAfter";
    EditorOption2[EditorOption2["suggest"] = 118] = "suggest";
    EditorOption2[EditorOption2["suggestFontSize"] = 119] = "suggestFontSize";
    EditorOption2[EditorOption2["suggestLineHeight"] = 120] = "suggestLineHeight";
    EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 121] = "suggestOnTriggerCharacters";
    EditorOption2[EditorOption2["suggestSelection"] = 122] = "suggestSelection";
    EditorOption2[EditorOption2["tabCompletion"] = 123] = "tabCompletion";
    EditorOption2[EditorOption2["tabIndex"] = 124] = "tabIndex";
    EditorOption2[EditorOption2["unicodeHighlighting"] = 125] = "unicodeHighlighting";
    EditorOption2[EditorOption2["unusualLineTerminators"] = 126] = "unusualLineTerminators";
    EditorOption2[EditorOption2["useShadowDOM"] = 127] = "useShadowDOM";
    EditorOption2[EditorOption2["useTabStops"] = 128] = "useTabStops";
    EditorOption2[EditorOption2["wordBreak"] = 129] = "wordBreak";
    EditorOption2[EditorOption2["wordSegmenterLocales"] = 130] = "wordSegmenterLocales";
    EditorOption2[EditorOption2["wordSeparators"] = 131] = "wordSeparators";
    EditorOption2[EditorOption2["wordWrap"] = 132] = "wordWrap";
    EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 133] = "wordWrapBreakAfterCharacters";
    EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 134] = "wordWrapBreakBeforeCharacters";
    EditorOption2[EditorOption2["wordWrapColumn"] = 135] = "wordWrapColumn";
    EditorOption2[EditorOption2["wordWrapOverride1"] = 136] = "wordWrapOverride1";
    EditorOption2[EditorOption2["wordWrapOverride2"] = 137] = "wordWrapOverride2";
    EditorOption2[EditorOption2["wrappingIndent"] = 138] = "wrappingIndent";
    EditorOption2[EditorOption2["wrappingStrategy"] = 139] = "wrappingStrategy";
    EditorOption2[EditorOption2["showDeprecated"] = 140] = "showDeprecated";
    EditorOption2[EditorOption2["inlayHints"] = 141] = "inlayHints";
    EditorOption2[EditorOption2["editorClassName"] = 142] = "editorClassName";
    EditorOption2[EditorOption2["pixelRatio"] = 143] = "pixelRatio";
    EditorOption2[EditorOption2["tabFocusMode"] = 144] = "tabFocusMode";
    EditorOption2[EditorOption2["layoutInfo"] = 145] = "layoutInfo";
    EditorOption2[EditorOption2["wrappingInfo"] = 146] = "wrappingInfo";
    EditorOption2[EditorOption2["defaultColorDecorators"] = 147] = "defaultColorDecorators";
    EditorOption2[EditorOption2["colorDecoratorsActivatedOn"] = 148] = "colorDecoratorsActivatedOn";
    EditorOption2[EditorOption2["inlineCompletionsAccessibilityVerbose"] = 149] = "inlineCompletionsAccessibilityVerbose";
  })(EditorOption || (EditorOption = {}));
  var EndOfLinePreference;
  (function(EndOfLinePreference2) {
    EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
    EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
    EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
  })(EndOfLinePreference || (EndOfLinePreference = {}));
  var EndOfLineSequence;
  (function(EndOfLineSequence2) {
    EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
    EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
  })(EndOfLineSequence || (EndOfLineSequence = {}));
  var GlyphMarginLane;
  (function(GlyphMarginLane3) {
    GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
    GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
    GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
  })(GlyphMarginLane || (GlyphMarginLane = {}));
  var HoverVerbosityAction2;
  (function(HoverVerbosityAction3) {
    HoverVerbosityAction3[HoverVerbosityAction3["Increase"] = 0] = "Increase";
    HoverVerbosityAction3[HoverVerbosityAction3["Decrease"] = 1] = "Decrease";
  })(HoverVerbosityAction2 || (HoverVerbosityAction2 = {}));
  var IndentAction;
  (function(IndentAction2) {
    IndentAction2[IndentAction2["None"] = 0] = "None";
    IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
    IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
    IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
  })(IndentAction || (IndentAction = {}));
  var InjectedTextCursorStops;
  (function(InjectedTextCursorStops3) {
    InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
    InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
  })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
  var InlayHintKind2;
  (function(InlayHintKind3) {
    InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
    InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
  })(InlayHintKind2 || (InlayHintKind2 = {}));
  var InlineCompletionTriggerKind2;
  (function(InlineCompletionTriggerKind3) {
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
  })(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
  var InlineEditTriggerKind2;
  (function(InlineEditTriggerKind3) {
    InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
    InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
  })(InlineEditTriggerKind2 || (InlineEditTriggerKind2 = {}));
  var KeyCode;
  (function(KeyCode2) {
    KeyCode2[KeyCode2["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
    KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
    KeyCode2[KeyCode2["Backspace"] = 1] = "Backspace";
    KeyCode2[KeyCode2["Tab"] = 2] = "Tab";
    KeyCode2[KeyCode2["Enter"] = 3] = "Enter";
    KeyCode2[KeyCode2["Shift"] = 4] = "Shift";
    KeyCode2[KeyCode2["Ctrl"] = 5] = "Ctrl";
    KeyCode2[KeyCode2["Alt"] = 6] = "Alt";
    KeyCode2[KeyCode2["PauseBreak"] = 7] = "PauseBreak";
    KeyCode2[KeyCode2["CapsLock"] = 8] = "CapsLock";
    KeyCode2[KeyCode2["Escape"] = 9] = "Escape";
    KeyCode2[KeyCode2["Space"] = 10] = "Space";
    KeyCode2[KeyCode2["PageUp"] = 11] = "PageUp";
    KeyCode2[KeyCode2["PageDown"] = 12] = "PageDown";
    KeyCode2[KeyCode2["End"] = 13] = "End";
    KeyCode2[KeyCode2["Home"] = 14] = "Home";
    KeyCode2[KeyCode2["LeftArrow"] = 15] = "LeftArrow";
    KeyCode2[KeyCode2["UpArrow"] = 16] = "UpArrow";
    KeyCode2[KeyCode2["RightArrow"] = 17] = "RightArrow";
    KeyCode2[KeyCode2["DownArrow"] = 18] = "DownArrow";
    KeyCode2[KeyCode2["Insert"] = 19] = "Insert";
    KeyCode2[KeyCode2["Delete"] = 20] = "Delete";
    KeyCode2[KeyCode2["Digit0"] = 21] = "Digit0";
    KeyCode2[KeyCode2["Digit1"] = 22] = "Digit1";
    KeyCode2[KeyCode2["Digit2"] = 23] = "Digit2";
    KeyCode2[KeyCode2["Digit3"] = 24] = "Digit3";
    KeyCode2[KeyCode2["Digit4"] = 25] = "Digit4";
    KeyCode2[KeyCode2["Digit5"] = 26] = "Digit5";
    KeyCode2[KeyCode2["Digit6"] = 27] = "Digit6";
    KeyCode2[KeyCode2["Digit7"] = 28] = "Digit7";
    KeyCode2[KeyCode2["Digit8"] = 29] = "Digit8";
    KeyCode2[KeyCode2["Digit9"] = 30] = "Digit9";
    KeyCode2[KeyCode2["KeyA"] = 31] = "KeyA";
    KeyCode2[KeyCode2["KeyB"] = 32] = "KeyB";
    KeyCode2[KeyCode2["KeyC"] = 33] = "KeyC";
    KeyCode2[KeyCode2["KeyD"] = 34] = "KeyD";
    KeyCode2[KeyCode2["KeyE"] = 35] = "KeyE";
    KeyCode2[KeyCode2["KeyF"] = 36] = "KeyF";
    KeyCode2[KeyCode2["KeyG"] = 37] = "KeyG";
    KeyCode2[KeyCode2["KeyH"] = 38] = "KeyH";
    KeyCode2[KeyCode2["KeyI"] = 39] = "KeyI";
    KeyCode2[KeyCode2["KeyJ"] = 40] = "KeyJ";
    KeyCode2[KeyCode2["KeyK"] = 41] = "KeyK";
    KeyCode2[KeyCode2["KeyL"] = 42] = "KeyL";
    KeyCode2[KeyCode2["KeyM"] = 43] = "KeyM";
    KeyCode2[KeyCode2["KeyN"] = 44] = "KeyN";
    KeyCode2[KeyCode2["KeyO"] = 45] = "KeyO";
    KeyCode2[KeyCode2["KeyP"] = 46] = "KeyP";
    KeyCode2[KeyCode2["KeyQ"] = 47] = "KeyQ";
    KeyCode2[KeyCode2["KeyR"] = 48] = "KeyR";
    KeyCode2[KeyCode2["KeyS"] = 49] = "KeyS";
    KeyCode2[KeyCode2["KeyT"] = 50] = "KeyT";
    KeyCode2[KeyCode2["KeyU"] = 51] = "KeyU";
    KeyCode2[KeyCode2["KeyV"] = 52] = "KeyV";
    KeyCode2[KeyCode2["KeyW"] = 53] = "KeyW";
    KeyCode2[KeyCode2["KeyX"] = 54] = "KeyX";
    KeyCode2[KeyCode2["KeyY"] = 55] = "KeyY";
    KeyCode2[KeyCode2["KeyZ"] = 56] = "KeyZ";
    KeyCode2[KeyCode2["Meta"] = 57] = "Meta";
    KeyCode2[KeyCode2["ContextMenu"] = 58] = "ContextMenu";
    KeyCode2[KeyCode2["F1"] = 59] = "F1";
    KeyCode2[KeyCode2["F2"] = 60] = "F2";
    KeyCode2[KeyCode2["F3"] = 61] = "F3";
    KeyCode2[KeyCode2["F4"] = 62] = "F4";
    KeyCode2[KeyCode2["F5"] = 63] = "F5";
    KeyCode2[KeyCode2["F6"] = 64] = "F6";
    KeyCode2[KeyCode2["F7"] = 65] = "F7";
    KeyCode2[KeyCode2["F8"] = 66] = "F8";
    KeyCode2[KeyCode2["F9"] = 67] = "F9";
    KeyCode2[KeyCode2["F10"] = 68] = "F10";
    KeyCode2[KeyCode2["F11"] = 69] = "F11";
    KeyCode2[KeyCode2["F12"] = 70] = "F12";
    KeyCode2[KeyCode2["F13"] = 71] = "F13";
    KeyCode2[KeyCode2["F14"] = 72] = "F14";
    KeyCode2[KeyCode2["F15"] = 73] = "F15";
    KeyCode2[KeyCode2["F16"] = 74] = "F16";
    KeyCode2[KeyCode2["F17"] = 75] = "F17";
    KeyCode2[KeyCode2["F18"] = 76] = "F18";
    KeyCode2[KeyCode2["F19"] = 77] = "F19";
    KeyCode2[KeyCode2["F20"] = 78] = "F20";
    KeyCode2[KeyCode2["F21"] = 79] = "F21";
    KeyCode2[KeyCode2["F22"] = 80] = "F22";
    KeyCode2[KeyCode2["F23"] = 81] = "F23";
    KeyCode2[KeyCode2["F24"] = 82] = "F24";
    KeyCode2[KeyCode2["NumLock"] = 83] = "NumLock";
    KeyCode2[KeyCode2["ScrollLock"] = 84] = "ScrollLock";
    KeyCode2[KeyCode2["Semicolon"] = 85] = "Semicolon";
    KeyCode2[KeyCode2["Equal"] = 86] = "Equal";
    KeyCode2[KeyCode2["Comma"] = 87] = "Comma";
    KeyCode2[KeyCode2["Minus"] = 88] = "Minus";
    KeyCode2[KeyCode2["Period"] = 89] = "Period";
    KeyCode2[KeyCode2["Slash"] = 90] = "Slash";
    KeyCode2[KeyCode2["Backquote"] = 91] = "Backquote";
    KeyCode2[KeyCode2["BracketLeft"] = 92] = "BracketLeft";
    KeyCode2[KeyCode2["Backslash"] = 93] = "Backslash";
    KeyCode2[KeyCode2["BracketRight"] = 94] = "BracketRight";
    KeyCode2[KeyCode2["Quote"] = 95] = "Quote";
    KeyCode2[KeyCode2["OEM_8"] = 96] = "OEM_8";
    KeyCode2[KeyCode2["IntlBackslash"] = 97] = "IntlBackslash";
    KeyCode2[KeyCode2["Numpad0"] = 98] = "Numpad0";
    KeyCode2[KeyCode2["Numpad1"] = 99] = "Numpad1";
    KeyCode2[KeyCode2["Numpad2"] = 100] = "Numpad2";
    KeyCode2[KeyCode2["Numpad3"] = 101] = "Numpad3";
    KeyCode2[KeyCode2["Numpad4"] = 102] = "Numpad4";
    KeyCode2[KeyCode2["Numpad5"] = 103] = "Numpad5";
    KeyCode2[KeyCode2["Numpad6"] = 104] = "Numpad6";
    KeyCode2[KeyCode2["Numpad7"] = 105] = "Numpad7";
    KeyCode2[KeyCode2["Numpad8"] = 106] = "Numpad8";
    KeyCode2[KeyCode2["Numpad9"] = 107] = "Numpad9";
    KeyCode2[KeyCode2["NumpadMultiply"] = 108] = "NumpadMultiply";
    KeyCode2[KeyCode2["NumpadAdd"] = 109] = "NumpadAdd";
    KeyCode2[KeyCode2["NUMPAD_SEPARATOR"] = 110] = "NUMPAD_SEPARATOR";
    KeyCode2[KeyCode2["NumpadSubtract"] = 111] = "NumpadSubtract";
    KeyCode2[KeyCode2["NumpadDecimal"] = 112] = "NumpadDecimal";
    KeyCode2[KeyCode2["NumpadDivide"] = 113] = "NumpadDivide";
    KeyCode2[KeyCode2["KEY_IN_COMPOSITION"] = 114] = "KEY_IN_COMPOSITION";
    KeyCode2[KeyCode2["ABNT_C1"] = 115] = "ABNT_C1";
    KeyCode2[KeyCode2["ABNT_C2"] = 116] = "ABNT_C2";
    KeyCode2[KeyCode2["AudioVolumeMute"] = 117] = "AudioVolumeMute";
    KeyCode2[KeyCode2["AudioVolumeUp"] = 118] = "AudioVolumeUp";
    KeyCode2[KeyCode2["AudioVolumeDown"] = 119] = "AudioVolumeDown";
    KeyCode2[KeyCode2["BrowserSearch"] = 120] = "BrowserSearch";
    KeyCode2[KeyCode2["BrowserHome"] = 121] = "BrowserHome";
    KeyCode2[KeyCode2["BrowserBack"] = 122] = "BrowserBack";
    KeyCode2[KeyCode2["BrowserForward"] = 123] = "BrowserForward";
    KeyCode2[KeyCode2["MediaTrackNext"] = 124] = "MediaTrackNext";
    KeyCode2[KeyCode2["MediaTrackPrevious"] = 125] = "MediaTrackPrevious";
    KeyCode2[KeyCode2["MediaStop"] = 126] = "MediaStop";
    KeyCode2[KeyCode2["MediaPlayPause"] = 127] = "MediaPlayPause";
    KeyCode2[KeyCode2["LaunchMediaPlayer"] = 128] = "LaunchMediaPlayer";
    KeyCode2[KeyCode2["LaunchMail"] = 129] = "LaunchMail";
    KeyCode2[KeyCode2["LaunchApp2"] = 130] = "LaunchApp2";
    KeyCode2[KeyCode2["Clear"] = 131] = "Clear";
    KeyCode2[KeyCode2["MAX_VALUE"] = 132] = "MAX_VALUE";
  })(KeyCode || (KeyCode = {}));
  var MarkerSeverity;
  (function(MarkerSeverity2) {
    MarkerSeverity2[MarkerSeverity2["Hint"] = 1] = "Hint";
    MarkerSeverity2[MarkerSeverity2["Info"] = 2] = "Info";
    MarkerSeverity2[MarkerSeverity2["Warning"] = 4] = "Warning";
    MarkerSeverity2[MarkerSeverity2["Error"] = 8] = "Error";
  })(MarkerSeverity || (MarkerSeverity = {}));
  var MarkerTag;
  (function(MarkerTag2) {
    MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
  })(MarkerTag || (MarkerTag = {}));
  var MinimapPosition;
  (function(MinimapPosition2) {
    MinimapPosition2[MinimapPosition2["Inline"] = 1] = "Inline";
    MinimapPosition2[MinimapPosition2["Gutter"] = 2] = "Gutter";
  })(MinimapPosition || (MinimapPosition = {}));
  var MinimapSectionHeaderStyle;
  (function(MinimapSectionHeaderStyle2) {
    MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2["Normal"] = 1] = "Normal";
    MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2["Underlined"] = 2] = "Underlined";
  })(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {}));
  var MouseTargetType;
  (function(MouseTargetType2) {
    MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
    MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
    MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
    MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
    MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
    MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
    MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
    MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
    MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
    MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
    MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
    MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
    MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
  })(MouseTargetType || (MouseTargetType = {}));
  var NewSymbolNameTag2;
  (function(NewSymbolNameTag3) {
    NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
  })(NewSymbolNameTag2 || (NewSymbolNameTag2 = {}));
  var NewSymbolNameTriggerKind2;
  (function(NewSymbolNameTriggerKind3) {
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Invoke"] = 0] = "Invoke";
    NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3["Automatic"] = 1] = "Automatic";
  })(NewSymbolNameTriggerKind2 || (NewSymbolNameTriggerKind2 = {}));
  var OverlayWidgetPositionPreference;
  (function(OverlayWidgetPositionPreference2) {
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
  })(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
  var OverviewRulerLane;
  (function(OverviewRulerLane3) {
    OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
    OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
    OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
    OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
  })(OverviewRulerLane || (OverviewRulerLane = {}));
  var PartialAcceptTriggerKind;
  (function(PartialAcceptTriggerKind2) {
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Word"] = 0] = "Word";
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Line"] = 1] = "Line";
    PartialAcceptTriggerKind2[PartialAcceptTriggerKind2["Suggest"] = 2] = "Suggest";
  })(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));
  var PositionAffinity;
  (function(PositionAffinity2) {
    PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
    PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
    PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
    PositionAffinity2[PositionAffinity2["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
    PositionAffinity2[PositionAffinity2["RightOfInjectedText"] = 4] = "RightOfInjectedText";
  })(PositionAffinity || (PositionAffinity = {}));
  var RenderLineNumbersType;
  (function(RenderLineNumbersType2) {
    RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
    RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
    RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
    RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
    RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
  })(RenderLineNumbersType || (RenderLineNumbersType = {}));
  var RenderMinimap;
  (function(RenderMinimap2) {
    RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
    RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
    RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
  })(RenderMinimap || (RenderMinimap = {}));
  var ScrollType;
  (function(ScrollType2) {
    ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
    ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
  })(ScrollType || (ScrollType = {}));
  var ScrollbarVisibility;
  (function(ScrollbarVisibility2) {
    ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
    ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
    ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
  })(ScrollbarVisibility || (ScrollbarVisibility = {}));
  var SelectionDirection;
  (function(SelectionDirection2) {
    SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
    SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
  })(SelectionDirection || (SelectionDirection = {}));
  var ShowLightbulbIconMode;
  (function(ShowLightbulbIconMode2) {
    ShowLightbulbIconMode2["Off"] = "off";
    ShowLightbulbIconMode2["OnCode"] = "onCode";
    ShowLightbulbIconMode2["On"] = "on";
  })(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));
  var SignatureHelpTriggerKind2;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
  })(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
  var SymbolKind;
  (function(SymbolKind2) {
    SymbolKind2[SymbolKind2["File"] = 0] = "File";
    SymbolKind2[SymbolKind2["Module"] = 1] = "Module";
    SymbolKind2[SymbolKind2["Namespace"] = 2] = "Namespace";
    SymbolKind2[SymbolKind2["Package"] = 3] = "Package";
    SymbolKind2[SymbolKind2["Class"] = 4] = "Class";
    SymbolKind2[SymbolKind2["Method"] = 5] = "Method";
    SymbolKind2[SymbolKind2["Property"] = 6] = "Property";
    SymbolKind2[SymbolKind2["Field"] = 7] = "Field";
    SymbolKind2[SymbolKind2["Constructor"] = 8] = "Constructor";
    SymbolKind2[SymbolKind2["Enum"] = 9] = "Enum";
    SymbolKind2[SymbolKind2["Interface"] = 10] = "Interface";
    SymbolKind2[SymbolKind2["Function"] = 11] = "Function";
    SymbolKind2[SymbolKind2["Variable"] = 12] = "Variable";
    SymbolKind2[SymbolKind2["Constant"] = 13] = "Constant";
    SymbolKind2[SymbolKind2["String"] = 14] = "String";
    SymbolKind2[SymbolKind2["Number"] = 15] = "Number";
    SymbolKind2[SymbolKind2["Boolean"] = 16] = "Boolean";
    SymbolKind2[SymbolKind2["Array"] = 17] = "Array";
    SymbolKind2[SymbolKind2["Object"] = 18] = "Object";
    SymbolKind2[SymbolKind2["Key"] = 19] = "Key";
    SymbolKind2[SymbolKind2["Null"] = 20] = "Null";
    SymbolKind2[SymbolKind2["EnumMember"] = 21] = "EnumMember";
    SymbolKind2[SymbolKind2["Struct"] = 22] = "Struct";
    SymbolKind2[SymbolKind2["Event"] = 23] = "Event";
    SymbolKind2[SymbolKind2["Operator"] = 24] = "Operator";
    SymbolKind2[SymbolKind2["TypeParameter"] = 25] = "TypeParameter";
  })(SymbolKind || (SymbolKind = {}));
  var SymbolTag;
  (function(SymbolTag2) {
    SymbolTag2[SymbolTag2["Deprecated"] = 1] = "Deprecated";
  })(SymbolTag || (SymbolTag = {}));
  var TextEditorCursorBlinkingStyle;
  (function(TextEditorCursorBlinkingStyle2) {
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
  })(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
  var TextEditorCursorStyle;
  (function(TextEditorCursorStyle2) {
    TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
    TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
    TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
    TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
    TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
    TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
  })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
  var TrackedRangeStickiness;
  (function(TrackedRangeStickiness2) {
    TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
  })(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
  var WrappingIndent;
  (function(WrappingIndent2) {
    WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
    WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
    WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
    WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
  })(WrappingIndent || (WrappingIndent = {}));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
  var KeyMod = class {
    static chord(firstPart, secondPart) {
      return KeyChord(firstPart, secondPart);
    }
  };
  KeyMod.CtrlCmd = 2048;
  KeyMod.Shift = 1024;
  KeyMod.Alt = 512;
  KeyMod.WinCtrl = 256;
  function createMonacoBaseAPI() {
    return {
      editor: void 0,
      // undefined override expected here
      languages: void 0,
      // undefined override expected here
      CancellationTokenSource,
      Emitter,
      KeyCode,
      KeyMod,
      Position,
      Range,
      Selection,
      SelectionDirection,
      MarkerSeverity,
      MarkerTag,
      Uri: URI,
      Token
    };
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/map.js
  var _a3;
  var _b2;
  var ResourceMapEntry = class {
    constructor(uri, value2) {
      this.uri = uri;
      this.value = value2;
    }
  };
  function isEntries(arg) {
    return Array.isArray(arg);
  }
  var ResourceMap = class _ResourceMap {
    constructor(arg, toKey) {
      this[_a3] = "ResourceMap";
      if (arg instanceof _ResourceMap) {
        this.map = new Map(arg.map);
        this.toKey = toKey !== null && toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;
      } else if (isEntries(arg)) {
        this.map = /* @__PURE__ */ new Map();
        this.toKey = toKey !== null && toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;
        for (const [resource, value2] of arg) {
          this.set(resource, value2);
        }
      } else {
        this.map = /* @__PURE__ */ new Map();
        this.toKey = arg !== null && arg !== void 0 ? arg : _ResourceMap.defaultToKey;
      }
    }
    set(resource, value2) {
      this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value2));
      return this;
    }
    get(resource) {
      var _c;
      return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;
    }
    has(resource) {
      return this.map.has(this.toKey(resource));
    }
    get size() {
      return this.map.size;
    }
    clear() {
      this.map.clear();
    }
    delete(resource) {
      return this.map.delete(this.toKey(resource));
    }
    forEach(clb, thisArg) {
      if (typeof thisArg !== "undefined") {
        clb = clb.bind(thisArg);
      }
      for (const [_, entry] of this.map) {
        clb(entry.value, entry.uri, this);
      }
    }
    *values() {
      for (const entry of this.map.values()) {
        yield entry.value;
      }
    }
    *keys() {
      for (const entry of this.map.values()) {
        yield entry.uri;
      }
    }
    *entries() {
      for (const entry of this.map.values()) {
        yield [entry.uri, entry.value];
      }
    }
    *[(_a3 = Symbol.toStringTag, Symbol.iterator)]() {
      for (const [, entry] of this.map) {
        yield [entry.uri, entry.value];
      }
    }
  };
  ResourceMap.defaultToKey = (resource) => resource.toString();
  var LinkedMap = class {
    constructor() {
      this[_b2] = "LinkedMap";
      this._map = /* @__PURE__ */ new Map();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state = 0;
    }
    clear() {
      this._map.clear();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state++;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    get first() {
      var _c;
      return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;
    }
    get last() {
      var _c;
      return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key, touch = 0) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      if (touch !== 0) {
        this.touch(item, touch);
      }
      return item.value;
    }
    set(key, value2, touch = 0) {
      let item = this._map.get(key);
      if (item) {
        item.value = value2;
        if (touch !== 0) {
          this.touch(item, touch);
        }
      } else {
        item = { key, value: value2, next: void 0, previous: void 0 };
        switch (touch) {
          case 0:
            this.addItemLast(item);
            break;
          case 1:
            this.addItemFirst(item);
            break;
          case 2:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item);
        this._size++;
      }
      return this;
    }
    delete(key) {
      return !!this.remove(key);
    }
    remove(key) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      this._map.delete(key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    shift() {
      if (!this._head && !this._tail) {
        return void 0;
      }
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      const item = this._head;
      this._map.delete(item.key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    forEach(callbackfn, thisArg) {
      const state = this._state;
      let current = this._head;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        if (this._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        current = current.next;
      }
    }
    keys() {
      const map = this;
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: current.key, done: false };
            current = current.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    values() {
      const map = this;
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: current.value, done: false };
            current = current.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    entries() {
      const map = this;
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]() {
          return iterator;
        },
        next() {
          if (map._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: [current.key, current.value], done: false };
            current = current.next;
            return result;
          } else {
            return { value: void 0, done: true };
          }
        }
      };
      return iterator;
    }
    [(_b2 = Symbol.toStringTag, Symbol.iterator)]() {
      return this.entries();
    }
    trimOld(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current = this._head;
      let currentSize = this.size;
      while (current && currentSize > newSize) {
        this._map.delete(current.key);
        current = current.next;
        currentSize--;
      }
      this._head = current;
      this._size = currentSize;
      if (current) {
        current.previous = void 0;
      }
      this._state++;
    }
    trimNew(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current = this._tail;
      let currentSize = this.size;
      while (current && currentSize > newSize) {
        this._map.delete(current.key);
        current = current.previous;
        currentSize--;
      }
      this._tail = current;
      this._size = currentSize;
      if (current) {
        current.next = void 0;
      }
      this._state++;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) {
        this._tail = item;
      } else if (!this._head) {
        throw new Error("Invalid list");
      } else {
        item.next = this._head;
        this._head.previous = item;
      }
      this._head = item;
      this._state++;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) {
        this._head = item;
      } else if (!this._tail) {
        throw new Error("Invalid list");
      } else {
        item.previous = this._tail;
        this._tail.next = item;
      }
      this._tail = item;
      this._state++;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._head = void 0;
        this._tail = void 0;
      } else if (item === this._head) {
        if (!item.next) {
          throw new Error("Invalid list");
        }
        item.next.previous = void 0;
        this._head = item.next;
      } else if (item === this._tail) {
        if (!item.previous) {
          throw new Error("Invalid list");
        }
        item.previous.next = void 0;
        this._tail = item.previous;
      } else {
        const next = item.next;
        const previous = item.previous;
        if (!next || !previous) {
          throw new Error("Invalid list");
        }
        next.previous = previous;
        previous.next = next;
      }
      item.next = void 0;
      item.previous = void 0;
      this._state++;
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      if (touch !== 1 && touch !== 2) {
        return;
      }
      if (touch === 1) {
        if (item === this._head) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._tail) {
          previous.next = void 0;
          this._tail = previous;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.previous = void 0;
        item.next = this._head;
        this._head.previous = item;
        this._head = item;
        this._state++;
      } else if (touch === 2) {
        if (item === this._tail) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._head) {
          next.previous = void 0;
          this._head = next;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = this._tail;
        this._tail.next = item;
        this._tail = item;
        this._state++;
      }
    }
    toJSON() {
      const data = [];
      this.forEach((value2, key) => {
        data.push([key, value2]);
      });
      return data;
    }
    fromJSON(data) {
      this.clear();
      for (const [key, value2] of data) {
        this.set(key, value2);
      }
    }
  };
  var Cache = class extends LinkedMap {
    constructor(limit, ratio = 1) {
      super();
      this._limit = limit;
      this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
      return this._limit;
    }
    set limit(limit) {
      this._limit = limit;
      this.checkTrim();
    }
    get(key, touch = 2) {
      return super.get(key, touch);
    }
    peek(key) {
      return super.get(
        key,
        0
        /* Touch.None */
      );
    }
    set(key, value2) {
      super.set(
        key,
        value2,
        2
        /* Touch.AsNew */
      );
      return this;
    }
    checkTrim() {
      if (this.size > this._limit) {
        this.trim(Math.round(this._limit * this._ratio));
      }
    }
  };
  var LRUCache = class extends Cache {
    constructor(limit, ratio = 1) {
      super(limit, ratio);
    }
    trim(newSize) {
      this.trimOld(newSize);
    }
    set(key, value2) {
      super.set(key, value2);
      this.checkTrim();
      return this;
    }
  };
  var SetMap = class {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    add(key, value2) {
      let values = this.map.get(key);
      if (!values) {
        values = /* @__PURE__ */ new Set();
        this.map.set(key, values);
      }
      values.add(value2);
    }
    delete(key, value2) {
      const values = this.map.get(key);
      if (!values) {
        return;
      }
      values.delete(value2);
      if (values.size === 0) {
        this.map.delete(key);
      }
    }
    forEach(key, fn2) {
      const values = this.map.get(key);
      if (!values) {
        return;
      }
      values.forEach(fn2);
    }
    get(key) {
      const values = this.map.get(key);
      if (!values) {
        return /* @__PURE__ */ new Set();
      }
      return values;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js
  var wordClassifierCache = new LRUCache(10);

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/model.js
  var OverviewRulerLane2;
  (function(OverviewRulerLane3) {
    OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
    OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
    OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
    OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
  })(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
  var GlyphMarginLane2;
  (function(GlyphMarginLane3) {
    GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
    GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
    GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
  })(GlyphMarginLane2 || (GlyphMarginLane2 = {}));
  var InjectedTextCursorStops2;
  (function(InjectedTextCursorStops3) {
    InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
    InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
  })(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
  function leftIsWordBounday(wordSeparators, text2, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
      return true;
    }
    const charBefore = text2.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0) {
      return true;
    }
    if (charBefore === 13 || charBefore === 10) {
      return true;
    }
    if (matchLength > 0) {
      const firstCharInMatch = text2.charCodeAt(matchStartIndex);
      if (wordSeparators.get(firstCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function rightIsWordBounday(wordSeparators, text2, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
      return true;
    }
    const charAfter = text2.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0) {
      return true;
    }
    if (charAfter === 13 || charAfter === 10) {
      return true;
    }
    if (matchLength > 0) {
      const lastCharInMatch = text2.charCodeAt(matchStartIndex + matchLength - 1);
      if (wordSeparators.get(lastCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function isValidMatch(wordSeparators, text2, textLength, matchStartIndex, matchLength) {
    return leftIsWordBounday(wordSeparators, text2, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text2, textLength, matchStartIndex, matchLength);
  }
  var Searcher = class {
    constructor(wordSeparators, searchRegex) {
      this._wordSeparators = wordSeparators;
      this._searchRegex = searchRegex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    reset(lastIndex) {
      this._searchRegex.lastIndex = lastIndex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    next(text2) {
      const textLength = text2.length;
      let m;
      do {
        if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
          return null;
        }
        m = this._searchRegex.exec(text2);
        if (!m) {
          return null;
        }
        const matchStartIndex = m.index;
        const matchLength = m[0].length;
        if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
          if (matchLength === 0) {
            if (getNextCodePoint(text2, textLength, this._searchRegex.lastIndex) > 65535) {
              this._searchRegex.lastIndex += 2;
            } else {
              this._searchRegex.lastIndex += 1;
            }
            continue;
          }
          return null;
        }
        this._prevMatchStartIndex = matchStartIndex;
        this._prevMatchLength = matchLength;
        if (!this._wordSeparators || isValidMatch(this._wordSeparators, text2, textLength, matchStartIndex, matchLength)) {
          return m;
        }
      } while (m);
      return null;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/assert.js
  function assertNever(value2, message = "Unreachable") {
    throw new Error(message);
  }
  function assertFn(condition) {
    if (!condition()) {
      debugger;
      condition();
      onUnexpectedError(new BugIndicatingError("Assertion Failed"));
    }
  }
  function checkAdjacentItems(items, predicate) {
    let i = 0;
    while (i < items.length - 1) {
      const a = items[i];
      const b = items[i + 1];
      if (!predicate(a, b)) {
        return false;
      }
      i++;
    }
    return true;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
  var UnicodeTextModelHighlighter = class {
    static computeUnicodeHighlights(model, options, range) {
      const startLine = range ? range.startLineNumber : 1;
      const endLine = range ? range.endLineNumber : model.getLineCount();
      const codePointHighlighter = new CodePointHighlighter(options);
      const candidates = codePointHighlighter.getCandidateCodePoints();
      let regex;
      if (candidates === "allNonBasicAscii") {
        regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
      } else {
        regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
      }
      const searcher = new Searcher(null, regex);
      const ranges = [];
      let hasMore = false;
      let m;
      let ambiguousCharacterCount = 0;
      let invisibleCharacterCount = 0;
      let nonBasicAsciiCharacterCount = 0;
      forLoop:
        for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
          const lineContent = model.getLineContent(lineNumber);
          const lineLength = lineContent.length;
          searcher.reset(0);
          do {
            m = searcher.next(lineContent);
            if (m) {
              let startIndex = m.index;
              let endIndex = m.index + m[0].length;
              if (startIndex > 0) {
                const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
                if (isHighSurrogate(charCodeBefore)) {
                  startIndex--;
                }
              }
              if (endIndex + 1 < lineLength) {
                const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
                if (isHighSurrogate(charCodeBefore)) {
                  endIndex++;
                }
              }
              const str = lineContent.substring(startIndex, endIndex);
              let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
              if (word && word.endColumn <= startIndex + 1) {
                word = null;
              }
              const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
              if (highlightReason !== 0) {
                if (highlightReason === 3) {
                  ambiguousCharacterCount++;
                } else if (highlightReason === 2) {
                  invisibleCharacterCount++;
                } else if (highlightReason === 1) {
                  nonBasicAsciiCharacterCount++;
                } else {
                  assertNever(highlightReason);
                }
                const MAX_RESULT_LENGTH = 1e3;
                if (ranges.length >= MAX_RESULT_LENGTH) {
                  hasMore = true;
                  break forLoop;
                }
                ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
              }
            }
          } while (m);
        }
      return {
        ranges,
        hasMore,
        ambiguousCharacterCount,
        invisibleCharacterCount,
        nonBasicAsciiCharacterCount
      };
    }
    static computeUnicodeHighlightReason(char, options) {
      const codePointHighlighter = new CodePointHighlighter(options);
      const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
      switch (reason) {
        case 0:
          return null;
        case 2:
          return {
            kind: 1
            /* UnicodeHighlighterReasonKind.Invisible */
          };
        case 3: {
          const codePoint = char.codePointAt(0);
          const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
          const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
          return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
        }
        case 1:
          return {
            kind: 2
            /* UnicodeHighlighterReasonKind.NonBasicAscii */
          };
      }
    }
  };
  function buildRegExpCharClassExpr(codePoints, flags) {
    const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(""))}]`;
    return src;
  }
  var CodePointHighlighter = class {
    constructor(options) {
      this.options = options;
      this.allowedCodePoints = new Set(options.allowedCodePoints);
      this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
    }
    getCandidateCodePoints() {
      if (this.options.nonBasicASCII) {
        return "allNonBasicAscii";
      }
      const set = /* @__PURE__ */ new Set();
      if (this.options.invisibleCharacters) {
        for (const cp of InvisibleCharacters.codePoints) {
          if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
            set.add(cp);
          }
        }
      }
      if (this.options.ambiguousCharacters) {
        for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
          set.add(cp);
        }
      }
      for (const cp of this.allowedCodePoints) {
        set.delete(cp);
      }
      return set;
    }
    shouldHighlightNonBasicASCII(character, wordContext) {
      const codePoint = character.codePointAt(0);
      if (this.allowedCodePoints.has(codePoint)) {
        return 0;
      }
      if (this.options.nonBasicASCII) {
        return 1;
      }
      let hasBasicASCIICharacters = false;
      let hasNonConfusableNonBasicAsciiCharacter = false;
      if (wordContext) {
        for (const char of wordContext) {
          const codePoint2 = char.codePointAt(0);
          const isBasicASCII2 = isBasicASCII(char);
          hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
          if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
            hasNonConfusableNonBasicAsciiCharacter = true;
          }
        }
      }
      if (
        /* Don't allow mixing weird looking characters with ASCII */
        !hasBasicASCIICharacters && /* Is there an obviously weird looking character? */
        hasNonConfusableNonBasicAsciiCharacter
      ) {
        return 0;
      }
      if (this.options.invisibleCharacters) {
        if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
          return 2;
        }
      }
      if (this.options.ambiguousCharacters) {
        if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
          return 3;
        }
      }
      return 0;
    }
  };
  function isAllowedInvisibleCharacter(character) {
    return character === " " || character === "\n" || character === "	";
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js
  var LinesDiff = class {
    constructor(changes, moves, hitTimeout) {
      this.changes = changes;
      this.moves = moves;
      this.hitTimeout = hitTimeout;
    }
  };
  var MovedText = class {
    constructor(lineRangeMapping, changes) {
      this.lineRangeMapping = lineRangeMapping;
      this.changes = changes;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js
  var OffsetRange = class _OffsetRange {
    static addRange(range, sortedRanges) {
      let i = 0;
      while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {
        i++;
      }
      let j = i;
      while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {
        j++;
      }
      if (i === j) {
        sortedRanges.splice(i, 0, range);
      } else {
        const start = Math.min(range.start, sortedRanges[i].start);
        const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);
        sortedRanges.splice(i, j - i, new _OffsetRange(start, end));
      }
    }
    static tryCreate(start, endExclusive) {
      if (start > endExclusive) {
        return void 0;
      }
      return new _OffsetRange(start, endExclusive);
    }
    static ofLength(length2) {
      return new _OffsetRange(0, length2);
    }
    static ofStartAndLength(start, length2) {
      return new _OffsetRange(start, start + length2);
    }
    constructor(start, endExclusive) {
      this.start = start;
      this.endExclusive = endExclusive;
      if (start > endExclusive) {
        throw new BugIndicatingError(`Invalid range: ${this.toString()}`);
      }
    }
    get isEmpty() {
      return this.start === this.endExclusive;
    }
    delta(offset) {
      return new _OffsetRange(this.start + offset, this.endExclusive + offset);
    }
    deltaStart(offset) {
      return new _OffsetRange(this.start + offset, this.endExclusive);
    }
    deltaEnd(offset) {
      return new _OffsetRange(this.start, this.endExclusive + offset);
    }
    get length() {
      return this.endExclusive - this.start;
    }
    toString() {
      return `[${this.start}, ${this.endExclusive})`;
    }
    contains(offset) {
      return this.start <= offset && offset < this.endExclusive;
    }
    /**
     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
     * The joined range is the smallest range that contains both ranges.
     */
    join(other) {
      return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
    }
    /**
     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
     *
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
      const start = Math.max(this.start, other.start);
      const end = Math.min(this.endExclusive, other.endExclusive);
      if (start <= end) {
        return new _OffsetRange(start, end);
      }
      return void 0;
    }
    intersects(other) {
      const start = Math.max(this.start, other.start);
      const end = Math.min(this.endExclusive, other.endExclusive);
      return start < end;
    }
    isBefore(other) {
      return this.endExclusive <= other.start;
    }
    isAfter(other) {
      return this.start >= other.endExclusive;
    }
    slice(arr) {
      return arr.slice(this.start, this.endExclusive);
    }
    substring(str) {
      return str.substring(this.start, this.endExclusive);
    }
    /**
     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
     * The range must not be empty.
     */
    clip(value2) {
      if (this.isEmpty) {
        throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
      }
      return Math.max(this.start, Math.min(this.endExclusive - 1, value2));
    }
    /**
     * Returns `r := value + k * length` such that `r` is contained in this range.
     * The range must not be empty.
     *
     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
     */
    clipCyclic(value2) {
      if (this.isEmpty) {
        throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
      }
      if (value2 < this.start) {
        return this.endExclusive - (this.start - value2) % this.length;
      }
      if (value2 >= this.endExclusive) {
        return this.start + (value2 - this.start) % this.length;
      }
      return value2;
    }
    forEach(f2) {
      for (let i = this.start; i < this.endExclusive; i++) {
        f2(i);
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/arraysFind.js
  function findLastMonotonous(array, predicate) {
    const idx = findLastIdxMonotonous(array, predicate);
    return idx === -1 ? void 0 : array[idx];
  }
  function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
    let i = startIdx;
    let j = endIdxEx;
    while (i < j) {
      const k2 = Math.floor((i + j) / 2);
      if (predicate(array[k2])) {
        i = k2 + 1;
      } else {
        j = k2;
      }
    }
    return i - 1;
  }
  function findFirstMonotonous(array, predicate) {
    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);
    return idx === array.length ? void 0 : array[idx];
  }
  function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
    let i = startIdx;
    let j = endIdxEx;
    while (i < j) {
      const k2 = Math.floor((i + j) / 2);
      if (predicate(array[k2])) {
        j = k2;
      } else {
        i = k2 + 1;
      }
    }
    return i;
  }
  var MonotonousArray = class _MonotonousArray {
    constructor(_array) {
      this._array = _array;
      this._findLastMonotonousLastIdx = 0;
    }
    /**
     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
     */
    findLastMonotonous(predicate) {
      if (_MonotonousArray.assertInvariants) {
        if (this._prevFindLastPredicate) {
          for (const item of this._array) {
            if (this._prevFindLastPredicate(item) && !predicate(item)) {
              throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
            }
          }
        }
        this._prevFindLastPredicate = predicate;
      }
      const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);
      this._findLastMonotonousLastIdx = idx + 1;
      return idx === -1 ? void 0 : this._array[idx];
    }
  };
  MonotonousArray.assertInvariants = false;

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js
  var LineRange = class _LineRange {
    static fromRangeInclusive(range) {
      return new _LineRange(range.startLineNumber, range.endLineNumber + 1);
    }
    /**
     * @param lineRanges An array of sorted line ranges.
     */
    static joinMany(lineRanges) {
      if (lineRanges.length === 0) {
        return [];
      }
      let result = new LineRangeSet(lineRanges[0].slice());
      for (let i = 1; i < lineRanges.length; i++) {
        result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));
      }
      return result.ranges;
    }
    static join(lineRanges) {
      if (lineRanges.length === 0) {
        throw new BugIndicatingError("lineRanges cannot be empty");
      }
      let startLineNumber = lineRanges[0].startLineNumber;
      let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;
      for (let i = 1; i < lineRanges.length; i++) {
        startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);
        endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);
      }
      return new _LineRange(startLineNumber, endLineNumberExclusive);
    }
    static ofLength(startLineNumber, length2) {
      return new _LineRange(startLineNumber, startLineNumber + length2);
    }
    /**
     * @internal
     */
    static deserialize(lineRange) {
      return new _LineRange(lineRange[0], lineRange[1]);
    }
    constructor(startLineNumber, endLineNumberExclusive) {
      if (startLineNumber > endLineNumberExclusive) {
        throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
      }
      this.startLineNumber = startLineNumber;
      this.endLineNumberExclusive = endLineNumberExclusive;
    }
    /**
     * Indicates if this line range contains the given line number.
     */
    contains(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Indicates if this line range is empty.
     */
    get isEmpty() {
      return this.startLineNumber === this.endLineNumberExclusive;
    }
    /**
     * Moves this line range by the given offset of line numbers.
     */
    delta(offset) {
      return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
    }
    deltaLength(offset) {
      return new _LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);
    }
    /**
     * The number of lines this line range spans.
     */
    get length() {
      return this.endLineNumberExclusive - this.startLineNumber;
    }
    /**
     * Creates a line range that combines this and the given line range.
     */
    join(other) {
      return new _LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
    }
    toString() {
      return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
    }
    /**
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
      const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
      const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
      if (startLineNumber <= endLineNumberExclusive) {
        return new _LineRange(startLineNumber, endLineNumberExclusive);
      }
      return void 0;
    }
    intersectsStrict(other) {
      return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
    }
    overlapOrTouch(other) {
      return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
    }
    equals(b) {
      return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;
    }
    toInclusiveRange() {
      if (this.isEmpty) {
        return null;
      }
      return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
    }
    /**
     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
    */
    toExclusiveRange() {
      return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
    }
    mapToLineArray(f2) {
      const result = [];
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        result.push(f2(lineNumber));
      }
      return result;
    }
    forEach(f2) {
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        f2(lineNumber);
      }
    }
    /**
     * @internal
     */
    serialize() {
      return [this.startLineNumber, this.endLineNumberExclusive];
    }
    includes(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
     * @internal
     */
    toOffsetRange() {
      return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
    }
  };
  var LineRangeSet = class _LineRangeSet {
    constructor(_normalizedRanges = []) {
      this._normalizedRanges = _normalizedRanges;
    }
    get ranges() {
      return this._normalizedRanges;
    }
    addRange(range) {
      if (range.length === 0) {
        return;
      }
      const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r2) => r2.endLineNumberExclusive >= range.startLineNumber);
      const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r2) => r2.startLineNumber <= range.endLineNumberExclusive) + 1;
      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
        this._normalizedRanges.splice(joinRangeStartIdx, 0, range);
      } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
        const joinRange = this._normalizedRanges[joinRangeStartIdx];
        this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);
      } else {
        const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);
        this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
      }
    }
    contains(lineNumber) {
      const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r2) => r2.startLineNumber <= lineNumber);
      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;
    }
    intersects(range) {
      const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r2) => r2.startLineNumber < range.endLineNumberExclusive);
      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;
    }
    getUnion(other) {
      if (this._normalizedRanges.length === 0) {
        return other;
      }
      if (other._normalizedRanges.length === 0) {
        return this;
      }
      const result = [];
      let i1 = 0;
      let i2 = 0;
      let current = null;
      while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {
        let next = null;
        if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
          const lineRange1 = this._normalizedRanges[i1];
          const lineRange2 = other._normalizedRanges[i2];
          if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
            next = lineRange1;
            i1++;
          } else {
            next = lineRange2;
            i2++;
          }
        } else if (i1 < this._normalizedRanges.length) {
          next = this._normalizedRanges[i1];
          i1++;
        } else {
          next = other._normalizedRanges[i2];
          i2++;
        }
        if (current === null) {
          current = next;
        } else {
          if (current.endLineNumberExclusive >= next.startLineNumber) {
            current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));
          } else {
            result.push(current);
            current = next;
          }
        }
      }
      if (current !== null) {
        result.push(current);
      }
      return new _LineRangeSet(result);
    }
    /**
     * Subtracts all ranges in this set from `range` and returns the result.
     */
    subtractFrom(range) {
      const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r2) => r2.endLineNumberExclusive >= range.startLineNumber);
      const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r2) => r2.startLineNumber <= range.endLineNumberExclusive) + 1;
      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
        return new _LineRangeSet([range]);
      }
      const result = [];
      let startLineNumber = range.startLineNumber;
      for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {
        const r2 = this._normalizedRanges[i];
        if (r2.startLineNumber > startLineNumber) {
          result.push(new LineRange(startLineNumber, r2.startLineNumber));
        }
        startLineNumber = r2.endLineNumberExclusive;
      }
      if (startLineNumber < range.endLineNumberExclusive) {
        result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));
      }
      return new _LineRangeSet(result);
    }
    toString() {
      return this._normalizedRanges.map((r2) => r2.toString()).join(", ");
    }
    getIntersection(other) {
      const result = [];
      let i1 = 0;
      let i2 = 0;
      while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
        const r1 = this._normalizedRanges[i1];
        const r2 = other._normalizedRanges[i2];
        const i = r1.intersect(r2);
        if (i && !i.isEmpty) {
          result.push(i);
        }
        if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {
          i1++;
        } else {
          i2++;
        }
      }
      return new _LineRangeSet(result);
    }
    getWithDelta(value2) {
      return new _LineRangeSet(this._normalizedRanges.map((r2) => r2.delta(value2)));
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js
  var TextLength = class _TextLength {
    static betweenPositions(position1, position2) {
      if (position1.lineNumber === position2.lineNumber) {
        return new _TextLength(0, position2.column - position1.column);
      } else {
        return new _TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);
      }
    }
    static ofRange(range) {
      return _TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());
    }
    static ofText(text2) {
      let line = 0;
      let column = 0;
      for (const c4 of text2) {
        if (c4 === "\n") {
          line++;
          column = 0;
        } else {
          column++;
        }
      }
      return new _TextLength(line, column);
    }
    constructor(lineCount, columnCount) {
      this.lineCount = lineCount;
      this.columnCount = columnCount;
    }
    isGreaterThanOrEqualTo(other) {
      if (this.lineCount !== other.lineCount) {
        return this.lineCount > other.lineCount;
      }
      return this.columnCount >= other.columnCount;
    }
    createRange(startPosition) {
      if (this.lineCount === 0) {
        return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);
      } else {
        return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);
      }
    }
    addToPosition(position2) {
      if (this.lineCount === 0) {
        return new Position(position2.lineNumber, position2.column + this.columnCount);
      } else {
        return new Position(position2.lineNumber + this.lineCount, this.columnCount + 1);
      }
    }
    toString() {
      return `${this.lineCount},${this.columnCount}`;
    }
  };
  TextLength.zero = new TextLength(0, 0);

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js
  var SingleTextEdit = class {
    constructor(range, text2) {
      this.range = range;
      this.text = text2;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js
  var LineRangeMapping = class _LineRangeMapping {
    static inverse(mapping, originalLineCount, modifiedLineCount) {
      const result = [];
      let lastOriginalEndLineNumber = 1;
      let lastModifiedEndLineNumber = 1;
      for (const m of mapping) {
        const r3 = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));
        if (!r3.modified.isEmpty) {
          result.push(r3);
        }
        lastOriginalEndLineNumber = m.original.endLineNumberExclusive;
        lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;
      }
      const r2 = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));
      if (!r2.modified.isEmpty) {
        result.push(r2);
      }
      return result;
    }
    static clip(mapping, originalRange, modifiedRange) {
      const result = [];
      for (const m of mapping) {
        const original = m.original.intersect(originalRange);
        const modified = m.modified.intersect(modifiedRange);
        if (original && !original.isEmpty && modified && !modified.isEmpty) {
          result.push(new _LineRangeMapping(original, modified));
        }
      }
      return result;
    }
    constructor(originalRange, modifiedRange) {
      this.original = originalRange;
      this.modified = modifiedRange;
    }
    toString() {
      return `{${this.original.toString()}->${this.modified.toString()}}`;
    }
    flip() {
      return new _LineRangeMapping(this.modified, this.original);
    }
    join(other) {
      return new _LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
    }
    /**
     * This method assumes that the LineRangeMapping describes a valid diff!
     * I.e. if one range is empty, the other range cannot be the entire document.
     * It avoids various problems when the line range points to non-existing line-numbers.
    */
    toRangeMapping() {
      const origInclusiveRange = this.original.toInclusiveRange();
      const modInclusiveRange = this.modified.toInclusiveRange();
      if (origInclusiveRange && modInclusiveRange) {
        return new RangeMapping(origInclusiveRange, modInclusiveRange);
      } else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
        if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {
          throw new BugIndicatingError("not a valid diff");
        }
        return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
      } else {
        return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
      }
    }
  };
  var DetailedLineRangeMapping = class _DetailedLineRangeMapping extends LineRangeMapping {
    static fromRangeMappings(rangeMappings) {
      const originalRange = LineRange.join(rangeMappings.map((r2) => LineRange.fromRangeInclusive(r2.originalRange)));
      const modifiedRange = LineRange.join(rangeMappings.map((r2) => LineRange.fromRangeInclusive(r2.modifiedRange)));
      return new _DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);
    }
    constructor(originalRange, modifiedRange, innerChanges) {
      super(originalRange, modifiedRange);
      this.innerChanges = innerChanges;
    }
    flip() {
      var _a4;
      return new _DetailedLineRangeMapping(this.modified, this.original, (_a4 = this.innerChanges) === null || _a4 === void 0 ? void 0 : _a4.map((c4) => c4.flip()));
    }
    withInnerChangesFromLineRanges() {
      return new _DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);
    }
  };
  var RangeMapping = class _RangeMapping {
    constructor(originalRange, modifiedRange) {
      this.originalRange = originalRange;
      this.modifiedRange = modifiedRange;
    }
    toString() {
      return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
    }
    flip() {
      return new _RangeMapping(this.modifiedRange, this.originalRange);
    }
    /**
     * Creates a single text edit that describes the change from the original to the modified text.
    */
    toTextEdit(modified) {
      const newText = modified.getValueOfRange(this.modifiedRange);
      return new SingleTextEdit(this.originalRange, newText);
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js
  var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
  var LegacyLinesDiffComputer = class {
    computeDiff(originalLines, modifiedLines, options) {
      var _a4;
      const diffComputer = new DiffComputer(originalLines, modifiedLines, {
        maxComputationTime: options.maxComputationTimeMs,
        shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
        shouldComputeCharChanges: true,
        shouldMakePrettyDiff: true,
        shouldPostProcessCharChanges: true
      });
      const result = diffComputer.computeDiff();
      const changes = [];
      let lastChange = null;
      for (const c4 of result.changes) {
        let originalRange;
        if (c4.originalEndLineNumber === 0) {
          originalRange = new LineRange(c4.originalStartLineNumber + 1, c4.originalStartLineNumber + 1);
        } else {
          originalRange = new LineRange(c4.originalStartLineNumber, c4.originalEndLineNumber + 1);
        }
        let modifiedRange;
        if (c4.modifiedEndLineNumber === 0) {
          modifiedRange = new LineRange(c4.modifiedStartLineNumber + 1, c4.modifiedStartLineNumber + 1);
        } else {
          modifiedRange = new LineRange(c4.modifiedStartLineNumber, c4.modifiedEndLineNumber + 1);
        }
        let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a4 = c4.charChanges) === null || _a4 === void 0 ? void 0 : _a4.map((c5) => new RangeMapping(new Range(c5.originalStartLineNumber, c5.originalStartColumn, c5.originalEndLineNumber, c5.originalEndColumn), new Range(c5.modifiedStartLineNumber, c5.modifiedStartColumn, c5.modifiedEndLineNumber, c5.modifiedEndColumn))));
        if (lastChange) {
          if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {
            change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
            changes.pop();
          }
        }
        changes.push(change);
        lastChange = change;
      }
      assertFn(() => {
        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
        m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
      });
      return new LinesDiff(changes, [], result.quitEarly);
    }
  };
  function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
  }
  var LineSequence = class {
    constructor(lines) {
      const startColumns = [];
      const endColumns = [];
      for (let i = 0, length2 = lines.length; i < length2; i++) {
        startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
        endColumns[i] = getLastNonBlankColumn(lines[i], 1);
      }
      this.lines = lines;
      this._startColumns = startColumns;
      this._endColumns = endColumns;
    }
    getElements() {
      const elements = [];
      for (let i = 0, len = this.lines.length; i < len; i++) {
        elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
      }
      return elements;
    }
    getStrictElement(index2) {
      return this.lines[index2];
    }
    getStartLineNumber(i) {
      return i + 1;
    }
    getEndLineNumber(i) {
      return i + 1;
    }
    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
      const charCodes = [];
      const lineNumbers = [];
      const columns = [];
      let len = 0;
      for (let index2 = startIndex; index2 <= endIndex; index2++) {
        const lineContent = this.lines[index2];
        const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index2] : 1;
        const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index2] : lineContent.length + 1;
        for (let col = startColumn; col < endColumn; col++) {
          charCodes[len] = lineContent.charCodeAt(col - 1);
          lineNumbers[len] = index2 + 1;
          columns[len] = col;
          len++;
        }
        if (!shouldIgnoreTrimWhitespace && index2 < endIndex) {
          charCodes[len] = 10;
          lineNumbers[len] = index2 + 1;
          columns[len] = lineContent.length + 1;
          len++;
        }
      }
      return new CharSequence(charCodes, lineNumbers, columns);
    }
  };
  var CharSequence = class {
    constructor(charCodes, lineNumbers, columns) {
      this._charCodes = charCodes;
      this._lineNumbers = lineNumbers;
      this._columns = columns;
    }
    toString() {
      return "[" + this._charCodes.map((s2, idx) => (s2 === 10 ? "\\n" : String.fromCharCode(s2)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
    }
    _assertIndex(index2, arr) {
      if (index2 < 0 || index2 >= arr.length) {
        throw new Error(`Illegal index`);
      }
    }
    getElements() {
      return this._charCodes;
    }
    getStartLineNumber(i) {
      if (i > 0 && i === this._lineNumbers.length) {
        return this.getEndLineNumber(i - 1);
      }
      this._assertIndex(i, this._lineNumbers);
      return this._lineNumbers[i];
    }
    getEndLineNumber(i) {
      if (i === -1) {
        return this.getStartLineNumber(i + 1);
      }
      this._assertIndex(i, this._lineNumbers);
      if (this._charCodes[i] === 10) {
        return this._lineNumbers[i] + 1;
      }
      return this._lineNumbers[i];
    }
    getStartColumn(i) {
      if (i > 0 && i === this._columns.length) {
        return this.getEndColumn(i - 1);
      }
      this._assertIndex(i, this._columns);
      return this._columns[i];
    }
    getEndColumn(i) {
      if (i === -1) {
        return this.getStartColumn(i + 1);
      }
      this._assertIndex(i, this._columns);
      if (this._charCodes[i] === 10) {
        return 1;
      }
      return this._columns[i] + 1;
    }
  };
  var CharChange = class _CharChange {
    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalStartColumn = originalStartColumn;
      this.originalEndLineNumber = originalEndLineNumber;
      this.originalEndColumn = originalEndColumn;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedStartColumn = modifiedStartColumn;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.modifiedEndColumn = modifiedEndColumn;
    }
    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
      const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
      const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
      const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
      const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
      const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
    }
  };
  function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
      return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i = 1, len = rawChanges.length; i < len; i++) {
      const currChange = rawChanges[i];
      const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
      const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
      const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
      if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
        prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
        prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
      } else {
        result.push(currChange);
        prevChange = currChange;
      }
    }
    return result;
  }
  var LineChange = class _LineChange {
    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalEndLineNumber = originalEndLineNumber;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.charChanges = charChanges;
    }
    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
      let originalStartLineNumber;
      let originalEndLineNumber;
      let modifiedStartLineNumber;
      let modifiedEndLineNumber;
      let charChanges = void 0;
      if (diffChange.originalLength === 0) {
        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
        originalEndLineNumber = 0;
      } else {
        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
        originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      }
      if (diffChange.modifiedLength === 0) {
        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
        modifiedEndLineNumber = 0;
      } else {
        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
        modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      }
      if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
        const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
        const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
        if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
          let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
          if (shouldPostProcessCharChanges) {
            rawChanges = postProcessCharChanges(rawChanges);
          }
          charChanges = [];
          for (let i = 0, length2 = rawChanges.length; i < length2; i++) {
            charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
          }
        }
      }
      return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
    }
  };
  var DiffComputer = class {
    constructor(originalLines, modifiedLines, opts) {
      this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
      this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
      this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
      this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
      this.originalLines = originalLines;
      this.modifiedLines = modifiedLines;
      this.original = new LineSequence(originalLines);
      this.modified = new LineSequence(modifiedLines);
      this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
      this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
    }
    computeDiff() {
      if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
          return {
            quitEarly: false,
            changes: []
          };
        }
        return {
          quitEarly: false,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: 1,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: this.modified.lines.length,
            charChanges: void 0
          }]
        };
      }
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
        return {
          quitEarly: false,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: this.original.lines.length,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: 1,
            charChanges: void 0
          }]
        };
      }
      const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
      const rawChanges = diffResult.changes;
      const quitEarly = diffResult.quitEarly;
      if (this.shouldIgnoreTrimWhitespace) {
        const lineChanges = [];
        for (let i = 0, length2 = rawChanges.length; i < length2; i++) {
          lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        }
        return {
          quitEarly,
          changes: lineChanges
        };
      }
      const result = [];
      let originalLineIndex = 0;
      let modifiedLineIndex = 0;
      for (let i = -1, len = rawChanges.length; i < len; i++) {
        const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
        const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
        const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
        while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
          const originalLine = this.originalLines[originalLineIndex];
          const modifiedLine = this.modifiedLines[modifiedLineIndex];
          if (originalLine !== modifiedLine) {
            {
              let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
              let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
              while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                if (originalChar !== modifiedChar) {
                  break;
                }
                originalStartColumn--;
                modifiedStartColumn--;
              }
              if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
              }
            }
            {
              let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
              let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
              const originalMaxColumn = originalLine.length + 1;
              const modifiedMaxColumn = modifiedLine.length + 1;
              while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                if (originalChar !== modifiedChar) {
                  break;
                }
                originalEndColumn++;
                modifiedEndColumn++;
              }
              if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
              }
            }
          }
          originalLineIndex++;
          modifiedLineIndex++;
        }
        if (nextChange) {
          result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
          originalLineIndex += nextChange.originalLength;
          modifiedLineIndex += nextChange.modifiedLength;
        }
      }
      return {
        quitEarly,
        changes: result
      };
    }
    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
        return;
      }
      let charChanges = void 0;
      if (this.shouldComputeCharChanges) {
        charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
      }
      result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
    }
    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      const len = result.length;
      if (len === 0) {
        return false;
      }
      const prevChange = result[len - 1];
      if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
        return false;
      }
      if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
        if (this.shouldComputeCharChanges && prevChange.charChanges) {
          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
        }
        return true;
      }
      if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
        prevChange.originalEndLineNumber = originalLineNumber;
        prevChange.modifiedEndLineNumber = modifiedLineNumber;
        if (this.shouldComputeCharChanges && prevChange.charChanges) {
          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
        }
        return true;
      }
      return false;
    }
  };
  function getFirstNonBlankColumn(txt, defaultValue) {
    const r2 = firstNonWhitespaceIndex(txt);
    if (r2 === -1) {
      return defaultValue;
    }
    return r2 + 1;
  }
  function getLastNonBlankColumn(txt, defaultValue) {
    const r2 = lastNonWhitespaceIndex(txt);
    if (r2 === -1) {
      return defaultValue;
    }
    return r2 + 2;
  }
  function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
      return () => true;
    }
    const startTime = Date.now();
    return () => {
      return Date.now() - startTime < maximumRuntime;
    };
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js
  var DiffAlgorithmResult = class _DiffAlgorithmResult {
    static trivial(seq1, seq2) {
      return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);
    }
    static trivialTimedOut(seq1, seq2) {
      return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);
    }
    constructor(diffs, hitTimeout) {
      this.diffs = diffs;
      this.hitTimeout = hitTimeout;
    }
  };
  var SequenceDiff = class _SequenceDiff {
    static invert(sequenceDiffs, doc1Length) {
      const result = [];
      forEachAdjacent(sequenceDiffs, (a, b) => {
        result.push(_SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));
      });
      return result;
    }
    static fromOffsetPairs(start, endExclusive) {
      return new _SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));
    }
    constructor(seq1Range, seq2Range) {
      this.seq1Range = seq1Range;
      this.seq2Range = seq2Range;
    }
    swap() {
      return new _SequenceDiff(this.seq2Range, this.seq1Range);
    }
    toString() {
      return `${this.seq1Range} <-> ${this.seq2Range}`;
    }
    join(other) {
      return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
    }
    delta(offset) {
      if (offset === 0) {
        return this;
      }
      return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));
    }
    deltaStart(offset) {
      if (offset === 0) {
        return this;
      }
      return new _SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));
    }
    deltaEnd(offset) {
      if (offset === 0) {
        return this;
      }
      return new _SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));
    }
    intersect(other) {
      const i1 = this.seq1Range.intersect(other.seq1Range);
      const i2 = this.seq2Range.intersect(other.seq2Range);
      if (!i1 || !i2) {
        return void 0;
      }
      return new _SequenceDiff(i1, i2);
    }
    getStarts() {
      return new OffsetPair(this.seq1Range.start, this.seq2Range.start);
    }
    getEndExclusives() {
      return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
    }
  };
  var OffsetPair = class _OffsetPair {
    constructor(offset1, offset2) {
      this.offset1 = offset1;
      this.offset2 = offset2;
    }
    toString() {
      return `${this.offset1} <-> ${this.offset2}`;
    }
    delta(offset) {
      if (offset === 0) {
        return this;
      }
      return new _OffsetPair(this.offset1 + offset, this.offset2 + offset);
    }
    equals(other) {
      return this.offset1 === other.offset1 && this.offset2 === other.offset2;
    }
  };
  OffsetPair.zero = new OffsetPair(0, 0);
  OffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  var InfiniteTimeout = class {
    isValid() {
      return true;
    }
  };
  InfiniteTimeout.instance = new InfiniteTimeout();
  var DateTimeout = class {
    constructor(timeout) {
      this.timeout = timeout;
      this.startTime = Date.now();
      this.valid = true;
      if (timeout <= 0) {
        throw new BugIndicatingError("timeout must be positive");
      }
    }
    // Recommendation: Set a log-point `{this.disable()}` in the body
    isValid() {
      const valid = Date.now() - this.startTime < this.timeout;
      if (!valid && this.valid) {
        this.valid = false;
        debugger;
      }
      return this.valid;
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js
  var Array2D = class {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.array = [];
      this.array = new Array(width * height);
    }
    get(x, y) {
      return this.array[x + y * this.width];
    }
    set(x, y, value2) {
      this.array[x + y * this.width] = value2;
    }
  };
  function isSpace(charCode) {
    return charCode === 32 || charCode === 9;
  }
  var LineRangeFragment = class _LineRangeFragment {
    static getKey(chr) {
      let key = this.chrKeys.get(chr);
      if (key === void 0) {
        key = this.chrKeys.size;
        this.chrKeys.set(chr, key);
      }
      return key;
    }
    constructor(range, lines, source) {
      this.range = range;
      this.lines = lines;
      this.source = source;
      this.histogram = [];
      let counter = 0;
      for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {
        const line = lines[i];
        for (let j = 0; j < line.length; j++) {
          counter++;
          const chr = line[j];
          const key2 = _LineRangeFragment.getKey(chr);
          this.histogram[key2] = (this.histogram[key2] || 0) + 1;
        }
        counter++;
        const key = _LineRangeFragment.getKey("\n");
        this.histogram[key] = (this.histogram[key] || 0) + 1;
      }
      this.totalCount = counter;
    }
    computeSimilarity(other) {
      var _a4, _b3;
      let sumDifferences = 0;
      const maxLength = Math.max(this.histogram.length, other.histogram.length);
      for (let i = 0; i < maxLength; i++) {
        sumDifferences += Math.abs(((_a4 = this.histogram[i]) !== null && _a4 !== void 0 ? _a4 : 0) - ((_b3 = other.histogram[i]) !== null && _b3 !== void 0 ? _b3 : 0));
      }
      return 1 - sumDifferences / (this.totalCount + other.totalCount);
    }
  };
  LineRangeFragment.chrKeys = /* @__PURE__ */ new Map();

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js
  var DynamicProgrammingDiffing = class {
    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {
      if (sequence1.length === 0 || sequence2.length === 0) {
        return DiffAlgorithmResult.trivial(sequence1, sequence2);
      }
      const lcsLengths = new Array2D(sequence1.length, sequence2.length);
      const directions = new Array2D(sequence1.length, sequence2.length);
      const lengths = new Array2D(sequence1.length, sequence2.length);
      for (let s12 = 0; s12 < sequence1.length; s12++) {
        for (let s22 = 0; s22 < sequence2.length; s22++) {
          if (!timeout.isValid()) {
            return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
          }
          const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);
          const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);
          let extendedSeqScore;
          if (sequence1.getElement(s12) === sequence2.getElement(s22)) {
            if (s12 === 0 || s22 === 0) {
              extendedSeqScore = 0;
            } else {
              extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);
            }
            if (s12 > 0 && s22 > 0 && directions.get(s12 - 1, s22 - 1) === 3) {
              extendedSeqScore += lengths.get(s12 - 1, s22 - 1);
            }
            extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;
          } else {
            extendedSeqScore = -1;
          }
          const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
          if (newValue === extendedSeqScore) {
            const prevLen = s12 > 0 && s22 > 0 ? lengths.get(s12 - 1, s22 - 1) : 0;
            lengths.set(s12, s22, prevLen + 1);
            directions.set(s12, s22, 3);
          } else if (newValue === horizontalLen) {
            lengths.set(s12, s22, 0);
            directions.set(s12, s22, 1);
          } else if (newValue === verticalLen) {
            lengths.set(s12, s22, 0);
            directions.set(s12, s22, 2);
          }
          lcsLengths.set(s12, s22, newValue);
        }
      }
      const result = [];
      let lastAligningPosS1 = sequence1.length;
      let lastAligningPosS2 = sequence2.length;
      function reportDecreasingAligningPositions(s12, s22) {
        if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {
          result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));
        }
        lastAligningPosS1 = s12;
        lastAligningPosS2 = s22;
      }
      let s1 = sequence1.length - 1;
      let s2 = sequence2.length - 1;
      while (s1 >= 0 && s2 >= 0) {
        if (directions.get(s1, s2) === 3) {
          reportDecreasingAligningPositions(s1, s2);
          s1--;
          s2--;
        } else {
          if (directions.get(s1, s2) === 1) {
            s1--;
          } else {
            s2--;
          }
        }
      }
      reportDecreasingAligningPositions(-1, -1);
      result.reverse();
      return new DiffAlgorithmResult(result, false);
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js
  var MyersDiffAlgorithm = class {
    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {
      if (seq1.length === 0 || seq2.length === 0) {
        return DiffAlgorithmResult.trivial(seq1, seq2);
      }
      const seqX = seq1;
      const seqY = seq2;
      function getXAfterSnake(x, y) {
        while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {
          x++;
          y++;
        }
        return x;
      }
      let d = 0;
      const V = new FastInt32Array();
      V.set(0, getXAfterSnake(0, 0));
      const paths = new FastArrayNegativeIndices();
      paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));
      let k2 = 0;
      loop:
        while (true) {
          d++;
          if (!timeout.isValid()) {
            return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);
          }
          const lowerBound = -Math.min(d, seqY.length + d % 2);
          const upperBound = Math.min(d, seqX.length + d % 2);
          for (k2 = lowerBound; k2 <= upperBound; k2 += 2) {
            let step = 0;
            const maxXofDLineTop = k2 === upperBound ? -1 : V.get(k2 + 1);
            const maxXofDLineLeft = k2 === lowerBound ? -1 : V.get(k2 - 1) + 1;
            step++;
            const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);
            const y = x - k2;
            step++;
            if (x > seqX.length || y > seqY.length) {
              continue;
            }
            const newMaxX = getXAfterSnake(x, y);
            V.set(k2, newMaxX);
            const lastPath = x === maxXofDLineTop ? paths.get(k2 + 1) : paths.get(k2 - 1);
            paths.set(k2, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);
            if (V.get(k2) === seqX.length && V.get(k2) - k2 === seqY.length) {
              break loop;
            }
          }
        }
      let path = paths.get(k2);
      const result = [];
      let lastAligningPosS1 = seqX.length;
      let lastAligningPosS2 = seqY.length;
      while (true) {
        const endX = path ? path.x + path.length : 0;
        const endY = path ? path.y + path.length : 0;
        if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
          result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));
        }
        if (!path) {
          break;
        }
        lastAligningPosS1 = path.x;
        lastAligningPosS2 = path.y;
        path = path.prev;
      }
      result.reverse();
      return new DiffAlgorithmResult(result, false);
    }
  };
  var SnakePath = class {
    constructor(prev, x, y, length2) {
      this.prev = prev;
      this.x = x;
      this.y = y;
      this.length = length2;
    }
  };
  var FastInt32Array = class {
    constructor() {
      this.positiveArr = new Int32Array(10);
      this.negativeArr = new Int32Array(10);
    }
    get(idx) {
      if (idx < 0) {
        idx = -idx - 1;
        return this.negativeArr[idx];
      } else {
        return this.positiveArr[idx];
      }
    }
    set(idx, value2) {
      if (idx < 0) {
        idx = -idx - 1;
        if (idx >= this.negativeArr.length) {
          const arr = this.negativeArr;
          this.negativeArr = new Int32Array(arr.length * 2);
          this.negativeArr.set(arr);
        }
        this.negativeArr[idx] = value2;
      } else {
        if (idx >= this.positiveArr.length) {
          const arr = this.positiveArr;
          this.positiveArr = new Int32Array(arr.length * 2);
          this.positiveArr.set(arr);
        }
        this.positiveArr[idx] = value2;
      }
    }
  };
  var FastArrayNegativeIndices = class {
    constructor() {
      this.positiveArr = [];
      this.negativeArr = [];
    }
    get(idx) {
      if (idx < 0) {
        idx = -idx - 1;
        return this.negativeArr[idx];
      } else {
        return this.positiveArr[idx];
      }
    }
    set(idx, value2) {
      if (idx < 0) {
        idx = -idx - 1;
        this.negativeArr[idx] = value2;
      } else {
        this.positiveArr[idx] = value2;
      }
    }
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js
  var LinesSliceCharSequence = class {
    constructor(lines, lineRange, considerWhitespaceChanges) {
      this.lines = lines;
      this.considerWhitespaceChanges = considerWhitespaceChanges;
      this.elements = [];
      this.firstCharOffsetByLine = [];
      this.additionalOffsetByLine = [];
      let trimFirstLineFully = false;
      if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {
        lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);
        trimFirstLineFully = true;
      }
      this.lineRange = lineRange;
      this.firstCharOffsetByLine[0] = 0;
      for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {
        let line = lines[i];
        let offset = 0;
        if (trimFirstLineFully) {
          offset = line.length;
          line = "";
          trimFirstLineFully = false;
        } else if (!considerWhitespaceChanges) {
          const trimmedStartLine = line.trimStart();
          offset = line.length - trimmedStartLine.length;
          line = trimmedStartLine.trimEnd();
        }
        this.additionalOffsetByLine.push(offset);
        for (let i2 = 0; i2 < line.length; i2++) {
          this.elements.push(line.charCodeAt(i2));
        }
        if (i < lines.length - 1) {
          this.elements.push("\n".charCodeAt(0));
          this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;
        }
      }
      this.additionalOffsetByLine.push(0);
    }
    toString() {
      return `Slice: "${this.text}"`;
    }
    get text() {
      return this.getText(new OffsetRange(0, this.length));
    }
    getText(range) {
      return this.elements.slice(range.start, range.endExclusive).map((e2) => String.fromCharCode(e2)).join("");
    }
    getElement(offset) {
      return this.elements[offset];
    }
    get length() {
      return this.elements.length;
    }
    getBoundaryScore(length2) {
      const prevCategory = getCategory(length2 > 0 ? this.elements[length2 - 1] : -1);
      const nextCategory = getCategory(length2 < this.elements.length ? this.elements[length2] : -1);
      if (prevCategory === 7 && nextCategory === 8) {
        return 0;
      }
      if (prevCategory === 8) {
        return 150;
      }
      let score2 = 0;
      if (prevCategory !== nextCategory) {
        score2 += 10;
        if (prevCategory === 0 && nextCategory === 1) {
          score2 += 1;
        }
      }
      score2 += getCategoryBoundaryScore(prevCategory);
      score2 += getCategoryBoundaryScore(nextCategory);
      return score2;
    }
    translateOffset(offset) {
      if (this.lineRange.isEmpty) {
        return new Position(this.lineRange.start + 1, 1);
      }
      const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value2) => value2 <= offset);
      return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);
    }
    translateRange(range) {
      return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));
    }
    /**
     * Finds the word that contains the character at the given offset
     */
    findWordContaining(offset) {
      if (offset < 0 || offset >= this.elements.length) {
        return void 0;
      }
      if (!isWordChar(this.elements[offset])) {
        return void 0;
      }
      let start = offset;
      while (start > 0 && isWordChar(this.elements[start - 1])) {
        start--;
      }
      let end = offset;
      while (end < this.elements.length && isWordChar(this.elements[end])) {
        end++;
      }
      return new OffsetRange(start, end);
    }
    countLinesIn(range) {
      return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;
    }
    isStronglyEqual(offset1, offset2) {
      return this.elements[offset1] === this.elements[offset2];
    }
    extendToFullLines(range) {
      var _a4, _b3;
      const start = (_a4 = findLastMonotonous(this.firstCharOffsetByLine, (x) => x <= range.start)) !== null && _a4 !== void 0 ? _a4 : 0;
      const end = (_b3 = findFirstMonotonous(this.firstCharOffsetByLine, (x) => range.endExclusive <= x)) !== null && _b3 !== void 0 ? _b3 : this.elements.length;
      return new OffsetRange(start, end);
    }
  };
  function isWordChar(charCode) {
    return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
  }
  var score = {
    [
      0
      /* CharBoundaryCategory.WordLower */
    ]: 0,
    [
      1
      /* CharBoundaryCategory.WordUpper */
    ]: 0,
    [
      2
      /* CharBoundaryCategory.WordNumber */
    ]: 0,
    [
      3
      /* CharBoundaryCategory.End */
    ]: 10,
    [
      4
      /* CharBoundaryCategory.Other */
    ]: 2,
    [
      5
      /* CharBoundaryCategory.Separator */
    ]: 30,
    [
      6
      /* CharBoundaryCategory.Space */
    ]: 3,
    [
      7
      /* CharBoundaryCategory.LineBreakCR */
    ]: 10,
    [
      8
      /* CharBoundaryCategory.LineBreakLF */
    ]: 10
  };
  function getCategoryBoundaryScore(category) {
    return score[category];
  }
  function getCategory(charCode) {
    if (charCode === 10) {
      return 8;
    } else if (charCode === 13) {
      return 7;
    } else if (isSpace(charCode)) {
      return 6;
    } else if (charCode >= 97 && charCode <= 122) {
      return 0;
    } else if (charCode >= 65 && charCode <= 90) {
      return 1;
    } else if (charCode >= 48 && charCode <= 57) {
      return 2;
    } else if (charCode === -1) {
      return 3;
    } else if (charCode === 44 || charCode === 59) {
      return 5;
    } else {
      return 4;
    }
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js
  function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {
    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);
    if (!timeout.isValid()) {
      return [];
    }
    const filteredChanges = changes.filter((c4) => !excludedChanges.has(c4));
    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);
    pushMany(moves, unchangedMoves);
    moves = joinCloseConsecutiveMoves(moves);
    moves = moves.filter((current) => {
      const lines = current.original.toOffsetRange().slice(originalLines).map((l) => l.trim());
      const originalText = lines.join("\n");
      return originalText.length >= 15 && countWhere(lines, (l) => l.length >= 2) >= 2;
    });
    moves = removeMovesInSameDiff(changes, moves);
    return moves;
  }
  function countWhere(arr, predicate) {
    let count = 0;
    for (const t of arr) {
      if (predicate(t)) {
        count++;
      }
    }
    return count;
  }
  function computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {
    const moves = [];
    const deletions = changes.filter((c4) => c4.modified.isEmpty && c4.original.length >= 3).map((d) => new LineRangeFragment(d.original, originalLines, d));
    const insertions = new Set(changes.filter((c4) => c4.original.isEmpty && c4.modified.length >= 3).map((d) => new LineRangeFragment(d.modified, modifiedLines, d)));
    const excludedChanges = /* @__PURE__ */ new Set();
    for (const deletion of deletions) {
      let highestSimilarity = -1;
      let best;
      for (const insertion of insertions) {
        const similarity = deletion.computeSimilarity(insertion);
        if (similarity > highestSimilarity) {
          highestSimilarity = similarity;
          best = insertion;
        }
      }
      if (highestSimilarity > 0.9 && best) {
        insertions.delete(best);
        moves.push(new LineRangeMapping(deletion.range, best.range));
        excludedChanges.add(deletion.source);
        excludedChanges.add(best.source);
      }
      if (!timeout.isValid()) {
        return { moves, excludedChanges };
      }
    }
    return { moves, excludedChanges };
  }
  function computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {
    const moves = [];
    const original3LineHashes = new SetMap();
    for (const change of changes) {
      for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {
        const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;
        original3LineHashes.add(key, { range: new LineRange(i, i + 3) });
      }
    }
    const possibleMappings = [];
    changes.sort(compareBy((c4) => c4.modified.startLineNumber, numberComparator));
    for (const change of changes) {
      let lastMappings = [];
      for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {
        const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;
        const currentModifiedRange = new LineRange(i, i + 3);
        const nextMappings = [];
        original3LineHashes.forEach(key, ({ range }) => {
          for (const lastMapping of lastMappings) {
            if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
              lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);
              lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
              nextMappings.push(lastMapping);
              return;
            }
          }
          const mapping = {
            modifiedLineRange: currentModifiedRange,
            originalLineRange: range
          };
          possibleMappings.push(mapping);
          nextMappings.push(mapping);
        });
        lastMappings = nextMappings;
      }
      if (!timeout.isValid()) {
        return [];
      }
    }
    possibleMappings.sort(reverseOrder(compareBy((m) => m.modifiedLineRange.length, numberComparator)));
    const modifiedSet = new LineRangeSet();
    const originalSet = new LineRangeSet();
    for (const mapping of possibleMappings) {
      const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
      const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);
      const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);
      const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);
      for (const s2 of modifiedIntersectedSections.ranges) {
        if (s2.length < 3) {
          continue;
        }
        const modifiedLineRange = s2;
        const originalLineRange = s2.delta(-diffOrigToMod);
        moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));
        modifiedSet.addRange(modifiedLineRange);
        originalSet.addRange(originalLineRange);
      }
    }
    moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
    const monotonousChanges = new MonotonousArray(changes);
    for (let i = 0; i < moves.length; i++) {
      const move = moves[i];
      const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous((c4) => c4.original.startLineNumber <= move.original.startLineNumber);
      const firstTouchingChangeMod = findLastMonotonous(changes, (c4) => c4.modified.startLineNumber <= move.modified.startLineNumber);
      const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);
      const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous((c4) => c4.original.startLineNumber < move.original.endLineNumberExclusive);
      const lastTouchingChangeMod = findLastMonotonous(changes, (c4) => c4.modified.startLineNumber < move.modified.endLineNumberExclusive);
      const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);
      let extendToTop;
      for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {
        const origLine = move.original.startLineNumber - extendToTop - 1;
        const modLine = move.modified.startLineNumber - extendToTop - 1;
        if (origLine > originalLines.length || modLine > modifiedLines.length) {
          break;
        }
        if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
          break;
        }
        if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
          break;
        }
      }
      if (extendToTop > 0) {
        originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));
        modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));
      }
      let extendToBottom;
      for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {
        const origLine = move.original.endLineNumberExclusive + extendToBottom;
        const modLine = move.modified.endLineNumberExclusive + extendToBottom;
        if (origLine > originalLines.length || modLine > modifiedLines.length) {
          break;
        }
        if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
          break;
        }
        if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
          break;
        }
      }
      if (extendToBottom > 0) {
        originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));
        modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));
      }
      if (extendToTop > 0 || extendToBottom > 0) {
        moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));
      }
    }
    return moves;
  }
  function areLinesSimilar(line1, line2, timeout) {
    if (line1.trim() === line2.trim()) {
      return true;
    }
    if (line1.length > 300 && line2.length > 300) {
      return false;
    }
    const myersDiffingAlgorithm = new MyersDiffAlgorithm();
    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);
    let commonNonSpaceCharCount = 0;
    const inverted = SequenceDiff.invert(result.diffs, line1.length);
    for (const seq of inverted) {
      seq.seq1Range.forEach((idx) => {
        if (!isSpace(line1.charCodeAt(idx))) {
          commonNonSpaceCharCount++;
        }
      });
    }
    function countNonWsChars(str) {
      let count = 0;
      for (let i = 0; i < line1.length; i++) {
        if (!isSpace(str.charCodeAt(i))) {
          count++;
        }
      }
      return count;
    }
    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);
    const r2 = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;
    return r2;
  }
  function joinCloseConsecutiveMoves(moves) {
    if (moves.length === 0) {
      return moves;
    }
    moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
    const result = [moves[0]];
    for (let i = 1; i < moves.length; i++) {
      const last = result[result.length - 1];
      const current = moves[i];
      const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;
      const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;
      const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;
      if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {
        result[result.length - 1] = last.join(current);
        continue;
      }
      result.push(current);
    }
    return result;
  }
  function removeMovesInSameDiff(changes, moves) {
    const changesMonotonous = new MonotonousArray(changes);
    moves = moves.filter((m) => {
      const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous((c4) => c4.original.startLineNumber < m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));
      const diffBeforeEndOfMoveModified = findLastMonotonous(changes, (c4) => c4.modified.startLineNumber < m.modified.endLineNumberExclusive);
      const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;
      return differentDiffs;
    });
    return moves;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js
  function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    let result = sequenceDiffs;
    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
    result = shiftSequenceDiffs(sequence1, sequence2, result);
    return result;
  }
  function joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {
    if (sequenceDiffs.length === 0) {
      return sequenceDiffs;
    }
    const result = [];
    result.push(sequenceDiffs[0]);
    for (let i = 1; i < sequenceDiffs.length; i++) {
      const prevResult = result[result.length - 1];
      let cur = sequenceDiffs[i];
      if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
        const length2 = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
        let d;
        for (d = 1; d <= length2; d++) {
          if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {
            break;
          }
        }
        d--;
        if (d === length2) {
          result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length2), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length2));
          continue;
        }
        cur = cur.delta(-d);
      }
      result.push(cur);
    }
    const result2 = [];
    for (let i = 0; i < result.length - 1; i++) {
      const nextResult = result[i + 1];
      let cur = result[i];
      if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
        const length2 = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
        let d;
        for (d = 0; d < length2; d++) {
          if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) || !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {
            break;
          }
        }
        if (d === length2) {
          result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length2, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length2, nextResult.seq2Range.endExclusive));
          continue;
        }
        if (d > 0) {
          cur = cur.delta(d);
        }
      }
      result2.push(cur);
    }
    if (result.length > 0) {
      result2.push(result[result.length - 1]);
    }
    return result2;
  }
  function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
      return sequenceDiffs;
    }
    for (let i = 0; i < sequenceDiffs.length; i++) {
      const prevDiff = i > 0 ? sequenceDiffs[i - 1] : void 0;
      const diff = sequenceDiffs[i];
      const nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : void 0;
      const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);
      const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);
      if (diff.seq1Range.isEmpty) {
        sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
      } else if (diff.seq2Range.isEmpty) {
        sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();
      }
    }
    return sequenceDiffs;
  }
  function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
    const maxShiftLimit = 100;
    let deltaBefore = 1;
    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
      deltaBefore++;
    }
    deltaBefore--;
    let deltaAfter = 0;
    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
      deltaAfter++;
    }
    if (deltaBefore === 0 && deltaAfter === 0) {
      return diff;
    }
    let bestDelta = 0;
    let bestScore = -1;
    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
      const seq2OffsetStart = diff.seq2Range.start + delta;
      const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
      const seq1Offset = diff.seq1Range.start + delta;
      const score2 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
      if (score2 > bestScore) {
        bestScore = score2;
        bestDelta = delta;
      }
    }
    return diff.delta(bestDelta);
  }
  function removeShortMatches(sequence1, sequence2, sequenceDiffs) {
    const result = [];
    for (const s2 of sequenceDiffs) {
      const last = result[result.length - 1];
      if (!last) {
        result.push(s2);
        continue;
      }
      if (s2.seq1Range.start - last.seq1Range.endExclusive <= 2 || s2.seq2Range.start - last.seq2Range.endExclusive <= 2) {
        result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s2.seq1Range), last.seq2Range.join(s2.seq2Range));
      } else {
        result.push(s2);
      }
    }
    return result;
  }
  function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {
    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);
    const additional = [];
    let lastPoint = new OffsetPair(0, 0);
    function scanWord(pair, equalMapping) {
      if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {
        return;
      }
      const w1 = sequence1.findWordContaining(pair.offset1);
      const w2 = sequence2.findWordContaining(pair.offset2);
      if (!w1 || !w2) {
        return;
      }
      let w = new SequenceDiff(w1, w2);
      const equalPart = w.intersect(equalMapping);
      let equalChars1 = equalPart.seq1Range.length;
      let equalChars2 = equalPart.seq2Range.length;
      while (equalMappings.length > 0) {
        const next = equalMappings[0];
        const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);
        if (!intersects) {
          break;
        }
        const v1 = sequence1.findWordContaining(next.seq1Range.start);
        const v2 = sequence2.findWordContaining(next.seq2Range.start);
        const v = new SequenceDiff(v1, v2);
        const equalPart2 = v.intersect(next);
        equalChars1 += equalPart2.seq1Range.length;
        equalChars2 += equalPart2.seq2Range.length;
        w = w.join(v);
        if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {
          equalMappings.shift();
        } else {
          break;
        }
      }
      if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {
        additional.push(w);
      }
      lastPoint = w.getEndExclusives();
    }
    while (equalMappings.length > 0) {
      const next = equalMappings.shift();
      if (next.seq1Range.isEmpty) {
        continue;
      }
      scanWord(next.getStarts(), next);
      scanWord(next.getEndExclusives().delta(-1), next);
    }
    const merged = mergeSequenceDiffs(sequenceDiffs, additional);
    return merged;
  }
  function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
    const result = [];
    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
      const sd1 = sequenceDiffs1[0];
      const sd2 = sequenceDiffs2[0];
      let next;
      if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
        next = sequenceDiffs1.shift();
      } else {
        next = sequenceDiffs2.shift();
      }
      if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
        result[result.length - 1] = result[result.length - 1].join(next);
      } else {
        result.push(next);
      }
    }
    return result;
  }
  function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {
    let diffs = sequenceDiffs;
    if (diffs.length === 0) {
      return diffs;
    }
    let counter = 0;
    let shouldRepeat;
    do {
      shouldRepeat = false;
      const result = [
        diffs[0]
      ];
      for (let i = 1; i < diffs.length; i++) {
        let shouldJoinDiffs = function(before, after) {
          const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
          const unchangedText = sequence1.getText(unchangedRange);
          const unchangedTextWithoutWs = unchangedText.replace(/\s/g, "");
          if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {
            return true;
          }
          return false;
        };
        const cur = diffs[i];
        const lastResult = result[result.length - 1];
        const shouldJoin = shouldJoinDiffs(lastResult, cur);
        if (shouldJoin) {
          shouldRepeat = true;
          result[result.length - 1] = result[result.length - 1].join(cur);
        } else {
          result.push(cur);
        }
      }
      diffs = result;
    } while (counter++ < 10 && shouldRepeat);
    return diffs;
  }
  function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {
    let diffs = sequenceDiffs;
    if (diffs.length === 0) {
      return diffs;
    }
    let counter = 0;
    let shouldRepeat;
    do {
      shouldRepeat = false;
      const result = [
        diffs[0]
      ];
      for (let i = 1; i < diffs.length; i++) {
        let shouldJoinDiffs = function(before, after) {
          const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
          const unchangedLineCount = sequence1.countLinesIn(unchangedRange);
          if (unchangedLineCount > 5 || unchangedRange.length > 500) {
            return false;
          }
          const unchangedText = sequence1.getText(unchangedRange).trim();
          if (unchangedText.length > 20 || unchangedText.split(/\r\n|\r|\n/).length > 1) {
            return false;
          }
          const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);
          const beforeSeq1Length = before.seq1Range.length;
          const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);
          const beforeSeq2Length = before.seq2Range.length;
          const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);
          const afterSeq1Length = after.seq1Range.length;
          const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);
          const afterSeq2Length = after.seq2Range.length;
          const max2 = 2 * 40 + 50;
          function cap(v) {
            return Math.min(v, max2);
          }
          if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max2 ** 1.5) ** 1.5 * 1.3) {
            return true;
          }
          return false;
        };
        const cur = diffs[i];
        const lastResult = result[result.length - 1];
        const shouldJoin = shouldJoinDiffs(lastResult, cur);
        if (shouldJoin) {
          shouldRepeat = true;
          result[result.length - 1] = result[result.length - 1].join(cur);
        } else {
          result.push(cur);
        }
      }
      diffs = result;
    } while (counter++ < 10 && shouldRepeat);
    const newDiffs = [];
    forEachWithNeighbors(diffs, (prev, cur, next) => {
      let newDiff = cur;
      function shouldMarkAsChanged(text2) {
        return text2.length > 0 && text2.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;
      }
      const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);
      const prefix3 = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));
      if (shouldMarkAsChanged(prefix3)) {
        newDiff = newDiff.deltaStart(-prefix3.length);
      }
      const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));
      if (shouldMarkAsChanged(suffix)) {
        newDiff = newDiff.deltaEnd(suffix.length);
      }
      const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);
      const result = newDiff.intersect(availableSpace);
      if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {
        newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);
      } else {
        newDiffs.push(result);
      }
    });
    return newDiffs;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js
  var LineSequence2 = class {
    constructor(trimmedHash, lines) {
      this.trimmedHash = trimmedHash;
      this.lines = lines;
    }
    getElement(offset) {
      return this.trimmedHash[offset];
    }
    get length() {
      return this.trimmedHash.length;
    }
    getBoundaryScore(length2) {
      const indentationBefore = length2 === 0 ? 0 : getIndentation(this.lines[length2 - 1]);
      const indentationAfter = length2 === this.lines.length ? 0 : getIndentation(this.lines[length2]);
      return 1e3 - (indentationBefore + indentationAfter);
    }
    getText(range) {
      return this.lines.slice(range.start, range.endExclusive).join("\n");
    }
    isStronglyEqual(offset1, offset2) {
      return this.lines[offset1] === this.lines[offset2];
    }
  };
  function getIndentation(str) {
    let i = 0;
    while (i < str.length && (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {
      i++;
    }
    return i;
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js
  var DefaultLinesDiffComputer = class {
    constructor() {
      this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();
      this.myersDiffingAlgorithm = new MyersDiffAlgorithm();
    }
    computeDiff(originalLines, modifiedLines, options) {
      if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {
        return new LinesDiff([], [], false);
      }
      if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
        return new LinesDiff([
          new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [
            new RangeMapping(new Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))
          ])
        ], [], false);
      }
      const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);
      const considerWhitespaceChanges = !options.ignoreTrimWhitespace;
      const perfectHashes = /* @__PURE__ */ new Map();
      function getOrCreateHash(text2) {
        let hash = perfectHashes.get(text2);
        if (hash === void 0) {
          hash = perfectHashes.size;
          perfectHashes.set(text2, hash);
        }
        return hash;
      }
      const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));
      const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));
      const sequence1 = new LineSequence2(originalLinesHashes, originalLines);
      const sequence2 = new LineSequence2(modifiedLinesHashes, modifiedLines);
      const lineAlignmentResult = (() => {
        if (sequence1.length + sequence2.length < 1700) {
          return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
        }
        return this.myersDiffingAlgorithm.compute(sequence1, sequence2);
      })();
      let lineAlignments = lineAlignmentResult.diffs;
      let hitTimeout = lineAlignmentResult.hitTimeout;
      lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);
      lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);
      const alignments = [];
      const scanForWhitespaceChanges = (equalLinesCount) => {
        if (!considerWhitespaceChanges) {
          return;
        }
        for (let i = 0; i < equalLinesCount; i++) {
          const seq1Offset = seq1LastStart + i;
          const seq2Offset = seq2LastStart + i;
          if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
            const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);
            for (const a of characterDiffs.mappings) {
              alignments.push(a);
            }
            if (characterDiffs.hitTimeout) {
              hitTimeout = true;
            }
          }
        }
      };
      let seq1LastStart = 0;
      let seq2LastStart = 0;
      for (const diff of lineAlignments) {
        assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
        const equalLinesCount = diff.seq1Range.start - seq1LastStart;
        scanForWhitespaceChanges(equalLinesCount);
        seq1LastStart = diff.seq1Range.endExclusive;
        seq2LastStart = diff.seq2Range.endExclusive;
        const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);
        if (characterDiffs.hitTimeout) {
          hitTimeout = true;
        }
        for (const a of characterDiffs.mappings) {
          alignments.push(a);
        }
      }
      scanForWhitespaceChanges(originalLines.length - seq1LastStart);
      const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
      let moves = [];
      if (options.computeMoves) {
        moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);
      }
      assertFn(() => {
        function validatePosition(pos, lines) {
          if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
            return false;
          }
          const line = lines[pos.lineNumber - 1];
          if (pos.column < 1 || pos.column > line.length + 1) {
            return false;
          }
          return true;
        }
        function validateRange(range, lines) {
          if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {
            return false;
          }
          if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {
            return false;
          }
          return true;
        }
        for (const c4 of changes) {
          if (!c4.innerChanges) {
            return false;
          }
          for (const ic of c4.innerChanges) {
            const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);
            if (!valid) {
              return false;
            }
          }
          if (!validateRange(c4.modified, modifiedLines) || !validateRange(c4.original, originalLines)) {
            return false;
          }
        }
        return true;
      });
      return new LinesDiff(changes, moves, hitTimeout);
    }
    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {
      const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);
      const movesWithDiffs = moves.map((m) => {
        const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);
        const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
        return new MovedText(m, mappings);
      });
      return movesWithDiffs;
    }
    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {
      const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);
      const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);
      const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);
      let diffs = diffResult.diffs;
      diffs = optimizeSequenceDiffs(slice1, slice2, diffs);
      diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);
      diffs = removeShortMatches(slice1, slice2, diffs);
      diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);
      const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));
      return {
        mappings: result,
        hitTimeout: diffResult.hitTimeout
      };
    }
  };
  function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
    const changes = [];
    for (const g of groupAdjacentBy(alignments.map((a) => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified))) {
      const first = g[0];
      const last = g[g.length - 1];
      changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map((a) => a.innerChanges[0])));
    }
    assertFn(() => {
      if (!dontAssertStartLine && changes.length > 0) {
        if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {
          return false;
        }
        if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {
          return false;
        }
      }
      return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
      m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
    });
    return changes;
  }
  function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
    let lineStartDelta = 0;
    let lineEndDelta = 0;
    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
      lineEndDelta = -1;
    }
    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
      lineStartDelta = 1;
    }
    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js
  var linesDiffComputers = {
    getLegacy: () => new LegacyLinesDiffComputer(),
    getDefault: () => new DefaultLinesDiffComputer()
  };

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/base/common/color.js
  function roundFloat(number2, decimalPoints) {
    const decimal = Math.pow(10, decimalPoints);
    return Math.round(number2 * decimal) / decimal;
  }
  var RGBA = class {
    constructor(r2, g, b, a = 1) {
      this._rgbaBrand = void 0;
      this.r = Math.min(255, Math.max(0, r2)) | 0;
      this.g = Math.min(255, Math.max(0, g)) | 0;
      this.b = Math.min(255, Math.max(0, b)) | 0;
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
      return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
    }
  };
  var HSLA = class _HSLA {
    constructor(h, s2, l, a) {
      this._hslaBrand = void 0;
      this.h = Math.max(Math.min(360, h), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s2), 0), 3);
      this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
      return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;
    }
    /**
     * Converts an RGB color value to HSL. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes r, g, and b are contained in the set [0, 255] and
     * returns h in the set [0, 360], s, and l in the set [0, 1].
     */
    static fromRGBA(rgba) {
      const r2 = rgba.r / 255;
      const g = rgba.g / 255;
      const b = rgba.b / 255;
      const a = rgba.a;
      const max2 = Math.max(r2, g, b);
      const min = Math.min(r2, g, b);
      let h = 0;
      let s2 = 0;
      const l = (min + max2) / 2;
      const chroma = max2 - min;
      if (chroma > 0) {
        s2 = Math.min(l <= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);
        switch (max2) {
          case r2:
            h = (g - b) / chroma + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r2) / chroma + 2;
            break;
          case b:
            h = (r2 - g) / chroma + 4;
            break;
        }
        h *= 60;
        h = Math.round(h);
      }
      return new _HSLA(h, s2, l, a);
    }
    static _hue2rgb(p2, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p2 + (q - p2) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p2 + (q - p2) * (2 / 3 - t) * 6;
      }
      return p2;
    }
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     */
    static toRGBA(hsla) {
      const h = hsla.h / 360;
      const { s: s2, l, a } = hsla;
      let r2, g, b;
      if (s2 === 0) {
        r2 = g = b = l;
      } else {
        const q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
        const p2 = 2 * l - q;
        r2 = _HSLA._hue2rgb(p2, q, h + 1 / 3);
        g = _HSLA._hue2rgb(p2, q, h);
        b = _HSLA._hue2rgb(p2, q, h - 1 / 3);
      }
      return new RGBA(Math.round(r2 * 255), Math.round(g * 255), Math.round(b * 255), a);
    }
  };
  var HSVA = class _HSVA {
    constructor(h, s2, v, a) {
      this._hsvaBrand = void 0;
      this.h = Math.max(Math.min(360, h), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s2), 0), 3);
      this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
    }
    static equals(a, b) {
      return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;
    }
    // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
    static fromRGBA(rgba) {
      const r2 = rgba.r / 255;
      const g = rgba.g / 255;
      const b = rgba.b / 255;
      const cmax = Math.max(r2, g, b);
      const cmin = Math.min(r2, g, b);
      const delta = cmax - cmin;
      const s2 = cmax === 0 ? 0 : delta / cmax;
      let m;
      if (delta === 0) {
        m = 0;
      } else if (cmax === r2) {
        m = ((g - b) / delta % 6 + 6) % 6;
      } else if (cmax === g) {
        m = (b - r2) / delta + 2;
      } else {
        m = (r2 - g) / delta + 4;
      }
      return new _HSVA(Math.round(m * 60), s2, cmax, rgba.a);
    }
    // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
    static toRGBA(hsva) {
      const { h, s: s2, v, a } = hsva;
      const c4 = v * s2;
      const x = c4 * (1 - Math.abs(h / 60 % 2 - 1));
      const m = v - c4;
      let [r2, g, b] = [0, 0, 0];
      if (h < 60) {
        r2 = c4;
        g = x;
      } else if (h < 120) {
        r2 = x;
        g = c4;
      } else if (h < 180) {
        g = c4;
        b = x;
      } else if (h < 240) {
        g = x;
        b = c4;
      } else if (h < 300) {
        r2 = x;
        b = c4;
      } else if (h <= 360) {
        r2 = c4;
        b = x;
      }
      r2 = Math.round((r2 + m) * 255);
      g = Math.round((g + m) * 255);
      b = Math.round((b + m) * 255);
      return new RGBA(r2, g, b, a);
    }
  };
  var Color = class _Color {
    static fromHex(hex2) {
      return _Color.Format.CSS.parseHex(hex2) || _Color.red;
    }
    static equals(a, b) {
      if (!a && !b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      return a.equals(b);
    }
    get hsla() {
      if (this._hsla) {
        return this._hsla;
      } else {
        return HSLA.fromRGBA(this.rgba);
      }
    }
    get hsva() {
      if (this._hsva) {
        return this._hsva;
      }
      return HSVA.fromRGBA(this.rgba);
    }
    constructor(arg) {
      if (!arg) {
        throw new Error("Color needs a value");
      } else if (arg instanceof RGBA) {
        this.rgba = arg;
      } else if (arg instanceof HSLA) {
        this._hsla = arg;
        this.rgba = HSLA.toRGBA(arg);
      } else if (arg instanceof HSVA) {
        this._hsva = arg;
        this.rgba = HSVA.toRGBA(arg);
      } else {
        throw new Error("Invalid color ctor argument");
      }
    }
    equals(other) {
      return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
    }
    /**
     * http://www.w3.org/TR/WCAG20/#relativeluminancedef
     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
     */
    getRelativeLuminance() {
      const R = _Color._relativeLuminanceForComponent(this.rgba.r);
      const G = _Color._relativeLuminanceForComponent(this.rgba.g);
      const B = _Color._relativeLuminanceForComponent(this.rgba.b);
      const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
      return roundFloat(luminance, 4);
    }
    static _relativeLuminanceForComponent(color2) {
      const c4 = color2 / 255;
      return c4 <= 0.03928 ? c4 / 12.92 : Math.pow((c4 + 0.055) / 1.055, 2.4);
    }
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if lighter color otherwise 'false'
     */
    isLighter() {
      const yiq2 = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;
      return yiq2 >= 128;
    }
    isLighterThan(another) {
      const lum1 = this.getRelativeLuminance();
      const lum2 = another.getRelativeLuminance();
      return lum1 > lum2;
    }
    isDarkerThan(another) {
      const lum1 = this.getRelativeLuminance();
      const lum2 = another.getRelativeLuminance();
      return lum1 < lum2;
    }
    lighten(factor2) {
      return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor2, this.hsla.a));
    }
    darken(factor2) {
      return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor2, this.hsla.a));
    }
    transparent(factor2) {
      const { r: r2, g, b, a } = this.rgba;
      return new _Color(new RGBA(r2, g, b, a * factor2));
    }
    isTransparent() {
      return this.rgba.a === 0;
    }
    isOpaque() {
      return this.rgba.a === 1;
    }
    opposite() {
      return new _Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
    }
    makeOpaque(opaqueBackground) {
      if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
        return this;
      }
      const { r: r2, g, b, a } = this.rgba;
      return new _Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r2), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));
    }
    toString() {
      if (!this._toString) {
        this._toString = _Color.Format.CSS.format(this);
      }
      return this._toString;
    }
    static getLighterColor(of, relative2, factor2) {
      if (of.isLighterThan(relative2)) {
        return of;
      }
      factor2 = factor2 ? factor2 : 0.5;
      const lum1 = of.getRelativeLuminance();
      const lum2 = relative2.getRelativeLuminance();
      factor2 = factor2 * (lum2 - lum1) / lum2;
      return of.lighten(factor2);
    }
    static getDarkerColor(of, relative2, factor2) {
      if (of.isDarkerThan(relative2)) {
        return of;
      }
      factor2 = factor2 ? factor2 : 0.5;
      const lum1 = of.getRelativeLuminance();
      const lum2 = relative2.getRelativeLuminance();
      factor2 = factor2 * (lum1 - lum2) / lum1;
      return of.darken(factor2);
    }
  };
  Color.white = new Color(new RGBA(255, 255, 255, 1));
  Color.black = new Color(new RGBA(0, 0, 0, 1));
  Color.red = new Color(new RGBA(255, 0, 0, 1));
  Color.blue = new Color(new RGBA(0, 0, 255, 1));
  Color.green = new Color(new RGBA(0, 255, 0, 1));
  Color.cyan = new Color(new RGBA(0, 255, 255, 1));
  Color.lightgrey = new Color(new RGBA(211, 211, 211, 1));
  Color.transparent = new Color(new RGBA(0, 0, 0, 0));
  (function(Color2) {
    let Format;
    (function(Format2) {
      let CSS;
      (function(CSS2) {
        function formatRGB(color2) {
          if (color2.rgba.a === 1) {
            return `rgb(${color2.rgba.r}, ${color2.rgba.g}, ${color2.rgba.b})`;
          }
          return Color2.Format.CSS.formatRGBA(color2);
        }
        CSS2.formatRGB = formatRGB;
        function formatRGBA(color2) {
          return `rgba(${color2.rgba.r}, ${color2.rgba.g}, ${color2.rgba.b}, ${+color2.rgba.a.toFixed(2)})`;
        }
        CSS2.formatRGBA = formatRGBA;
        function formatHSL(color2) {
          if (color2.hsla.a === 1) {
            return `hsl(${color2.hsla.h}, ${(color2.hsla.s * 100).toFixed(2)}%, ${(color2.hsla.l * 100).toFixed(2)}%)`;
          }
          return Color2.Format.CSS.formatHSLA(color2);
        }
        CSS2.formatHSL = formatHSL;
        function formatHSLA(color2) {
          return `hsla(${color2.hsla.h}, ${(color2.hsla.s * 100).toFixed(2)}%, ${(color2.hsla.l * 100).toFixed(2)}%, ${color2.hsla.a.toFixed(2)})`;
        }
        CSS2.formatHSLA = formatHSLA;
        function _toTwoDigitHex(n2) {
          const r2 = n2.toString(16);
          return r2.length !== 2 ? "0" + r2 : r2;
        }
        function formatHex(color2) {
          return `#${_toTwoDigitHex(color2.rgba.r)}${_toTwoDigitHex(color2.rgba.g)}${_toTwoDigitHex(color2.rgba.b)}`;
        }
        CSS2.formatHex = formatHex;
        function formatHexA(color2, compact = false) {
          if (compact && color2.rgba.a === 1) {
            return Color2.Format.CSS.formatHex(color2);
          }
          return `#${_toTwoDigitHex(color2.rgba.r)}${_toTwoDigitHex(color2.rgba.g)}${_toTwoDigitHex(color2.rgba.b)}${_toTwoDigitHex(Math.round(color2.rgba.a * 255))}`;
        }
        CSS2.formatHexA = formatHexA;
        function format(color2) {
          if (color2.isOpaque()) {
            return Color2.Format.CSS.formatHex(color2);
          }
          return Color2.Format.CSS.formatRGBA(color2);
        }
        CSS2.format = format;
        function parseHex2(hex2) {
          const length2 = hex2.length;
          if (length2 === 0) {
            return null;
          }
          if (hex2.charCodeAt(0) !== 35) {
            return null;
          }
          if (length2 === 7) {
            const r2 = 16 * _parseHexDigit(hex2.charCodeAt(1)) + _parseHexDigit(hex2.charCodeAt(2));
            const g = 16 * _parseHexDigit(hex2.charCodeAt(3)) + _parseHexDigit(hex2.charCodeAt(4));
            const b = 16 * _parseHexDigit(hex2.charCodeAt(5)) + _parseHexDigit(hex2.charCodeAt(6));
            return new Color2(new RGBA(r2, g, b, 1));
          }
          if (length2 === 9) {
            const r2 = 16 * _parseHexDigit(hex2.charCodeAt(1)) + _parseHexDigit(hex2.charCodeAt(2));
            const g = 16 * _parseHexDigit(hex2.charCodeAt(3)) + _parseHexDigit(hex2.charCodeAt(4));
            const b = 16 * _parseHexDigit(hex2.charCodeAt(5)) + _parseHexDigit(hex2.charCodeAt(6));
            const a = 16 * _parseHexDigit(hex2.charCodeAt(7)) + _parseHexDigit(hex2.charCodeAt(8));
            return new Color2(new RGBA(r2, g, b, a / 255));
          }
          if (length2 === 4) {
            const r2 = _parseHexDigit(hex2.charCodeAt(1));
            const g = _parseHexDigit(hex2.charCodeAt(2));
            const b = _parseHexDigit(hex2.charCodeAt(3));
            return new Color2(new RGBA(16 * r2 + r2, 16 * g + g, 16 * b + b));
          }
          if (length2 === 5) {
            const r2 = _parseHexDigit(hex2.charCodeAt(1));
            const g = _parseHexDigit(hex2.charCodeAt(2));
            const b = _parseHexDigit(hex2.charCodeAt(3));
            const a = _parseHexDigit(hex2.charCodeAt(4));
            return new Color2(new RGBA(16 * r2 + r2, 16 * g + g, 16 * b + b, (16 * a + a) / 255));
          }
          return null;
        }
        CSS2.parseHex = parseHex2;
        function _parseHexDigit(charCode) {
          switch (charCode) {
            case 48:
              return 0;
            case 49:
              return 1;
            case 50:
              return 2;
            case 51:
              return 3;
            case 52:
              return 4;
            case 53:
              return 5;
            case 54:
              return 6;
            case 55:
              return 7;
            case 56:
              return 8;
            case 57:
              return 9;
            case 97:
              return 10;
            case 65:
              return 10;
            case 98:
              return 11;
            case 66:
              return 11;
            case 99:
              return 12;
            case 67:
              return 12;
            case 100:
              return 13;
            case 68:
              return 13;
            case 101:
              return 14;
            case 69:
              return 14;
            case 102:
              return 15;
            case 70:
              return 15;
          }
          return 0;
        }
      })(CSS = Format2.CSS || (Format2.CSS = {}));
    })(Format = Color2.Format || (Color2.Format = {}));
  })(Color || (Color = {}));

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js
  function _parseCaptureGroups(captureGroups) {
    const values = [];
    for (const captureGroup of captureGroups) {
      const parsedNumber = Number(captureGroup);
      if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\s/g, "") !== "") {
        values.push(parsedNumber);
      }
    }
    return values;
  }
  function _toIColor(r2, g, b, a) {
    return {
      red: r2 / 255,
      blue: b / 255,
      green: g / 255,
      alpha: a
    };
  }
  function _findRange(model, match) {
    const index2 = match.index;
    const length2 = match[0].length;
    if (!index2) {
      return;
    }
    const startPosition = model.positionAt(index2);
    const range = {
      startLineNumber: startPosition.lineNumber,
      startColumn: startPosition.column,
      endLineNumber: startPosition.lineNumber,
      endColumn: startPosition.column + length2
    };
    return range;
  }
  function _findHexColorInformation(range, hexValue) {
    if (!range) {
      return;
    }
    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);
    if (!parsedHexColor) {
      return;
    }
    return {
      range,
      color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)
    };
  }
  function _findRGBColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
      return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    return {
      range,
      color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)
    };
  }
  function _findHSLColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
      return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));
    return {
      range,
      color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)
    };
  }
  function _findMatches(model, regex) {
    if (typeof model === "string") {
      return [...model.matchAll(regex)];
    } else {
      return model.findMatches(regex);
    }
  }
  function computeColors(model) {
    const result = [];
    const initialValidationRegex = /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm;
    const initialValidationMatches = _findMatches(model, initialValidationRegex);
    if (initialValidationMatches.length > 0) {
      for (const initialMatch of initialValidationMatches) {
        const initialCaptureGroups = initialMatch.filter((captureGroup) => captureGroup !== void 0);
        const colorScheme = initialCaptureGroups[1];
        const colorParameters = initialCaptureGroups[2];
        if (!colorParameters) {
          continue;
        }
        let colorInformation;
        if (colorScheme === "rgb") {
          const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
          colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
        } else if (colorScheme === "rgba") {
          const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
          colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
        } else if (colorScheme === "hsl") {
          const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
          colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
        } else if (colorScheme === "hsla") {
          const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
          colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
        } else if (colorScheme === "#") {
          colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);
        }
        if (colorInformation) {
          result.push(colorInformation);
        }
      }
    }
    return result;
  }
  function computeDefaultDocumentColors(model) {
    if (!model || typeof model.getValue !== "function" || typeof model.positionAt !== "function") {
      return [];
    }
    return computeColors(model);
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js
  var markRegex = /\bMARK:\s*(.*)$/d;
  var trimDashesRegex = /^-+|-+$/g;
  function findSectionHeaders(model, options) {
    var _a4;
    let headers = [];
    if (options.findRegionSectionHeaders && ((_a4 = options.foldingRules) === null || _a4 === void 0 ? void 0 : _a4.markers)) {
      const regionHeaders = collectRegionHeaders(model, options);
      headers = headers.concat(regionHeaders);
    }
    if (options.findMarkSectionHeaders) {
      const markHeaders = collectMarkHeaders(model);
      headers = headers.concat(markHeaders);
    }
    return headers;
  }
  function collectRegionHeaders(model, options) {
    const regionHeaders = [];
    const endLineNumber = model.getLineCount();
    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      const match = lineContent.match(options.foldingRules.markers.start);
      if (match) {
        const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };
        if (range.endColumn > range.startColumn) {
          const sectionHeader = {
            range,
            ...getHeaderText(lineContent.substring(match[0].length)),
            shouldBeInComments: false
          };
          if (sectionHeader.text || sectionHeader.hasSeparatorLine) {
            regionHeaders.push(sectionHeader);
          }
        }
      }
    }
    return regionHeaders;
  }
  function collectMarkHeaders(model) {
    const markHeaders = [];
    const endLineNumber = model.getLineCount();
    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);
    }
    return markHeaders;
  }
  function addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {
    markRegex.lastIndex = 0;
    const match = markRegex.exec(lineContent);
    if (match) {
      const column = match.indices[1][0] + 1;
      const endColumn = match.indices[1][1] + 1;
      const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn };
      if (range.endColumn > range.startColumn) {
        const sectionHeader = {
          range,
          ...getHeaderText(match[1]),
          shouldBeInComments: true
        };
        if (sectionHeader.text || sectionHeader.hasSeparatorLine) {
          sectionHeaders.push(sectionHeader);
        }
      }
    }
  }
  function getHeaderText(text2) {
    text2 = text2.trim();
    const hasSeparatorLine = text2.startsWith("-");
    text2 = text2.replace(trimDashesRegex, "");
    return { text: text2, hasSeparatorLine };
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
  var MirrorModel = class extends MirrorTextModel {
    get uri() {
      return this._uri;
    }
    get eol() {
      return this._eol;
    }
    getValue() {
      return this.getText();
    }
    findMatches(regex) {
      const matches = [];
      for (let i = 0; i < this._lines.length; i++) {
        const line = this._lines[i];
        const offsetToAdd = this.offsetAt(new Position(i + 1, 1));
        const iteratorOverMatches = line.matchAll(regex);
        for (const match of iteratorOverMatches) {
          if (match.index || match.index === 0) {
            match.index = match.index + offsetToAdd;
          }
          matches.push(match);
        }
      }
      return matches;
    }
    getLinesContent() {
      return this._lines.slice(0);
    }
    getLineCount() {
      return this._lines.length;
    }
    getLineContent(lineNumber) {
      return this._lines[lineNumber - 1];
    }
    getWordAtPosition(position2, wordDefinition) {
      const wordAtText = getWordAtText(position2.column, ensureValidWordDefinition(wordDefinition), this._lines[position2.lineNumber - 1], 0);
      if (wordAtText) {
        return new Range(position2.lineNumber, wordAtText.startColumn, position2.lineNumber, wordAtText.endColumn);
      }
      return null;
    }
    words(wordDefinition) {
      const lines = this._lines;
      const wordenize = this._wordenize.bind(this);
      let lineNumber = 0;
      let lineText = "";
      let wordRangesIdx = 0;
      let wordRanges = [];
      return {
        *[Symbol.iterator]() {
          while (true) {
            if (wordRangesIdx < wordRanges.length) {
              const value2 = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
              wordRangesIdx += 1;
              yield value2;
            } else {
              if (lineNumber < lines.length) {
                lineText = lines[lineNumber];
                wordRanges = wordenize(lineText, wordDefinition);
                wordRangesIdx = 0;
                lineNumber += 1;
              } else {
                break;
              }
            }
          }
        }
      };
    }
    getLineWords(lineNumber, wordDefinition) {
      const content = this._lines[lineNumber - 1];
      const ranges = this._wordenize(content, wordDefinition);
      const words = [];
      for (const range of ranges) {
        words.push({
          word: content.substring(range.start, range.end),
          startColumn: range.start + 1,
          endColumn: range.end + 1
        });
      }
      return words;
    }
    _wordenize(content, wordDefinition) {
      const result = [];
      let match;
      wordDefinition.lastIndex = 0;
      while (match = wordDefinition.exec(content)) {
        if (match[0].length === 0) {
          break;
        }
        result.push({ start: match.index, end: match.index + match[0].length });
      }
      return result;
    }
    getValueInRange(range) {
      range = this._validateRange(range);
      if (range.startLineNumber === range.endLineNumber) {
        return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
      }
      const lineEnding = this._eol;
      const startLineIndex = range.startLineNumber - 1;
      const endLineIndex = range.endLineNumber - 1;
      const resultLines = [];
      resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
      for (let i = startLineIndex + 1; i < endLineIndex; i++) {
        resultLines.push(this._lines[i]);
      }
      resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
      return resultLines.join(lineEnding);
    }
    offsetAt(position2) {
      position2 = this._validatePosition(position2);
      this._ensureLineStarts();
      return this._lineStarts.getPrefixSum(position2.lineNumber - 2) + (position2.column - 1);
    }
    positionAt(offset) {
      offset = Math.floor(offset);
      offset = Math.max(0, offset);
      this._ensureLineStarts();
      const out = this._lineStarts.getIndexOf(offset);
      const lineLength = this._lines[out.index].length;
      return {
        lineNumber: 1 + out.index,
        column: 1 + Math.min(out.remainder, lineLength)
      };
    }
    _validateRange(range) {
      const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
      const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
      if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {
        return {
          startLineNumber: start.lineNumber,
          startColumn: start.column,
          endLineNumber: end.lineNumber,
          endColumn: end.column
        };
      }
      return range;
    }
    _validatePosition(position2) {
      if (!Position.isIPosition(position2)) {
        throw new Error("bad position");
      }
      let { lineNumber, column } = position2;
      let hasChanged = false;
      if (lineNumber < 1) {
        lineNumber = 1;
        column = 1;
        hasChanged = true;
      } else if (lineNumber > this._lines.length) {
        lineNumber = this._lines.length;
        column = this._lines[lineNumber - 1].length + 1;
        hasChanged = true;
      } else {
        const maxCharacter = this._lines[lineNumber - 1].length + 1;
        if (column < 1) {
          column = 1;
          hasChanged = true;
        } else if (column > maxCharacter) {
          column = maxCharacter;
          hasChanged = true;
        }
      }
      if (!hasChanged) {
        return position2;
      } else {
        return { lineNumber, column };
      }
    }
  };
  var EditorSimpleWorker = class _EditorSimpleWorker {
    constructor(host, foreignModuleFactory) {
      this._host = host;
      this._models = /* @__PURE__ */ Object.create(null);
      this._foreignModuleFactory = foreignModuleFactory;
      this._foreignModule = null;
    }
    dispose() {
      this._models = /* @__PURE__ */ Object.create(null);
    }
    _getModel(uri) {
      return this._models[uri];
    }
    _getModels() {
      const all = [];
      Object.keys(this._models).forEach((key) => all.push(this._models[key]));
      return all;
    }
    acceptNewModel(data) {
      this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
    }
    acceptModelChanged(strURL, e2) {
      if (!this._models[strURL]) {
        return;
      }
      const model = this._models[strURL];
      model.onEvents(e2);
    }
    acceptRemovedModel(strURL) {
      if (!this._models[strURL]) {
        return;
      }
      delete this._models[strURL];
    }
    async computeUnicodeHighlights(url2, options, range) {
      const model = this._getModel(url2);
      if (!model) {
        return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
      }
      return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
    }
    async findSectionHeaders(url2, options) {
      const model = this._getModel(url2);
      if (!model) {
        return [];
      }
      return findSectionHeaders(model, options);
    }
    // ---- BEGIN diff --------------------------------------------------------------------------
    async computeDiff(originalUrl, modifiedUrl, options, algorithm) {
      const original = this._getModel(originalUrl);
      const modified = this._getModel(modifiedUrl);
      if (!original || !modified) {
        return null;
      }
      const result = _EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
      return result;
    }
    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
      const diffAlgorithm = algorithm === "advanced" ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();
      const originalLines = originalTextModel.getLinesContent();
      const modifiedLines = modifiedTextModel.getLinesContent();
      const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);
      const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);
      function getLineChanges(changes) {
        return changes.map((m) => {
          var _a4;
          return [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a4 = m.innerChanges) === null || _a4 === void 0 ? void 0 : _a4.map((m2) => [
            m2.originalRange.startLineNumber,
            m2.originalRange.startColumn,
            m2.originalRange.endLineNumber,
            m2.originalRange.endColumn,
            m2.modifiedRange.startLineNumber,
            m2.modifiedRange.startColumn,
            m2.modifiedRange.endLineNumber,
            m2.modifiedRange.endColumn
          ])];
        });
      }
      return {
        identical,
        quitEarly: result.hitTimeout,
        changes: getLineChanges(result.changes),
        moves: result.moves.map((m) => [
          m.lineRangeMapping.original.startLineNumber,
          m.lineRangeMapping.original.endLineNumberExclusive,
          m.lineRangeMapping.modified.startLineNumber,
          m.lineRangeMapping.modified.endLineNumberExclusive,
          getLineChanges(m.changes)
        ])
      };
    }
    static _modelsAreIdentical(original, modified) {
      const originalLineCount = original.getLineCount();
      const modifiedLineCount = modified.getLineCount();
      if (originalLineCount !== modifiedLineCount) {
        return false;
      }
      for (let line = 1; line <= originalLineCount; line++) {
        const originalLine = original.getLineContent(line);
        const modifiedLine = modified.getLineContent(line);
        if (originalLine !== modifiedLine) {
          return false;
        }
      }
      return true;
    }
    async computeMoreMinimalEdits(modelUrl, edits, pretty) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return edits;
      }
      const result = [];
      let lastEol = void 0;
      edits = edits.slice(0).sort((a, b) => {
        if (a.range && b.range) {
          return Range.compareRangesUsingStarts(a.range, b.range);
        }
        const aRng = a.range ? 0 : 1;
        const bRng = b.range ? 0 : 1;
        return aRng - bRng;
      });
      let writeIndex = 0;
      for (let readIndex = 1; readIndex < edits.length; readIndex++) {
        if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {
          edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));
          edits[writeIndex].text += edits[readIndex].text;
        } else {
          writeIndex++;
          edits[writeIndex] = edits[readIndex];
        }
      }
      edits.length = writeIndex + 1;
      for (let { range, text: text2, eol } of edits) {
        if (typeof eol === "number") {
          lastEol = eol;
        }
        if (Range.isEmpty(range) && !text2) {
          continue;
        }
        const original = model.getValueInRange(range);
        text2 = text2.replace(/\r\n|\n|\r/g, model.eol);
        if (original === text2) {
          continue;
        }
        if (Math.max(text2.length, original.length) > _EditorSimpleWorker._diffLimit) {
          result.push({ range, text: text2 });
          continue;
        }
        const changes = stringDiff(original, text2, pretty);
        const editOffset = model.offsetAt(Range.lift(range).getStartPosition());
        for (const change of changes) {
          const start = model.positionAt(editOffset + change.originalStart);
          const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
          const newEdit = {
            text: text2.substr(change.modifiedStart, change.modifiedLength),
            range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
          };
          if (model.getValueInRange(newEdit.range) !== newEdit.text) {
            result.push(newEdit);
          }
        }
      }
      if (typeof lastEol === "number") {
        result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
      }
      return result;
    }
    // ---- END minimal edits ---------------------------------------------------------------
    async computeLinks(modelUrl) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      return computeLinks(model);
    }
    // --- BEGIN default document colors -----------------------------------------------------------
    async computeDefaultDocumentColors(modelUrl) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      return computeDefaultDocumentColors(model);
    }
    async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
      const sw = new StopWatch();
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const seen = /* @__PURE__ */ new Set();
      outer:
        for (const url2 of modelUrls) {
          const model = this._getModel(url2);
          if (!model) {
            continue;
          }
          for (const word of model.words(wordDefRegExp)) {
            if (word === leadingWord || !isNaN(Number(word))) {
              continue;
            }
            seen.add(word);
            if (seen.size > _EditorSimpleWorker._suggestionsLimit) {
              break outer;
            }
          }
        }
      return { words: Array.from(seen), duration: sw.elapsed() };
    }
    // ---- END suggest --------------------------------------------------------------------------
    //#region -- word ranges --
    async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return /* @__PURE__ */ Object.create(null);
      }
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      const result = /* @__PURE__ */ Object.create(null);
      for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
        const words = model.getLineWords(line, wordDefRegExp);
        for (const word of words) {
          if (!isNaN(Number(word.word))) {
            continue;
          }
          let array = result[word.word];
          if (!array) {
            array = [];
            result[word.word] = array;
          }
          array.push({
            startLineNumber: line,
            startColumn: word.startColumn,
            endLineNumber: line,
            endColumn: word.endColumn
          });
        }
      }
      return result;
    }
    //#endregion
    async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
      const model = this._getModel(modelUrl);
      if (!model) {
        return null;
      }
      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
      if (range.startColumn === range.endColumn) {
        range = {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn + 1
        };
      }
      const selectionText = model.getValueInRange(range);
      const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
      if (!wordRange) {
        return null;
      }
      const word = model.getValueInRange(wordRange);
      const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
      return result;
    }
    // ---- BEGIN foreign module support --------------------------------------------------------------------------
    loadForeignModule(moduleId, createData, foreignHostMethods) {
      const proxyMethodRequest = (method, args) => {
        return this._host.fhr(method, args);
      };
      const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
      const ctx = {
        host: foreignHost,
        getMirrorModels: () => {
          return this._getModels();
        }
      };
      if (this._foreignModuleFactory) {
        this._foreignModule = this._foreignModuleFactory(ctx, createData);
        return Promise.resolve(getAllMethodNames(this._foreignModule));
      }
      return Promise.reject(new Error(`Unexpected usage`));
    }
    // foreign method request
    fmr(method, args) {
      if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
        return Promise.reject(new Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
      } catch (e2) {
        return Promise.reject(e2);
      }
    }
  };
  EditorSimpleWorker._diffLimit = 1e5;
  EditorSimpleWorker._suggestionsLimit = 1e4;
  if (typeof importScripts === "function") {
    globalThis.monaco = createMonacoBaseAPI();
  }

  // node_modules/.pnpm/monaco-editor@0.49.0/node_modules/monaco-editor/esm/vs/editor/editor.worker.js
  var initialized = false;
  function initialize(foreignModule) {
    if (initialized) {
      return;
    }
    initialized = true;
    const simpleWorker = new SimpleWorkerServer((msg) => {
      globalThis.postMessage(msg);
    }, (host) => new EditorSimpleWorker(host, foreignModule));
    globalThis.onmessage = (e2) => {
      simpleWorker.onmessage(e2.data);
    };
  }
  globalThis.onmessage = (e2) => {
    if (!initialized) {
      initialize(null);
    }
  };

  // node_modules/.pnpm/monaco-worker-manager@2.0.1_monaco-editor@0.49.0/node_modules/monaco-worker-manager/worker.js
  function initialize2(fn2) {
    self.onmessage = () => {
      initialize((ctx, createData) => Object.create(fn2(ctx, createData)));
    };
  }

  // node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/postcss.mjs
  var import_postcss = __toESM(require_postcss(), 1);
  var postcss_default = import_postcss.default;
  var stringify = import_postcss.default.stringify;
  var fromJSON = import_postcss.default.fromJSON;
  var plugin = import_postcss.default.plugin;
  var parse = import_postcss.default.parse;
  var list = import_postcss.default.list;
  var document2 = import_postcss.default.document;
  var comment = import_postcss.default.comment;
  var atRule = import_postcss.default.atRule;
  var rule = import_postcss.default.rule;
  var decl = import_postcss.default.decl;
  var root = import_postcss.default.root;
  var CssSyntaxError = import_postcss.default.CssSyntaxError;
  var Declaration = import_postcss.default.Declaration;
  var Container = import_postcss.default.Container;
  var Processor = import_postcss.default.Processor;
  var Document = import_postcss.default.Document;
  var Comment = import_postcss.default.Comment;
  var Warning = import_postcss.default.Warning;
  var AtRule = import_postcss.default.AtRule;
  var Result = import_postcss.default.Result;
  var Input = import_postcss.default.Input;
  var Rule = import_postcss.default.Rule;
  var Root = import_postcss.default.Root;
  var Node2 = import_postcss.default.Node;

  // node_modules/.pnpm/monaco-tailwindcss@0.6.0_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var import_postcss_selector_parser = __toESM(require_dist(), 1);
  var import_postcss_selector_parser2 = __toESM(require_dist(), 1);
  var import_postcss_selector_parser3 = __toESM(require_dist(), 1);
  var import_postcss_nested = __toESM(require_postcss_nested(), 1);

  // node_modules/.pnpm/postcss-js@4.0.1_postcss@8.4.38/node_modules/postcss-js/index.mjs
  var import_index = __toESM(require_postcss_js(), 1);
  var postcss_js_default = import_index.default;
  var objectify = import_index.default.objectify;
  var parse2 = import_index.default.parse;
  var async = import_index.default.async;
  var sync = import_index.default.sync;

  // node_modules/.pnpm/monaco-tailwindcss@0.6.0_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var import_postcss_selector_parser4 = __toESM(require_dist(), 1);

  // node_modules/.pnpm/color-name@2.0.0/node_modules/color-name/index.js
  var color_name_default = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };

  // node_modules/.pnpm/monaco-tailwindcss@0.6.0_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var import_postcss_selector_parser5 = __toESM(require_dist(), 1);
  var import_unesc = __toESM(require_unesc(), 1);
  var import_postcss_selector_parser6 = __toESM(require_dist(), 1);
  var import_dlv = __toESM(require_dlv_umd(), 1);
  var import_postcss_selector_parser7 = __toESM(require_dist(), 1);

  // node_modules/.pnpm/quick-lru@6.1.2/node_modules/quick-lru/index.js
  var QuickLRU = class extends Map {
    constructor(options = {}) {
      super();
      if (!(options.maxSize && options.maxSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      if (typeof options.maxAge === "number" && options.maxAge === 0) {
        throw new TypeError("`maxAge` must be a number greater than 0");
      }
      this.maxSize = options.maxSize;
      this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
      this.onEviction = options.onEviction;
      this.cache = /* @__PURE__ */ new Map();
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    // TODO: Use private class methods when targeting Node.js 16.
    _emitEvictions(cache3) {
      if (typeof this.onEviction !== "function") {
        return;
      }
      for (const [key, item] of cache3) {
        this.onEviction(key, item.value);
      }
    }
    _deleteIfExpired(key, item) {
      if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
        if (typeof this.onEviction === "function") {
          this.onEviction(key, item.value);
        }
        return this.delete(key);
      }
      return false;
    }
    _getOrDeleteIfExpired(key, item) {
      const deleted = this._deleteIfExpired(key, item);
      if (deleted === false) {
        return item.value;
      }
    }
    _getItemValue(key, item) {
      return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
    }
    _peek(key, cache3) {
      const item = cache3.get(key);
      return this._getItemValue(key, item);
    }
    _set(key, value2) {
      this.cache.set(key, value2);
      this._size++;
      if (this._size >= this.maxSize) {
        this._size = 0;
        this._emitEvictions(this.oldCache);
        this.oldCache = this.cache;
        this.cache = /* @__PURE__ */ new Map();
      }
    }
    _moveToRecent(key, item) {
      this.oldCache.delete(key);
      this._set(key, item);
    }
    *_entriesAscending() {
      for (const item of this.oldCache) {
        const [key, value2] = item;
        if (!this.cache.has(key)) {
          const deleted = this._deleteIfExpired(key, value2);
          if (deleted === false) {
            yield item;
          }
        }
      }
      for (const item of this.cache) {
        const [key, value2] = item;
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield item;
        }
      }
    }
    get(key) {
      if (this.cache.has(key)) {
        const item = this.cache.get(key);
        return this._getItemValue(key, item);
      }
      if (this.oldCache.has(key)) {
        const item = this.oldCache.get(key);
        if (this._deleteIfExpired(key, item) === false) {
          this._moveToRecent(key, item);
          return item.value;
        }
      }
    }
    set(key, value2, { maxAge = this.maxAge } = {}) {
      const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
      if (this.cache.has(key)) {
        this.cache.set(key, {
          value: value2,
          expiry
        });
      } else {
        this._set(key, { value: value2, expiry });
      }
      return this;
    }
    has(key) {
      if (this.cache.has(key)) {
        return !this._deleteIfExpired(key, this.cache.get(key));
      }
      if (this.oldCache.has(key)) {
        return !this._deleteIfExpired(key, this.oldCache.get(key));
      }
      return false;
    }
    peek(key) {
      if (this.cache.has(key)) {
        return this._peek(key, this.cache);
      }
      if (this.oldCache.has(key)) {
        return this._peek(key, this.oldCache);
      }
    }
    delete(key) {
      const deleted = this.cache.delete(key);
      if (deleted) {
        this._size--;
      }
      return this.oldCache.delete(key) || deleted;
    }
    clear() {
      this.cache.clear();
      this.oldCache.clear();
      this._size = 0;
    }
    resize(newSize) {
      if (!(newSize && newSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      const items = [...this._entriesAscending()];
      const removeCount = items.length - newSize;
      if (removeCount < 0) {
        this.cache = new Map(items);
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = items.length;
      } else {
        if (removeCount > 0) {
          this._emitEvictions(items.slice(0, removeCount));
        }
        this.oldCache = new Map(items.slice(removeCount));
        this.cache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      this.maxSize = newSize;
    }
    *keys() {
      for (const [key] of this) {
        yield key;
      }
    }
    *values() {
      for (const [, value2] of this) {
        yield value2;
      }
    }
    *[Symbol.iterator]() {
      for (const item of this.cache) {
        const [key, value2] = item;
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield [key, value2.value];
        }
      }
      for (const item of this.oldCache) {
        const [key, value2] = item;
        if (!this.cache.has(key)) {
          const deleted = this._deleteIfExpired(key, value2);
          if (deleted === false) {
            yield [key, value2.value];
          }
        }
      }
    }
    *entriesDescending() {
      let items = [...this.cache];
      for (let i = items.length - 1; i >= 0; --i) {
        const item = items[i];
        const [key, value2] = item;
        const deleted = this._deleteIfExpired(key, value2);
        if (deleted === false) {
          yield [key, value2.value];
        }
      }
      items = [...this.oldCache];
      for (let i = items.length - 1; i >= 0; --i) {
        const item = items[i];
        const [key, value2] = item;
        if (!this.cache.has(key)) {
          const deleted = this._deleteIfExpired(key, value2);
          if (deleted === false) {
            yield [key, value2.value];
          }
        }
      }
    }
    *entriesAscending() {
      for (const [key, value2] of this._entriesAscending()) {
        yield [key, value2.value];
      }
    }
    get size() {
      if (!this._size) {
        return this.oldCache.size;
      }
      let oldCacheSize = 0;
      for (const key of this.oldCache.keys()) {
        if (!this.cache.has(key)) {
          oldCacheSize++;
        }
      }
      return Math.min(this._size + oldCacheSize, this.maxSize);
    }
    entries() {
      return this.entriesAscending();
    }
    forEach(callbackFunction, thisArgument = this) {
      for (const [key, value2] of this.entriesAscending()) {
        callbackFunction.call(thisArgument, value2, key, this);
      }
    }
    get [Symbol.toStringTag]() {
      return JSON.stringify([...this.entriesAscending()]);
    }
  };

  // node_modules/.pnpm/monaco-tailwindcss@0.6.0_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var import_dlv2 = __toESM(require_dlv_umd(), 1);
  var import_didyoumean = __toESM(require_didYouMean_1_2_1(), 1);
  var import_postcss_value_parser = __toESM(require_lib(), 1);
  var import_postcss_selector_parser8 = __toESM(require_dist(), 1);
  var import_dlv3 = __toESM(require_dlv_umd(), 1);
  var import_line_column = __toESM(require_line_column(), 1);
  var import_moo = __toESM(require_moo(), 1);
  var import_becke_ch_regex_s0_0_v1_base_pl_lib = __toESM(require_becke_ch_regex_s0_0_v1_base_pl_lib(), 1);
  var import_tmp_cache = __toESM(require_lib2(), 1);
  var import_css = __toESM(require_css_escape(), 1);

  // node_modules/.pnpm/is-regexp@3.1.0/node_modules/is-regexp/index.js
  var { toString } = Object.prototype;
  function isRegexp(value2) {
    return toString.call(value2) === "[object RegExp]";
  }

  // node_modules/.pnpm/is-obj@3.0.0/node_modules/is-obj/index.js
  function isObject2(value2) {
    const type = typeof value2;
    return value2 !== null && (type === "object" || type === "function");
  }

  // node_modules/.pnpm/get-own-enumerable-keys@1.0.0/node_modules/get-own-enumerable-keys/index.js
  var { propertyIsEnumerable } = Object.prototype;
  function getOwnEnumerableKeys(object) {
    return [
      ...Object.keys(object),
      ...Object.getOwnPropertySymbols(object).filter((key) => propertyIsEnumerable.call(object, key))
    ];
  }

  // node_modules/.pnpm/stringify-object@5.0.0/node_modules/stringify-object/index.js
  function stringifyObject(input, options, pad) {
    const seen = [];
    return function stringify2(input2, options2 = {}, pad2 = "") {
      const indent = options2.indent || "	";
      let tokens;
      if (options2.inlineCharacterLimit === void 0) {
        tokens = {
          newline: "\n",
          newlineOrSpace: "\n",
          pad: pad2,
          indent: pad2 + indent
        };
      } else {
        tokens = {
          newline: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
          newlineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
          pad: "@@__STRINGIFY_OBJECT_PAD__@@",
          indent: "@@__STRINGIFY_OBJECT_INDENT__@@"
        };
      }
      const expandWhiteSpace = (string) => {
        if (options2.inlineCharacterLimit === void 0) {
          return string;
        }
        const oneLined = string.replace(new RegExp(tokens.newline, "g"), "").replace(new RegExp(tokens.newlineOrSpace, "g"), " ").replace(new RegExp(tokens.pad + "|" + tokens.indent, "g"), "");
        if (oneLined.length <= options2.inlineCharacterLimit) {
          return oneLined;
        }
        return string.replace(new RegExp(tokens.newline + "|" + tokens.newlineOrSpace, "g"), "\n").replace(new RegExp(tokens.pad, "g"), pad2).replace(new RegExp(tokens.indent, "g"), pad2 + indent);
      };
      if (seen.includes(input2)) {
        return '"[Circular]"';
      }
      if (input2 === null || input2 === void 0 || typeof input2 === "number" || typeof input2 === "boolean" || typeof input2 === "function" || typeof input2 === "symbol" || isRegexp(input2)) {
        return String(input2);
      }
      if (input2 instanceof Date) {
        return `new Date('${input2.toISOString()}')`;
      }
      if (Array.isArray(input2)) {
        if (input2.length === 0) {
          return "[]";
        }
        seen.push(input2);
        const returnValue = "[" + tokens.newline + input2.map((element, i) => {
          const eol = input2.length - 1 === i ? tokens.newline : "," + tokens.newlineOrSpace;
          let value2 = stringify2(element, options2, pad2 + indent);
          if (options2.transform) {
            value2 = options2.transform(input2, i, value2);
          }
          return tokens.indent + value2 + eol;
        }).join("") + tokens.pad + "]";
        seen.pop();
        return expandWhiteSpace(returnValue);
      }
      if (isObject2(input2)) {
        let objectKeys = getOwnEnumerableKeys(input2);
        if (options2.filter) {
          objectKeys = objectKeys.filter((element) => options2.filter(input2, element));
        }
        if (objectKeys.length === 0) {
          return "{}";
        }
        seen.push(input2);
        const returnValue = "{" + tokens.newline + objectKeys.map((element, index2) => {
          const eol = objectKeys.length - 1 === index2 ? tokens.newline : "," + tokens.newlineOrSpace;
          const isSymbol = typeof element === "symbol";
          const isClassic = !isSymbol && /^[a-z$_][$\w]*$/i.test(element);
          const key = isSymbol || isClassic ? element : stringify2(element, options2);
          let value2 = stringify2(input2[element], options2, pad2 + indent);
          if (options2.transform) {
            value2 = options2.transform(input2, element, value2);
          }
          return tokens.indent + String(key) + ": " + value2 + eol;
        }).join("") + tokens.pad + "}";
        seen.pop();
        return expandWhiteSpace(returnValue);
      }
      input2 = input2.replace(/\\/g, "\\\\");
      input2 = String(input2).replace(/[\r\n]/g, (x) => x === "\n" ? "\\n" : "\\r");
      if (options2.singleQuotes === false) {
        input2 = input2.replace(/"/g, '\\"');
        return `"${input2}"`;
      }
      input2 = input2.replace(/'/g, "\\'");
      return `'${input2}'`;
    }(input, options, pad);
  }

  // node_modules/.pnpm/monaco-tailwindcss@0.6.0_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  var import_gte = __toESM(require_gte(), 1);
  var import_lte = __toESM(require_lte(), 1);
  var import_sift_string = __toESM(require_sift_string(), 1);
  var import_postcss_selector_parser9 = __toESM(require_dist(), 1);

  // node_modules/.pnpm/vscode-languageserver-textdocument@1.0.11/node_modules/vscode-languageserver-textdocument/lib/esm/main.js
  var FullTextDocument = class _FullTextDocument {
    constructor(uri, languageId, version2, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version2;
      this._content = content;
      this._lineOffsets = void 0;
    }
    get uri() {
      return this._uri;
    }
    get languageId() {
      return this._languageId;
    }
    get version() {
      return this._version;
    }
    getText(range) {
      if (range) {
        const start = this.offsetAt(range.start);
        const end = this.offsetAt(range.end);
        return this._content.substring(start, end);
      }
      return this._content;
    }
    update(changes, version2) {
      for (let change of changes) {
        if (_FullTextDocument.isIncremental(change)) {
          const range = getWellformedRange(change.range);
          const startOffset = this.offsetAt(range.start);
          const endOffset = this.offsetAt(range.end);
          this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
          const startLine = Math.max(range.start.line, 0);
          const endLine = Math.max(range.end.line, 0);
          let lineOffsets = this._lineOffsets;
          const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
          if (endLine - startLine === addedLineOffsets.length) {
            for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
              lineOffsets[i + startLine + 1] = addedLineOffsets[i];
            }
          } else {
            if (addedLineOffsets.length < 1e4) {
              lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
            } else {
              this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
            }
          }
          const diff = change.text.length - (endOffset - startOffset);
          if (diff !== 0) {
            for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
              lineOffsets[i] = lineOffsets[i] + diff;
            }
          }
        } else if (_FullTextDocument.isFull(change)) {
          this._content = change.text;
          this._lineOffsets = void 0;
        } else {
          throw new Error("Unknown change event received");
        }
      }
      this._version = version2;
    }
    getLineOffsets() {
      if (this._lineOffsets === void 0) {
        this._lineOffsets = computeLineOffsets(this._content, true);
      }
      return this._lineOffsets;
    }
    positionAt(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      let lineOffsets = this.getLineOffsets();
      let low = 0, high = lineOffsets.length;
      if (high === 0) {
        return { line: 0, character: offset };
      }
      while (low < high) {
        let mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      let line = low - 1;
      return { line, character: offset - lineOffsets[line] };
    }
    offsetAt(position2) {
      let lineOffsets = this.getLineOffsets();
      if (position2.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position2.line < 0) {
        return 0;
      }
      let lineOffset = lineOffsets[position2.line];
      let nextLineOffset = position2.line + 1 < lineOffsets.length ? lineOffsets[position2.line + 1] : this._content.length;
      return Math.max(Math.min(lineOffset + position2.character, nextLineOffset), lineOffset);
    }
    get lineCount() {
      return this.getLineOffsets().length;
    }
    static isIncremental(event) {
      let candidate = event;
      return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
    }
    static isFull(event) {
      let candidate = event;
      return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
    }
  };
  var TextDocument;
  (function(TextDocument2) {
    function create(uri, languageId, version2, content) {
      return new FullTextDocument(uri, languageId, version2, content);
    }
    TextDocument2.create = create;
    function update(document3, changes, version2) {
      if (document3 instanceof FullTextDocument) {
        document3.update(changes, version2);
        return document3;
      } else {
        throw new Error("TextDocument.update: document must be created by TextDocument.create");
      }
    }
    TextDocument2.update = update;
    function applyEdits(document3, edits) {
      let text2 = document3.getText();
      let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
        let diff = a.range.start.line - b.range.start.line;
        if (diff === 0) {
          return a.range.start.character - b.range.start.character;
        }
        return diff;
      });
      let lastModifiedOffset = 0;
      const spans = [];
      for (const e2 of sortedEdits) {
        let startOffset = document3.offsetAt(e2.range.start);
        if (startOffset < lastModifiedOffset) {
          throw new Error("Overlapping edit");
        } else if (startOffset > lastModifiedOffset) {
          spans.push(text2.substring(lastModifiedOffset, startOffset));
        }
        if (e2.newText.length) {
          spans.push(e2.newText);
        }
        lastModifiedOffset = document3.offsetAt(e2.range.end);
      }
      spans.push(text2.substr(lastModifiedOffset));
      return spans.join("");
    }
    TextDocument2.applyEdits = applyEdits;
  })(TextDocument || (TextDocument = {}));
  function mergeSort(data, compare) {
    if (data.length <= 1) {
      return data;
    }
    const p2 = data.length / 2 | 0;
    const left = data.slice(0, p2);
    const right = data.slice(p2);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
      let ret = compare(left[leftIdx], right[rightIdx]);
      if (ret <= 0) {
        data[i++] = left[leftIdx++];
      } else {
        data[i++] = right[rightIdx++];
      }
    }
    while (leftIdx < left.length) {
      data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
      data[i++] = right[rightIdx++];
    }
    return data;
  }
  function computeLineOffsets(text2, isAtLineStart, textOffset = 0) {
    const result = isAtLineStart ? [textOffset] : [];
    for (let i = 0; i < text2.length; i++) {
      let ch = text2.charCodeAt(i);
      if (ch === 13 || ch === 10) {
        if (ch === 13 && i + 1 < text2.length && text2.charCodeAt(i + 1) === 10) {
          i++;
        }
        result.push(textOffset + i + 1);
      }
    }
    return result;
  }
  function getWellformedRange(range) {
    const start = range.start;
    const end = range.end;
    if (start.line > end.line || start.line === end.line && start.character > end.character) {
      return { start: end, end: start };
    }
    return range;
  }
  function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
      return { newText: textEdit.newText, range };
    }
    return textEdit;
  }

  // node_modules/.pnpm/monaco-tailwindcss@0.6.0_monaco-editor@0.49.0/node_modules/monaco-tailwindcss/tailwindcss.worker.js
  function parseObjectStyles(styles) {
    if (!Array.isArray(styles)) {
      return parseObjectStyles([styles]);
    }
    return styles.flatMap((style) => {
      return postcss_default([
        (0, import_postcss_nested.default)({
          bubble: ["screen"]
        })
      ]).process(style, {
        parser: postcss_js_default
      }).root.nodes;
    });
  }
  function isPlainObject(value2) {
    if (Object.prototype.toString.call(value2) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value2);
    return prototype === null || prototype === Object.prototype;
  }
  function prefixSelector_default(prefix3, selector, prependNegative = false) {
    if (prefix3 === "") {
      return selector;
    }
    let ast = typeof selector === "string" ? (0, import_postcss_selector_parser4.default)().astSync(selector) : selector;
    ast.walkClasses((classSelector) => {
      let baseClass = classSelector.value;
      let shouldPlaceNegativeBeforePrefix = prependNegative && baseClass.startsWith("-");
      classSelector.value = shouldPlaceNegativeBeforePrefix ? `-${prefix3}${baseClass.slice(1)}` : `${prefix3}${baseClass}`;
    });
    return typeof selector === "string" ? ast.toString() : ast;
  }
  function escapeCommas(className) {
    return className.replace(/\\,/g, "\\2c ");
  }
  var HEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
  var SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
  var VALUE = /(?:\d+|\d*\.\d+)%?/;
  var SEP = /(?:\s*,\s*|\s+)/;
  var ALPHA_SEP = /\s*[,/]\s*/;
  var CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)\)/;
  var RGB = new RegExp(
    `^(rgba?)\\(\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`
  );
  var HSL = new RegExp(
    `^(hsla?)\\(\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`
  );
  function parseColor(value2, { loose = false } = {}) {
    if (typeof value2 !== "string") {
      return null;
    }
    value2 = value2.trim();
    if (value2 === "transparent") {
      return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
    }
    if (value2 in color_name_default) {
      return { mode: "rgb", color: color_name_default[value2].map((v) => v.toString()) };
    }
    let hex2 = value2.replace(SHORT_HEX, (_, r2, g, b, a) => ["#", r2, r2, g, g, b, b, a ? a + a : ""].join("")).match(HEX);
    if (hex2 !== null) {
      return {
        mode: "rgb",
        color: [parseInt(hex2[1], 16), parseInt(hex2[2], 16), parseInt(hex2[3], 16)].map(
          (v) => v.toString()
        ),
        alpha: hex2[4] ? (parseInt(hex2[4], 16) / 255).toString() : void 0
      };
    }
    let match = value2.match(RGB) ?? value2.match(HSL);
    if (match === null) {
      return null;
    }
    let color2 = [match[2], match[3], match[4]].filter(Boolean).map((v) => v.toString());
    if (color2.length === 2 && color2[0].startsWith("var(")) {
      return {
        mode: match[1],
        color: [color2[0]],
        alpha: color2[1]
      };
    }
    if (!loose && color2.length !== 3) {
      return null;
    }
    if (color2.length < 3 && !color2.some((part) => /^var\(.*?\)$/.test(part))) {
      return null;
    }
    return {
      mode: match[1],
      color: color2,
      alpha: match[5]?.toString?.()
    };
  }
  function formatColor({ mode, color: color2, alpha }) {
    let hasAlpha = alpha !== void 0;
    if (mode === "rgba" || mode === "hsla") {
      return `${mode}(${color2.join(", ")}${hasAlpha ? `, ${alpha}` : ""})`;
    }
    return `${mode}(${color2.join(" ")}${hasAlpha ? ` / ${alpha}` : ""})`;
  }
  function withAlphaValue(color2, alphaValue, defaultValue) {
    if (typeof color2 === "function") {
      return color2({ opacityValue: alphaValue });
    }
    let parsed = parseColor(color2, { loose: true });
    if (parsed === null) {
      return defaultValue;
    }
    return formatColor({ ...parsed, alpha: alphaValue });
  }
  function withAlphaVariable({ color: color2, property, variable }) {
    let properties = [].concat(property);
    if (typeof color2 === "function") {
      return {
        [variable]: "1",
        ...Object.fromEntries(
          properties.map((p2) => {
            return [p2, color2({ opacityVariable: variable, opacityValue: `var(${variable})` })];
          })
        )
      };
    }
    const parsed = parseColor(color2);
    if (parsed === null) {
      return Object.fromEntries(properties.map((p2) => [p2, color2]));
    }
    if (parsed.alpha !== void 0) {
      return Object.fromEntries(properties.map((p2) => [p2, color2]));
    }
    return {
      [variable]: "1",
      ...Object.fromEntries(
        properties.map((p2) => {
          return [p2, formatColor({ ...parsed, alpha: `var(${variable})` })];
        })
      )
    };
  }
  function splitAtTopLevelOnly(input, separator) {
    let stack = [];
    let parts = [];
    let lastPos = 0;
    for (let idx = 0; idx < input.length; idx++) {
      let char = input[idx];
      if (stack.length === 0 && char === separator[0]) {
        if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
          parts.push(input.slice(lastPos, idx));
          lastPos = idx + separator.length;
        }
      }
      if (char === "(" || char === "[" || char === "{") {
        stack.push(char);
      } else if (char === ")" && stack[stack.length - 1] === "(" || char === "]" && stack[stack.length - 1] === "[" || char === "}" && stack[stack.length - 1] === "{") {
        stack.pop();
      }
    }
    parts.push(input.slice(lastPos));
    return parts;
  }
  var KEYWORDS = /* @__PURE__ */ new Set(["inset", "inherit", "initial", "revert", "unset"]);
  var SPACE = /\ +(?![^(]*\))/g;
  var LENGTH = /^-?(\d+|\.\d+)(.*?)$/g;
  function parseBoxShadowValue(input) {
    let shadows = splitAtTopLevelOnly(input, ",");
    return shadows.map((shadow2) => {
      let value2 = shadow2.trim();
      let result = { raw: value2 };
      let parts = value2.split(SPACE);
      let seen = /* @__PURE__ */ new Set();
      for (let part of parts) {
        LENGTH.lastIndex = 0;
        if (!seen.has("KEYWORD") && KEYWORDS.has(part)) {
          result.keyword = part;
          seen.add("KEYWORD");
        } else if (LENGTH.test(part)) {
          if (!seen.has("X")) {
            result.x = part;
            seen.add("X");
          } else if (!seen.has("Y")) {
            result.y = part;
            seen.add("Y");
          } else if (!seen.has("BLUR")) {
            result.blur = part;
            seen.add("BLUR");
          } else if (!seen.has("SPREAD")) {
            result.spread = part;
            seen.add("SPREAD");
          }
        } else {
          if (!result.color) {
            result.color = part;
          } else {
            if (!result.unknown)
              result.unknown = [];
            result.unknown.push(part);
          }
        }
      }
      result.valid = result.x !== void 0 && result.y !== void 0;
      return result;
    });
  }
  function formatBoxShadowValue(shadows) {
    return shadows.map((shadow2) => {
      if (!shadow2.valid) {
        return shadow2.raw;
      }
      return [shadow2.keyword, shadow2.x, shadow2.y, shadow2.blur, shadow2.spread, shadow2.color].filter(Boolean).join(" ");
    }).join(", ");
  }
  var cssFunctions = ["min", "max", "clamp", "calc"];
  function isCSSFunction(value2) {
    return cssFunctions.some((fn2) => new RegExp(`^${fn2}\\(.*\\)`).test(value2));
  }
  var placeholder = "--tw-placeholder";
  var placeholderRe = new RegExp(placeholder, "g");
  function normalize2(value2, isRoot2 = true) {
    if (value2.includes("url(")) {
      return value2.split(/(url\(.*?\))/g).filter(Boolean).map((part) => {
        if (/^url\(.*?\)$/.test(part)) {
          return part;
        }
        return normalize2(part, false);
      }).join("");
    }
    value2 = value2.replace(
      /([^\\])_+/g,
      (fullMatch, characterBefore) => characterBefore + " ".repeat(fullMatch.length - 1)
    ).replace(/^_/g, " ").replace(/\\_/g, "_");
    if (isRoot2) {
      value2 = value2.trim();
    }
    value2 = value2.replace(/(calc|min|max|clamp)\(.+\)/g, (match) => {
      let vars = [];
      return match.replace(/var\((--.+?)[,)]/g, (match2, g1) => {
        vars.push(g1);
        return match2.replace(g1, placeholder);
      }).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(placeholderRe, () => vars.shift());
    });
    return value2;
  }
  function url(value2) {
    return value2.startsWith("url(");
  }
  function number(value2) {
    return !isNaN(Number(value2)) || isCSSFunction(value2);
  }
  function percentage(value2) {
    return value2.endsWith("%") && number(value2.slice(0, -1)) || isCSSFunction(value2);
  }
  var lengthUnits = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
  ];
  var lengthUnitsPattern = `(?:${lengthUnits.join("|")})`;
  function length(value2) {
    return value2 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`).test(value2) || isCSSFunction(value2);
  }
  var lineWidths = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
  function lineWidth(value2) {
    return lineWidths.has(value2);
  }
  function shadow(value2) {
    let parsedShadows = parseBoxShadowValue(normalize2(value2));
    for (let parsedShadow of parsedShadows) {
      if (!parsedShadow.valid) {
        return false;
      }
    }
    return true;
  }
  function color(value2) {
    let colors = 0;
    let result = splitAtTopLevelOnly(value2, "_").every((part) => {
      part = normalize2(part);
      if (part.startsWith("var("))
        return true;
      if (parseColor(part, { loose: true }) !== null)
        return colors++, true;
      return false;
    });
    if (!result)
      return false;
    return colors > 0;
  }
  function image(value2) {
    let images = 0;
    let result = splitAtTopLevelOnly(value2, ",").every((part) => {
      part = normalize2(part);
      if (part.startsWith("var("))
        return true;
      if (url(part) || gradient(part) || ["element(", "image(", "cross-fade(", "image-set("].some((fn2) => part.startsWith(fn2))) {
        images++;
        return true;
      }
      return false;
    });
    if (!result)
      return false;
    return images > 0;
  }
  var gradientTypes = /* @__PURE__ */ new Set([
    "linear-gradient",
    "radial-gradient",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "conic-gradient"
  ]);
  function gradient(value2) {
    value2 = normalize2(value2);
    for (let type of gradientTypes) {
      if (value2.startsWith(`${type}(`)) {
        return true;
      }
    }
    return false;
  }
  var validPositions = /* @__PURE__ */ new Set(["center", "top", "right", "bottom", "left"]);
  function position(value2) {
    let positions = 0;
    let result = splitAtTopLevelOnly(value2, "_").every((part) => {
      part = normalize2(part);
      if (part.startsWith("var("))
        return true;
      if (validPositions.has(part) || length(part) || percentage(part)) {
        positions++;
        return true;
      }
      return false;
    });
    if (!result)
      return false;
    return positions > 0;
  }
  function familyName(value2) {
    let fonts = 0;
    let result = splitAtTopLevelOnly(value2, ",").every((part) => {
      part = normalize2(part);
      if (part.startsWith("var("))
        return true;
      if (part.includes(" ")) {
        if (!/(['"])([^"']+)\1/g.test(part)) {
          return false;
        }
      }
      if (/^\d/g.test(part)) {
        return false;
      }
      fonts++;
      return true;
    });
    if (!result)
      return false;
    return fonts > 0;
  }
  var genericNames = /* @__PURE__ */ new Set([
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "ui-serif",
    "ui-sans-serif",
    "ui-monospace",
    "ui-rounded",
    "math",
    "emoji",
    "fangsong"
  ]);
  function genericName(value2) {
    return genericNames.has(value2);
  }
  var absoluteSizes = /* @__PURE__ */ new Set([
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "x-large",
    "xxx-large"
  ]);
  function absoluteSize(value2) {
    return absoluteSizes.has(value2);
  }
  var relativeSizes = /* @__PURE__ */ new Set(["larger", "smaller"]);
  function relativeSize(value2) {
    return relativeSizes.has(value2);
  }
  function negateValue(value2) {
    value2 = `${value2}`;
    if (value2 === "0") {
      return "0";
    }
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(value2)) {
      return value2.replace(/^[+-]?/, (sign) => sign === "-" ? "" : "-");
    }
    let numericFunctions = ["var", "calc", "min", "max", "clamp"];
    for (const fn2 of numericFunctions) {
      if (value2.includes(`${fn2}(`)) {
        return `calc(${value2} * -1)`;
      }
    }
  }
  function backgroundSize(value2) {
    let keywordValues = ["cover", "contain"];
    return splitAtTopLevelOnly(value2, ",").every((part) => {
      let sizes = splitAtTopLevelOnly(part, "_").filter(Boolean);
      if (sizes.length === 1 && keywordValues.includes(sizes[0]))
        return true;
      if (sizes.length !== 1 && sizes.length !== 2)
        return false;
      return sizes.every((size) => length(size) || percentage(size) || size === "auto");
    });
  }
  var picocolors_default = {
    yellow: (input) => input
  };
  function log() {
  }
  function dim(input) {
    return input;
  }
  var log_default = {
    info: log,
    warn: log,
    risk: log
  };
  var defaults = {
    optimizeUniversalDefaults: false,
    generalizedModifiers: true
  };
  var featureFlags = {
    future: [
      "hoverOnlyWhenSupported",
      "respectDefaultRingColorOpacity",
      "disableColorOpacityUtilitiesByDefault",
      "relativeContentPathsByDefault"
    ],
    experimental: [
      "optimizeUniversalDefaults",
      "generalizedModifiers"
      // 'variantGrouping',
    ]
  };
  function flagEnabled(config, flag) {
    if (featureFlags.future.includes(flag)) {
      return config.future === "all" || (config?.future?.[flag] ?? defaults[flag] ?? false);
    }
    if (featureFlags.experimental.includes(flag)) {
      return config.experimental === "all" || (config?.experimental?.[flag] ?? defaults[flag] ?? false);
    }
    return false;
  }
  function experimentalFlagsEnabled(config) {
    if (config.experimental === "all") {
      return featureFlags.experimental;
    }
    return Object.keys(config?.experimental ?? {}).filter(
      (flag) => featureFlags.experimental.includes(flag) && config.experimental[flag]
    );
  }
  function issueFlagNotices(config) {
    if (true) {
      return;
    }
    if (experimentalFlagsEnabled(config).length > 0) {
      let changes = experimentalFlagsEnabled(config).map((s2) => picocolors_default.yellow(s2)).join(", ");
      log_default.warn("experimental-flags-enabled", [
        `You have enabled experimental features: ${changes}`,
        "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
      ]);
    }
  }
  function updateAllClasses(selectors, updateClass) {
    selectors.walkClasses((sel) => {
      sel.value = updateClass(sel.value);
      if (sel.raws && sel.raws.value) {
        sel.raws.value = escapeCommas(sel.raws.value);
      }
    });
  }
  function resolveArbitraryValue(modifier, validate) {
    if (!isArbitraryValue(modifier)) {
      return void 0;
    }
    let value2 = modifier.slice(1, -1);
    if (!validate(value2)) {
      return void 0;
    }
    return normalize2(value2);
  }
  function asNegativeValue(modifier, lookup = {}, validate) {
    let positiveValue = lookup[modifier];
    if (positiveValue !== void 0) {
      return negateValue(positiveValue);
    }
    if (isArbitraryValue(modifier)) {
      let resolved = resolveArbitraryValue(modifier, validate);
      if (resolved === void 0) {
        return void 0;
      }
      return negateValue(resolved);
    }
  }
  function asValue(modifier, options = {}, { validate = () => true } = {}) {
    let value2 = options.values?.[modifier];
    if (value2 !== void 0) {
      return value2;
    }
    if (options.supportsNegativeValues && modifier.startsWith("-")) {
      return asNegativeValue(modifier.slice(1), options.values, validate);
    }
    return resolveArbitraryValue(modifier, validate);
  }
  function isArbitraryValue(input) {
    return input.startsWith("[") && input.endsWith("]");
  }
  function splitUtilityModifier(modifier) {
    let slashIdx = modifier.lastIndexOf("/");
    if (slashIdx === -1 || slashIdx === modifier.length - 1) {
      return [modifier, void 0];
    }
    let arbitrary = isArbitraryValue(modifier);
    if (arbitrary && !modifier.includes("]/[")) {
      return [modifier, void 0];
    }
    return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];
  }
  function parseColorFormat(value2) {
    if (typeof value2 === "string" && value2.includes("<alpha-value>")) {
      let oldValue = value2;
      return ({ opacityValue = 1 }) => oldValue.replace("<alpha-value>", opacityValue);
    }
    return value2;
  }
  function asColor(modifier, options = {}, { tailwindConfig = {} } = {}) {
    if (options.values?.[modifier] !== void 0) {
      return parseColorFormat(options.values?.[modifier]);
    }
    let [color2, alpha] = splitUtilityModifier(modifier);
    if (alpha !== void 0) {
      let normalizedColor = options.values?.[color2] ?? (isArbitraryValue(color2) ? color2.slice(1, -1) : void 0);
      if (normalizedColor === void 0) {
        return void 0;
      }
      normalizedColor = parseColorFormat(normalizedColor);
      if (isArbitraryValue(alpha)) {
        return withAlphaValue(normalizedColor, alpha.slice(1, -1));
      }
      if (tailwindConfig.theme?.opacity?.[alpha] === void 0) {
        return void 0;
      }
      return withAlphaValue(normalizedColor, tailwindConfig.theme.opacity[alpha]);
    }
    return asValue(modifier, options, { validate: color });
  }
  function asLookupValue(modifier, options = {}) {
    return options.values?.[modifier];
  }
  function guess(validate) {
    return (modifier, options) => {
      return asValue(modifier, options, { validate });
    };
  }
  var typeMap = {
    any: asValue,
    color: asColor,
    url: guess(url),
    image: guess(image),
    length: guess(length),
    percentage: guess(percentage),
    position: guess(position),
    lookup: asLookupValue,
    "generic-name": guess(genericName),
    "family-name": guess(familyName),
    number: guess(number),
    "line-width": guess(lineWidth),
    "absolute-size": guess(absoluteSize),
    "relative-size": guess(relativeSize),
    shadow: guess(shadow),
    size: guess(backgroundSize)
  };
  var supportedTypes = Object.keys(typeMap);
  function splitAtFirst(input, delim) {
    let idx = input.indexOf(delim);
    if (idx === -1)
      return [void 0, input];
    return [input.slice(0, idx), input.slice(idx + 1)];
  }
  function coerceValue(types2, modifier, options, tailwindConfig) {
    if (options.values && modifier in options.values) {
      for (let { type } of types2 ?? []) {
        let result = typeMap[type](modifier, options, {
          tailwindConfig
        });
        if (result === void 0) {
          continue;
        }
        return [result, type, null];
      }
    }
    if (isArbitraryValue(modifier)) {
      let arbitraryValue = modifier.slice(1, -1);
      let [explicitType, value2] = splitAtFirst(arbitraryValue, ":");
      if (!/^[\w-_]+$/g.test(explicitType)) {
        value2 = arbitraryValue;
      } else if (explicitType !== void 0 && !supportedTypes.includes(explicitType)) {
        return [];
      }
      if (value2.length > 0 && supportedTypes.includes(explicitType)) {
        return [asValue(`[${value2}]`, options), explicitType, null];
      }
    }
    let matches = getMatchingTypes(types2, modifier, options, tailwindConfig);
    for (let match of matches) {
      return match;
    }
    return [];
  }
  function* getMatchingTypes(types2, rawModifier, options, tailwindConfig) {
    let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
    let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);
    let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === "any" || typeof options.modifiers === "object" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));
    if (!canUseUtilityModifier) {
      modifier = rawModifier;
      utilityModifier = void 0;
    }
    if (utilityModifier !== void 0 && modifier === "") {
      modifier = "DEFAULT";
    }
    if (utilityModifier !== void 0) {
      if (typeof options.modifiers === "object") {
        let configValue = options.modifiers?.[utilityModifier] ?? null;
        if (configValue !== null) {
          utilityModifier = configValue;
        } else if (isArbitraryValue(utilityModifier)) {
          utilityModifier = utilityModifier.slice(1, -1);
        }
      }
    }
    for (let { type } of types2 ?? []) {
      let result = typeMap[type](modifier, options, {
        tailwindConfig
      });
      if (result === void 0) {
        continue;
      }
      yield [result, type, utilityModifier ?? null];
    }
  }
  var version = "3.2.7";
  var package_default = {
    name: "tailwindcss",
    version,
    description: "A utility-first CSS framework for rapidly building custom user interfaces.",
    license: "MIT",
    main: "lib/index.js",
    types: "types/index.d.ts",
    repository: "https://github.com/tailwindlabs/tailwindcss.git",
    bugs: "https://github.com/tailwindlabs/tailwindcss/issues",
    homepage: "https://tailwindcss.com",
    bin: {
      tailwind: "lib/cli.js",
      tailwindcss: "lib/cli.js"
    },
    tailwindcss: {
      engine: "stable"
    },
    scripts: {
      prebuild: "npm run generate && rimraf lib",
      build: "swc src --out-dir lib --copy-files",
      postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false",
      "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js",
      style: "eslint .",
      pretest: "npm run generate",
      test: "jest",
      "test:integrations": "npm run test --prefix ./integrations",
      "install:integrations": "node scripts/install-integrations.js",
      "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js",
      "generate:types": "node -r @swc/register scripts/generate-types.js",
      generate: "npm run generate:plugin-list && npm run generate:types",
      "release-channel": "node ./scripts/release-channel.js",
      "release-notes": "node ./scripts/release-notes.js",
      prepublishOnly: "npm install --force && npm run build"
    },
    files: [
      "src/*",
      "cli/*",
      "lib/*",
      "peers/*",
      "scripts/*.js",
      "stubs/*.stub.js",
      "nesting/*",
      "types/**/*",
      "*.d.ts",
      "*.css",
      "*.js"
    ],
    devDependencies: {
      "@swc/cli": "0.1.59",
      "@swc/core": "1.3.24",
      "@swc/jest": "0.2.24",
      "@swc/register": "0.1.10",
      autoprefixer: "^10.4.13",
      browserslist: "^4.21.4",
      concurrently: "^7.5.0",
      cssnano: "^5.1.14",
      esbuild: "^0.16.10",
      eslint: "^8.31.0",
      "eslint-config-prettier": "^8.6.0",
      "eslint-plugin-prettier": "^4.2.1",
      jest: "^28.1.3",
      "jest-diff": "^28.1.3",
      lightningcss: "^1.18.0",
      prettier: "^2.8.1",
      rimraf: "^3.0.0",
      "source-map-js": "^1.0.2",
      turbo: "^1.6.3"
    },
    peerDependencies: {
      postcss: "^8.0.9"
    },
    dependencies: {
      arg: "^5.0.2",
      chokidar: "^3.5.3",
      "color-name": "^1.1.4",
      detective: "^5.2.1",
      didyoumean: "^1.2.2",
      dlv: "^1.1.3",
      "fast-glob": "^3.2.12",
      "glob-parent": "^6.0.2",
      "is-glob": "^4.0.3",
      lilconfig: "^2.0.6",
      micromatch: "^4.0.5",
      "normalize-path": "^3.0.0",
      "object-hash": "^3.0.0",
      picocolors: "^1.0.0",
      postcss: "^8.0.9",
      "postcss-import": "^14.1.0",
      "postcss-js": "^4.0.0",
      "postcss-load-config": "^3.1.4",
      "postcss-nested": "6.0.0",
      "postcss-selector-parser": "^6.0.11",
      "postcss-value-parser": "^4.2.0",
      "quick-lru": "^5.1.1",
      resolve: "^1.22.1"
    },
    browserslist: [
      "> 1%",
      "not edge <= 18",
      "not ie 11",
      "not op_mini all"
    ],
    jest: {
      testTimeout: 3e4,
      setupFilesAfterEnv: [
        "<rootDir>/jest/customMatchers.js"
      ],
      testPathIgnorePatterns: [
        "/node_modules/",
        "/integrations/",
        "/standalone-cli/",
        "\\.test\\.skip\\.js$"
      ],
      transformIgnorePatterns: [
        "node_modules/(?!lightningcss)"
      ],
      transform: {
        "\\.js$": "@swc/jest",
        "\\.ts$": "@swc/jest"
      }
    },
    engines: {
      node: ">=12.13.0"
    }
  };
  var OXIDE_DEFAULT_ENABLED = package_default.tailwindcss.engine === "oxide";
  var env2 = {
    NODE_ENV: "production",
    DEBUG: resolveDebug(void 0),
    ENGINE: package_default.tailwindcss.engine,
    OXIDE: resolveBoolean(void 0, OXIDE_DEFAULT_ENABLED)
  };
  var NOT_ON_DEMAND = new String("*");
  var NONE = Symbol("__NONE__");
  function resolveBoolean(value2, defaultValue) {
    if (value2 === void 0) {
      return defaultValue;
    }
    if (value2 === "0" || value2 === "false") {
      return false;
    }
    return true;
  }
  function resolveDebug(debug) {
    if (debug === void 0) {
      return false;
    }
    if (debug === "true" || debug === "1") {
      return true;
    }
    if (debug === "false" || debug === "0") {
      return false;
    }
    if (debug === "*") {
      return true;
    }
    let debuggers = debug.split(",").map((d) => d.split(":")[0]);
    if (debuggers.includes("-tailwindcss")) {
      return false;
    }
    if (debuggers.includes("tailwindcss")) {
      return true;
    }
    return false;
  }
  function escapeClassName(className) {
    let node = import_postcss_selector_parser6.default.className();
    node.value = className;
    return escapeCommas(node?.raws?.value ?? node.value);
  }
  var MERGE = ":merge";
  function formatVariantSelector(formats, { context, candidate }) {
    let prefix3 = context?.tailwindConfig.prefix ?? "";
    let parsedFormats = formats.map((format) => {
      let ast = (0, import_postcss_selector_parser5.default)().astSync(format.format);
      return {
        ...format,
        ast: format.isArbitraryVariant ? ast : prefixSelector_default(prefix3, ast)
      };
    });
    let formatAst = import_postcss_selector_parser5.default.root({
      nodes: [
        import_postcss_selector_parser5.default.selector({
          nodes: [import_postcss_selector_parser5.default.className({ value: escapeClassName(candidate) })]
        })
      ]
    });
    for (let { ast } of parsedFormats) {
      ;
      [formatAst, ast] = handleMergePseudo(formatAst, ast);
      ast.walkNesting((nesting) => nesting.replaceWith(...formatAst.nodes[0].nodes));
      formatAst = ast;
    }
    return formatAst;
  }
  function simpleSelectorForNode(node) {
    let nodes = [];
    while (node.prev() && node.prev().type !== "combinator") {
      node = node.prev();
    }
    while (node && node.type !== "combinator") {
      nodes.push(node);
      node = node.next();
    }
    return nodes;
  }
  function resortSelector(sel) {
    sel.sort((a, b) => {
      if (a.type === "tag" && b.type === "class") {
        return -1;
      } else if (a.type === "class" && b.type === "tag") {
        return 1;
      } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
        return -1;
      } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
        return 1;
      }
      return sel.index(a) - sel.index(b);
    });
    return sel;
  }
  function eliminateIrrelevantSelectors(sel, base) {
    let hasClassesMatchingCandidate = false;
    sel.walk((child) => {
      if (child.type === "class" && child.value === base) {
        hasClassesMatchingCandidate = true;
        return false;
      }
    });
    if (!hasClassesMatchingCandidate) {
      sel.remove();
    }
  }
  function finalizeSelector(current, formats, { context, candidate, base }) {
    let separator = context?.tailwindConfig?.separator ?? ":";
    base = base ?? candidate.split(new RegExp(`\\${separator}(?![^[]*\\])`)).pop();
    let selector = (0, import_postcss_selector_parser5.default)().astSync(current);
    selector.walkClasses((node) => {
      if (node.raws && node.value.includes(base)) {
        node.raws.value = escapeClassName((0, import_unesc.default)(node.raws.value));
      }
    });
    selector.each((sel) => eliminateIrrelevantSelectors(sel, base));
    let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, { context, candidate }) : formats;
    if (formatAst === null) {
      return selector.toString();
    }
    let simpleStart = import_postcss_selector_parser5.default.comment({ value: "/*__simple__*/" });
    let simpleEnd = import_postcss_selector_parser5.default.comment({ value: "/*__simple__*/" });
    selector.walkClasses((node) => {
      if (node.value !== base) {
        return;
      }
      let parent = node.parent;
      let formatNodes = formatAst.nodes[0].nodes;
      if (parent.nodes.length === 1) {
        node.replaceWith(...formatNodes);
        return;
      }
      let simpleSelector = simpleSelectorForNode(node);
      parent.insertBefore(simpleSelector[0], simpleStart);
      parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);
      for (let child of formatNodes) {
        parent.insertBefore(simpleSelector[0], child.clone());
      }
      node.remove();
      simpleSelector = simpleSelectorForNode(simpleStart);
      let firstNode = parent.index(simpleStart);
      parent.nodes.splice(
        firstNode,
        simpleSelector.length,
        ...resortSelector(import_postcss_selector_parser5.default.selector({ nodes: simpleSelector })).nodes
      );
      simpleStart.remove();
      simpleEnd.remove();
    });
    selector.walkPseudos((p2) => {
      if (p2.value === MERGE) {
        p2.replaceWith(p2.nodes);
      }
    });
    selector.each((sel) => {
      let pseudoElements = collectPseudoElements(sel);
      if (pseudoElements.length > 0) {
        sel.nodes.push(pseudoElements.sort(sortSelector));
      }
    });
    return selector.toString();
  }
  function handleMergePseudo(selector, format) {
    let merges = [];
    selector.walkPseudos((pseudo) => {
      if (pseudo.value === MERGE) {
        merges.push({
          pseudo,
          value: pseudo.nodes[0].toString()
        });
      }
    });
    format.walkPseudos((pseudo) => {
      if (pseudo.value !== MERGE) {
        return;
      }
      let value2 = pseudo.nodes[0].toString();
      let existing = merges.find((merge) => merge.value === value2);
      if (!existing) {
        return;
      }
      let attachments = [];
      let next = pseudo.next();
      while (next && next.type !== "combinator") {
        attachments.push(next);
        next = next.next();
      }
      let combinator = next;
      existing.pseudo.parent.insertAfter(
        existing.pseudo,
        import_postcss_selector_parser5.default.selector({ nodes: attachments.map((node) => node.clone()) })
      );
      pseudo.remove();
      attachments.forEach((node) => node.remove());
      if (combinator && combinator.type === "combinator") {
        combinator.remove();
      }
    });
    return [selector, format];
  }
  var pseudoElementsBC = [":before", ":after", ":first-line", ":first-letter"];
  var pseudoElementExceptions = [
    "::file-selector-button",
    // Webkit scroll bar pseudo elements can be combined with user-action pseudo classes
    "::-webkit-scrollbar",
    "::-webkit-scrollbar-button",
    "::-webkit-scrollbar-thumb",
    "::-webkit-scrollbar-track",
    "::-webkit-scrollbar-track-piece",
    "::-webkit-scrollbar-corner",
    "::-webkit-resizer"
  ];
  function collectPseudoElements(selector) {
    let nodes = [];
    for (let node of selector.nodes) {
      if (isPseudoElement(node)) {
        nodes.push(node);
        selector.removeChild(node);
      }
      if (node?.nodes) {
        nodes.push(...collectPseudoElements(node));
      }
    }
    return nodes;
  }
  function sortSelector(a, z) {
    if (a.type !== "pseudo" && z.type !== "pseudo") {
      return 0;
    }
    if (a.type === "combinator" ^ z.type === "combinator") {
      return 0;
    }
    if (a.type === "pseudo" ^ z.type === "pseudo") {
      return (a.type === "pseudo") - (z.type === "pseudo");
    }
    return isPseudoElement(a) - isPseudoElement(z);
  }
  function isPseudoElement(node) {
    if (node.type !== "pseudo")
      return false;
    if (pseudoElementExceptions.includes(node.value))
      return false;
    return node.value.startsWith("::") || pseudoElementsBC.includes(node.value);
  }
  function asClass(name) {
    return escapeCommas(`.${escapeClassName(name)}`);
  }
  function nameClass(classPrefix, key) {
    return asClass(formatClass(classPrefix, key));
  }
  function formatClass(classPrefix, key) {
    if (key === "DEFAULT") {
      return classPrefix;
    }
    if (key === "-" || key === "-DEFAULT") {
      return `-${classPrefix}`;
    }
    if (key.startsWith("-")) {
      return `-${classPrefix}${key}`;
    }
    if (key.startsWith("/")) {
      return `${classPrefix}${key}`;
    }
    return `${classPrefix}-${key}`;
  }
  var preflight_default = "/*\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\n*/\n\n*,\n::before,\n::after {\n  box-sizing: border-box; /* 1 */\n  border-width: 0; /* 2 */\n  border-style: solid; /* 2 */\n  border-color: theme('borderColor.DEFAULT', currentColor); /* 2 */\n}\n\n::before,\n::after {\n  --tw-content: '';\n}\n\n/*\n1. Use a consistent sensible line-height in all browsers.\n2. Prevent adjustments of font size after orientation changes in iOS.\n3. Use a more readable tab size.\n4. Use the user's configured `sans` font-family by default.\n5. Use the user's configured `sans` font-feature-settings by default.\n*/\n\nhtml {\n  line-height: 1.5; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n  -moz-tab-size: 4; /* 3 */\n  tab-size: 4; /* 3 */\n  font-family: theme('fontFamily.sans', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"); /* 4 */\n  font-feature-settings: theme('fontFamily.sans[1].fontFeatureSettings', normal); /* 5 */\n}\n\n/*\n1. Remove the margin in all browsers.\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\n*/\n\nbody {\n  margin: 0; /* 1 */\n  line-height: inherit; /* 2 */\n}\n\n/*\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n3. Ensure horizontal rules are visible by default.\n*/\n\nhr {\n  height: 0; /* 1 */\n  color: inherit; /* 2 */\n  border-top-width: 1px; /* 3 */\n}\n\n/*\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr:where([title]) {\n  text-decoration: underline dotted;\n}\n\n/*\nRemove the default font size and weight for headings.\n*/\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-size: inherit;\n  font-weight: inherit;\n}\n\n/*\nReset links to optimize for opt-in styling instead of opt-out.\n*/\n\na {\n  color: inherit;\n  text-decoration: inherit;\n}\n\n/*\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/*\n1. Use the user's configured `mono` font family by default.\n2. Correct the odd `em` font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n  font-family: theme('fontFamily.mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace); /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/*\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n  font-size: 80%;\n}\n\n/*\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/*\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n3. Remove gaps between table borders by default.\n*/\n\ntable {\n  text-indent: 0; /* 1 */\n  border-color: inherit; /* 2 */\n  border-collapse: collapse; /* 3 */\n}\n\n/*\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n3. Remove default padding in all browsers.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  font-weight: inherit; /* 1 */\n  line-height: inherit; /* 1 */\n  color: inherit; /* 1 */\n  margin: 0; /* 2 */\n  padding: 0; /* 3 */\n}\n\n/*\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n  text-transform: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Remove default button styles.\n*/\n\nbutton,\n[type='button'],\n[type='reset'],\n[type='submit'] {\n  -webkit-appearance: button; /* 1 */\n  background-color: transparent; /* 2 */\n  background-image: none; /* 2 */\n}\n\n/*\nUse the modern Firefox focus style for all focusable elements.\n*/\n\n:-moz-focusring {\n  outline: auto;\n}\n\n/*\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n:-moz-ui-invalid {\n  box-shadow: none;\n}\n\n/*\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n  vertical-align: baseline;\n}\n\n/*\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/*\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type='search'] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/*\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to `inherit` in Safari.\n*/\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n  display: list-item;\n}\n\n/*\nRemoves the default spacing and border for appropriate elements.\n*/\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nlegend {\n  padding: 0;\n}\n\nol,\nul,\nmenu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n/*\nPrevent resizing textareas horizontally by default.\n*/\n\ntextarea {\n  resize: vertical;\n}\n\n/*\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n2. Set the default placeholder color to the user's configured gray 400 color.\n*/\n\ninput::placeholder,\ntextarea::placeholder {\n  opacity: 1; /* 1 */\n  color: theme('colors.gray.400', #9ca3af); /* 2 */\n}\n\n/*\nSet the default cursor for buttons.\n*/\n\nbutton,\n[role=\"button\"] {\n  cursor: pointer;\n}\n\n/*\nMake sure disabled buttons don't get the pointer cursor.\n*/\n:disabled {\n  cursor: default;\n}\n\n/*\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n   This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n  display: block; /* 1 */\n  vertical-align: middle; /* 2 */\n}\n\n/*\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\nimg,\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n\n/* Make elements with the HTML hidden attribute stay hidden by default */\n[hidden] {\n  display: none;\n}\n";
  var fs_default = {
    // Reading the preflight CSS is the only use of fs at the moment of writing.
    readFileSync: () => preflight_default
  };
  function transformThemeValue(themeSection) {
    if (["fontSize", "outline"].includes(themeSection)) {
      return (value2) => {
        if (typeof value2 === "function")
          value2 = value2({});
        if (Array.isArray(value2))
          value2 = value2[0];
        return value2;
      };
    }
    if (themeSection === "fontFamily") {
      return (value2) => {
        if (typeof value2 === "function")
          value2 = value2({});
        let families = Array.isArray(value2) && isPlainObject(value2[1]) ? value2[0] : value2;
        return Array.isArray(families) ? families.join(", ") : families;
      };
    }
    if ([
      "boxShadow",
      "transitionProperty",
      "transitionDuration",
      "transitionDelay",
      "transitionTimingFunction",
      "backgroundImage",
      "backgroundSize",
      "backgroundColor",
      "cursor",
      "animation"
    ].includes(themeSection)) {
      return (value2) => {
        if (typeof value2 === "function")
          value2 = value2({});
        if (Array.isArray(value2))
          value2 = value2.join(", ");
        return value2;
      };
    }
    if (["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(themeSection)) {
      return (value2) => {
        if (typeof value2 === "function")
          value2 = value2({});
        if (typeof value2 === "string")
          value2 = postcss_default.list.comma(value2).join(" ");
        return value2;
      };
    }
    return (value2, opts = {}) => {
      if (typeof value2 === "function") {
        value2 = value2(opts);
      }
      return value2;
    };
  }
  var join = () => "";
  function createUtilityPlugin(themeKey, utilityVariations = [[themeKey, [themeKey]]], { filterDefault = false, ...options } = {}) {
    let transformValue = transformThemeValue(themeKey);
    return function({ matchUtilities, theme }) {
      for (let utilityVariation of utilityVariations) {
        let group = Array.isArray(utilityVariation[0]) ? utilityVariation : [utilityVariation];
        matchUtilities(
          group.reduce((obj, [classPrefix, properties]) => {
            return Object.assign(obj, {
              [classPrefix]: (value2) => {
                return properties.reduce((obj2, name) => {
                  if (Array.isArray(name)) {
                    return Object.assign(obj2, { [name[0]]: name[1] });
                  }
                  return Object.assign(obj2, { [name]: transformValue(value2) });
                }, {});
              }
            });
          }, {}),
          {
            ...options,
            values: filterDefault ? Object.fromEntries(
              Object.entries(theme(themeKey) ?? {}).filter(([modifier]) => modifier !== "DEFAULT")
            ) : theme(themeKey)
          }
        );
      }
    };
  }
  function buildMediaQuery(screens) {
    screens = Array.isArray(screens) ? screens : [screens];
    return screens.map((screen) => {
      let values = screen.values.map((screen2) => {
        if (screen2.raw !== void 0) {
          return screen2.raw;
        }
        return [
          screen2.min && `(min-width: ${screen2.min})`,
          screen2.max && `(max-width: ${screen2.max})`
        ].filter(Boolean).join(" and ");
      });
      return screen.not ? `not all and ${values}` : values;
    }).join(", ");
  }
  var DIRECTIONS = /* @__PURE__ */ new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
  var PLAY_STATES = /* @__PURE__ */ new Set(["running", "paused"]);
  var FILL_MODES = /* @__PURE__ */ new Set(["none", "forwards", "backwards", "both"]);
  var ITERATION_COUNTS = /* @__PURE__ */ new Set(["infinite"]);
  var TIMINGS = /* @__PURE__ */ new Set([
    "linear",
    "ease",
    "ease-in",
    "ease-out",
    "ease-in-out",
    "step-start",
    "step-end"
  ]);
  var TIMING_FNS = ["cubic-bezier", "steps"];
  var COMMA = /\,(?![^(]*\))/g;
  var SPACE2 = /\ +(?![^(]*\))/g;
  var TIME = /^(-?[\d.]+m?s)$/;
  var DIGIT = /^(\d+)$/;
  function parseAnimationValue(input) {
    let animations = input.split(COMMA);
    return animations.map((animation) => {
      let value2 = animation.trim();
      let result = { value: value2 };
      let parts = value2.split(SPACE2);
      let seen = /* @__PURE__ */ new Set();
      for (let part of parts) {
        if (!seen.has("DIRECTIONS") && DIRECTIONS.has(part)) {
          result.direction = part;
          seen.add("DIRECTIONS");
        } else if (!seen.has("PLAY_STATES") && PLAY_STATES.has(part)) {
          result.playState = part;
          seen.add("PLAY_STATES");
        } else if (!seen.has("FILL_MODES") && FILL_MODES.has(part)) {
          result.fillMode = part;
          seen.add("FILL_MODES");
        } else if (!seen.has("ITERATION_COUNTS") && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {
          result.iterationCount = part;
          seen.add("ITERATION_COUNTS");
        } else if (!seen.has("TIMING_FUNCTION") && TIMINGS.has(part)) {
          result.timingFunction = part;
          seen.add("TIMING_FUNCTION");
        } else if (!seen.has("TIMING_FUNCTION") && TIMING_FNS.some((f2) => part.startsWith(`${f2}(`))) {
          result.timingFunction = part;
          seen.add("TIMING_FUNCTION");
        } else if (!seen.has("DURATION") && TIME.test(part)) {
          result.duration = part;
          seen.add("DURATION");
        } else if (!seen.has("DELAY") && TIME.test(part)) {
          result.delay = part;
          seen.add("DELAY");
        } else if (!seen.has("NAME")) {
          result.name = part;
          seen.add("NAME");
        } else {
          if (!result.unknown)
            result.unknown = [];
          result.unknown.push(part);
        }
      }
      return result;
    });
  }
  var flattenColorPalette = (colors) => Object.assign(
    {},
    ...Object.entries(colors ?? {}).flatMap(
      ([color2, values]) => typeof values == "object" ? Object.entries(flattenColorPalette(values)).map(([number2, hex2]) => ({
        [color2 + (number2 === "DEFAULT" ? "" : `-${number2}`)]: hex2
      })) : [{ [`${color2}`]: values }]
    )
  );
  var flattenColorPalette_default = flattenColorPalette;
  function toColorValue(maybeFunction) {
    return typeof maybeFunction === "function" ? maybeFunction({}) : maybeFunction;
  }
  function normalizeScreens(screens, root2 = true) {
    if (Array.isArray(screens)) {
      return screens.map((screen) => {
        if (root2 && Array.isArray(screen)) {
          throw new Error("The tuple syntax is not supported for `screens`.");
        }
        if (typeof screen === "string") {
          return { name: screen.toString(), not: false, values: [{ min: screen, max: void 0 }] };
        }
        let [name, options] = screen;
        name = name.toString();
        if (typeof options === "string") {
          return { name, not: false, values: [{ min: options, max: void 0 }] };
        }
        if (Array.isArray(options)) {
          return { name, not: false, values: options.map((option) => resolveValue(option)) };
        }
        return { name, not: false, values: [resolveValue(options)] };
      });
    }
    return normalizeScreens(Object.entries(screens ?? {}), false);
  }
  function isScreenSortable(screen) {
    if (screen.values.length !== 1) {
      return { result: false, reason: "multiple-values" };
    } else if (screen.values[0].raw !== void 0) {
      return { result: false, reason: "raw-values" };
    } else if (screen.values[0].min !== void 0 && screen.values[0].max !== void 0) {
      return { result: false, reason: "min-and-max" };
    }
    return { result: true, reason: null };
  }
  function compareScreens(type, a, z) {
    let aScreen = toScreen(a, type);
    let zScreen = toScreen(z, type);
    let aSorting = isScreenSortable(aScreen);
    let bSorting = isScreenSortable(zScreen);
    if (aSorting.reason === "multiple-values" || bSorting.reason === "multiple-values") {
      throw new Error(
        "Attempted to sort a screen with multiple values. This should never happen. Please open a bug report."
      );
    } else if (aSorting.reason === "raw-values" || bSorting.reason === "raw-values") {
      throw new Error(
        "Attempted to sort a screen with raw values. This should never happen. Please open a bug report."
      );
    } else if (aSorting.reason === "min-and-max" || bSorting.reason === "min-and-max") {
      throw new Error(
        "Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report."
      );
    }
    let { min: aMin, max: aMax } = aScreen.values[0];
    let { min: zMin, max: zMax } = zScreen.values[0];
    if (a.not)
      [aMin, aMax] = [aMax, aMin];
    if (z.not)
      [zMin, zMax] = [zMax, zMin];
    aMin = aMin === void 0 ? aMin : parseFloat(aMin);
    aMax = aMax === void 0 ? aMax : parseFloat(aMax);
    zMin = zMin === void 0 ? zMin : parseFloat(zMin);
    zMax = zMax === void 0 ? zMax : parseFloat(zMax);
    let [aValue, zValue] = type === "min" ? [aMin, zMin] : [zMax, aMax];
    return aValue - zValue;
  }
  function toScreen(value2, type) {
    if (typeof value2 === "object") {
      return value2;
    }
    return {
      name: "arbitrary-screen",
      values: [{ [type]: value2 }]
    };
  }
  function resolveValue({ "min-width": _minWidth, min = _minWidth, max: max2, raw } = {}) {
    return { min, max: max2, raw };
  }
  function removeAlphaVariables(container, toRemove) {
    container.walkDecls((decl2) => {
      if (toRemove.includes(decl2.prop)) {
        decl2.remove();
        return;
      }
      for (let varName of toRemove) {
        if (decl2.value.includes(`/ var(${varName})`)) {
          decl2.value = decl2.value.replace(`/ var(${varName})`, "");
        }
      }
    });
  }
  var variantPlugins = {
    pseudoElementVariants: ({ addVariant }) => {
      addVariant("first-letter", "&::first-letter");
      addVariant("first-line", "&::first-line");
      addVariant("marker", [
        ({ container }) => {
          removeAlphaVariables(container, ["--tw-text-opacity"]);
          return "& *::marker";
        },
        ({ container }) => {
          removeAlphaVariables(container, ["--tw-text-opacity"]);
          return "&::marker";
        }
      ]);
      addVariant("selection", ["& *::selection", "&::selection"]);
      addVariant("file", "&::file-selector-button");
      addVariant("placeholder", "&::placeholder");
      addVariant("backdrop", "&::backdrop");
      addVariant("before", ({ container }) => {
        container.walkRules((rule2) => {
          let foundContent = false;
          rule2.walkDecls("content", () => {
            foundContent = true;
          });
          if (!foundContent) {
            rule2.prepend(postcss_default.decl({ prop: "content", value: "var(--tw-content)" }));
          }
        });
        return "&::before";
      });
      addVariant("after", ({ container }) => {
        container.walkRules((rule2) => {
          let foundContent = false;
          rule2.walkDecls("content", () => {
            foundContent = true;
          });
          if (!foundContent) {
            rule2.prepend(postcss_default.decl({ prop: "content", value: "var(--tw-content)" }));
          }
        });
        return "&::after";
      });
    },
    pseudoClassVariants: ({ addVariant, matchVariant, config }) => {
      let pseudoVariants = [
        // Positional
        ["first", "&:first-child"],
        ["last", "&:last-child"],
        ["only", "&:only-child"],
        ["odd", "&:nth-child(odd)"],
        ["even", "&:nth-child(even)"],
        "first-of-type",
        "last-of-type",
        "only-of-type",
        // State
        [
          "visited",
          ({ container }) => {
            removeAlphaVariables(container, [
              "--tw-text-opacity",
              "--tw-border-opacity",
              "--tw-bg-opacity"
            ]);
            return "&:visited";
          }
        ],
        "target",
        ["open", "&[open]"],
        // Forms
        "default",
        "checked",
        "indeterminate",
        "placeholder-shown",
        "autofill",
        "optional",
        "required",
        "valid",
        "invalid",
        "in-range",
        "out-of-range",
        "read-only",
        // Content
        "empty",
        // Interactive
        "focus-within",
        [
          "hover",
          !flagEnabled(config(), "hoverOnlyWhenSupported") ? "&:hover" : "@media (hover: hover) and (pointer: fine) { &:hover }"
        ],
        "focus",
        "focus-visible",
        "active",
        "enabled",
        "disabled"
      ].map((variant) => Array.isArray(variant) ? variant : [variant, `&:${variant}`]);
      for (let [variantName, state] of pseudoVariants) {
        addVariant(variantName, (ctx) => {
          let result = typeof state === "function" ? state(ctx) : state;
          return result;
        });
      }
      let variants = {
        group: (_, { modifier }) => modifier ? [`:merge(.group\\/${escapeClassName(modifier)})`, " &"] : [`:merge(.group)`, " &"],
        peer: (_, { modifier }) => modifier ? [`:merge(.peer\\/${escapeClassName(modifier)})`, " ~ &"] : [`:merge(.peer)`, " ~ &"]
      };
      for (let [name, fn2] of Object.entries(variants)) {
        matchVariant(
          name,
          (value2 = "", extra) => {
            let result = normalize2(typeof value2 === "function" ? value2(extra) : value2);
            if (!result.includes("&"))
              result = "&" + result;
            let [a, b] = fn2("", extra);
            let start = null;
            let end = null;
            let quotes2 = 0;
            for (let i = 0; i < result.length; ++i) {
              let c4 = result[i];
              if (c4 === "&") {
                start = i;
              } else if (c4 === "'" || c4 === '"') {
                quotes2 += 1;
              } else if (start !== null && c4 === " " && !quotes2) {
                end = i;
              }
            }
            if (start !== null && end === null) {
              end = result.length;
            }
            return result.slice(0, start) + a + result.slice(start + 1, end) + b + result.slice(end);
          },
          { values: Object.fromEntries(pseudoVariants) }
        );
      }
    },
    directionVariants: ({ addVariant }) => {
      addVariant("ltr", () => {
        log_default.warn("rtl-experimental", [
          "The RTL features in Tailwind CSS are currently in preview.",
          "Preview features are not covered by semver, and may be improved in breaking ways at any time."
        ]);
        return '[dir="ltr"] &';
      });
      addVariant("rtl", () => {
        log_default.warn("rtl-experimental", [
          "The RTL features in Tailwind CSS are currently in preview.",
          "Preview features are not covered by semver, and may be improved in breaking ways at any time."
        ]);
        return '[dir="rtl"] &';
      });
    },
    reducedMotionVariants: ({ addVariant }) => {
      addVariant("motion-safe", "@media (prefers-reduced-motion: no-preference)");
      addVariant("motion-reduce", "@media (prefers-reduced-motion: reduce)");
    },
    darkVariants: ({ config, addVariant }) => {
      let [mode, className = ".dark"] = [].concat(config("darkMode", "media"));
      if (mode === false) {
        mode = "media";
        log_default.warn("darkmode-false", [
          "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
          "Change `darkMode` to `media` or remove it entirely.",
          "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
        ]);
      }
      if (mode === "class") {
        addVariant("dark", `${className} &`);
      } else if (mode === "media") {
        addVariant("dark", "@media (prefers-color-scheme: dark)");
      }
    },
    printVariant: ({ addVariant }) => {
      addVariant("print", "@media print");
    },
    screenVariants: ({ theme, addVariant, matchVariant }) => {
      let rawScreens = theme("screens") ?? {};
      let areSimpleScreens = Object.values(rawScreens).every((v) => typeof v === "string");
      let screens = normalizeScreens(theme("screens"));
      let unitCache = /* @__PURE__ */ new Set([]);
      function units(value2) {
        return value2.match(/(\D+)$/)?.[1] ?? "(none)";
      }
      function recordUnits(value2) {
        if (value2 !== void 0) {
          unitCache.add(units(value2));
        }
      }
      function canUseUnits(value2) {
        recordUnits(value2);
        return unitCache.size === 1;
      }
      for (const screen of screens) {
        for (const value2 of screen.values) {
          recordUnits(value2.min);
          recordUnits(value2.max);
        }
      }
      let screensUseConsistentUnits = unitCache.size <= 1;
      function buildScreenValues(type) {
        return Object.fromEntries(
          screens.filter((screen) => isScreenSortable(screen).result).map((screen) => {
            let { min, max: max2 } = screen.values[0];
            if (type === "min" && min !== void 0) {
              return screen;
            } else if (type === "min" && max2 !== void 0) {
              return { ...screen, not: !screen.not };
            } else if (type === "max" && max2 !== void 0) {
              return screen;
            } else if (type === "max" && min !== void 0) {
              return { ...screen, not: !screen.not };
            }
          }).map((screen) => [screen.name, screen])
        );
      }
      function buildSort(type) {
        return (a, z) => compareScreens(type, a.value, z.value);
      }
      let maxSort = buildSort("max");
      let minSort = buildSort("min");
      function buildScreenVariant(type) {
        return (value2) => {
          if (!areSimpleScreens) {
            log_default.warn("complex-screen-config", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
            ]);
            return [];
          } else if (!screensUseConsistentUnits) {
            log_default.warn("mixed-screen-units", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
            ]);
            return [];
          } else if (typeof value2 === "string" && !canUseUnits(value2)) {
            log_default.warn("minmax-have-mixed-units", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
            ]);
            return [];
          }
          return [`@media ${buildMediaQuery(toScreen(value2, type))}`];
        };
      }
      matchVariant("max", buildScreenVariant("max"), {
        sort: maxSort,
        values: areSimpleScreens ? buildScreenValues("max") : {}
      });
      let id = "min-screens";
      for (let screen of screens) {
        addVariant(screen.name, `@media ${buildMediaQuery(screen)}`, {
          id,
          sort: areSimpleScreens && screensUseConsistentUnits ? minSort : void 0,
          value: screen
        });
      }
      matchVariant("min", buildScreenVariant("min"), {
        id,
        sort: minSort
      });
    },
    supportsVariants: ({ matchVariant, theme }) => {
      matchVariant(
        "supports",
        (value2 = "") => {
          let check = normalize2(value2);
          let isRaw = /^\w*\s*\(/.test(check);
          check = isRaw ? check.replace(/\b(and|or|not)\b/g, " $1 ") : check;
          if (isRaw) {
            return `@supports ${check}`;
          }
          if (!check.includes(":")) {
            check = `${check}: var(--tw)`;
          }
          if (!(check.startsWith("(") && check.endsWith(")"))) {
            check = `(${check})`;
          }
          return `@supports ${check}`;
        },
        { values: theme("supports") ?? {} }
      );
    },
    ariaVariants: ({ matchVariant, theme }) => {
      matchVariant("aria", (value2) => `&[aria-${normalize2(value2)}]`, { values: theme("aria") ?? {} });
      matchVariant(
        "group-aria",
        (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier})[aria-${normalize2(value2)}] &` : `:merge(.group)[aria-${normalize2(value2)}] &`,
        { values: theme("aria") ?? {} }
      );
      matchVariant(
        "peer-aria",
        (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[aria-${normalize2(value2)}] ~ &` : `:merge(.peer)[aria-${normalize2(value2)}] ~ &`,
        { values: theme("aria") ?? {} }
      );
    },
    dataVariants: ({ matchVariant, theme }) => {
      matchVariant("data", (value2) => `&[data-${normalize2(value2)}]`, { values: theme("data") ?? {} });
      matchVariant(
        "group-data",
        (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier})[data-${normalize2(value2)}] &` : `:merge(.group)[data-${normalize2(value2)}] &`,
        { values: theme("data") ?? {} }
      );
      matchVariant(
        "peer-data",
        (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[data-${normalize2(value2)}] ~ &` : `:merge(.peer)[data-${normalize2(value2)}] ~ &`,
        { values: theme("data") ?? {} }
      );
    },
    orientationVariants: ({ addVariant }) => {
      addVariant("portrait", "@media (orientation: portrait)");
      addVariant("landscape", "@media (orientation: landscape)");
    },
    prefersContrastVariants: ({ addVariant }) => {
      addVariant("contrast-more", "@media (prefers-contrast: more)");
      addVariant("contrast-less", "@media (prefers-contrast: less)");
    }
  };
  var cssTransformValue = [
    "translate(var(--tw-translate-x), var(--tw-translate-y))",
    "rotate(var(--tw-rotate))",
    "skewX(var(--tw-skew-x))",
    "skewY(var(--tw-skew-y))",
    "scaleX(var(--tw-scale-x))",
    "scaleY(var(--tw-scale-y))"
  ].join(" ");
  var cssFilterValue = [
    "var(--tw-blur)",
    "var(--tw-brightness)",
    "var(--tw-contrast)",
    "var(--tw-grayscale)",
    "var(--tw-hue-rotate)",
    "var(--tw-invert)",
    "var(--tw-saturate)",
    "var(--tw-sepia)",
    "var(--tw-drop-shadow)"
  ].join(" ");
  var cssBackdropFilterValue = [
    "var(--tw-backdrop-blur)",
    "var(--tw-backdrop-brightness)",
    "var(--tw-backdrop-contrast)",
    "var(--tw-backdrop-grayscale)",
    "var(--tw-backdrop-hue-rotate)",
    "var(--tw-backdrop-invert)",
    "var(--tw-backdrop-opacity)",
    "var(--tw-backdrop-saturate)",
    "var(--tw-backdrop-sepia)"
  ].join(" ");
  var corePlugins = {
    preflight: ({ addBase }) => {
      let preflightStyles = postcss_default.parse(
        fs_default.readFileSync(join("/", "./css/preflight.css"), "utf8")
      );
      addBase([
        postcss_default.comment({
          text: `! tailwindcss v${version} | MIT License | https://tailwindcss.com`
        }),
        ...preflightStyles.nodes
      ]);
    },
    container: /* @__PURE__ */ (() => {
      function extractMinWidths(breakpoints = []) {
        return breakpoints.flatMap((breakpoint) => breakpoint.values.map((breakpoint2) => breakpoint2.min)).filter((v) => v !== void 0);
      }
      function mapMinWidthsToPadding(minWidths, screens, paddings) {
        if (typeof paddings === "undefined") {
          return [];
        }
        if (!(typeof paddings === "object" && paddings !== null)) {
          return [
            {
              screen: "DEFAULT",
              minWidth: 0,
              padding: paddings
            }
          ];
        }
        let mapping = [];
        if (paddings.DEFAULT) {
          mapping.push({
            screen: "DEFAULT",
            minWidth: 0,
            padding: paddings.DEFAULT
          });
        }
        for (let minWidth of minWidths) {
          for (let screen of screens) {
            for (let { min } of screen.values) {
              if (min === minWidth) {
                mapping.push({ minWidth, padding: paddings[screen.name] });
              }
            }
          }
        }
        return mapping;
      }
      return function({ addComponents, theme }) {
        let screens = normalizeScreens(theme("container.screens", theme("screens")));
        let minWidths = extractMinWidths(screens);
        let paddings = mapMinWidthsToPadding(minWidths, screens, theme("container.padding"));
        let generatePaddingFor = (minWidth) => {
          let paddingConfig = paddings.find((padding) => padding.minWidth === minWidth);
          if (!paddingConfig) {
            return {};
          }
          return {
            paddingRight: paddingConfig.padding,
            paddingLeft: paddingConfig.padding
          };
        };
        let atRules = Array.from(
          new Set(minWidths.slice().sort((a, z) => parseInt(a) - parseInt(z)))
        ).map((minWidth) => ({
          [`@media (min-width: ${minWidth})`]: {
            ".container": {
              "max-width": minWidth,
              ...generatePaddingFor(minWidth)
            }
          }
        }));
        addComponents([
          {
            ".container": Object.assign(
              { width: "100%" },
              theme("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {},
              generatePaddingFor(0)
            )
          },
          ...atRules
        ]);
      };
    })(),
    accessibility: ({ addUtilities }) => {
      addUtilities({
        ".sr-only": {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: "0",
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          borderWidth: "0"
        },
        ".not-sr-only": {
          position: "static",
          width: "auto",
          height: "auto",
          padding: "0",
          margin: "0",
          overflow: "visible",
          clip: "auto",
          whiteSpace: "normal"
        }
      });
    },
    pointerEvents: ({ addUtilities }) => {
      addUtilities({
        ".pointer-events-none": { "pointer-events": "none" },
        ".pointer-events-auto": { "pointer-events": "auto" }
      });
    },
    visibility: ({ addUtilities }) => {
      addUtilities({
        ".visible": { visibility: "visible" },
        ".invisible": { visibility: "hidden" },
        ".collapse": { visibility: "collapse" }
      });
    },
    position: ({ addUtilities }) => {
      addUtilities({
        ".static": { position: "static" },
        ".fixed": { position: "fixed" },
        ".absolute": { position: "absolute" },
        ".relative": { position: "relative" },
        ".sticky": { position: "sticky" }
      });
    },
    inset: createUtilityPlugin(
      "inset",
      [
        ["inset", ["top", "right", "bottom", "left"]],
        [
          ["inset-x", ["left", "right"]],
          ["inset-y", ["top", "bottom"]]
        ],
        [
          ["top", ["top"]],
          ["right", ["right"]],
          ["bottom", ["bottom"]],
          ["left", ["left"]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    isolation: ({ addUtilities }) => {
      addUtilities({
        ".isolate": { isolation: "isolate" },
        ".isolation-auto": { isolation: "auto" }
      });
    },
    zIndex: createUtilityPlugin("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }),
    order: createUtilityPlugin("order", void 0, { supportsNegativeValues: true }),
    gridColumn: createUtilityPlugin("gridColumn", [["col", ["gridColumn"]]]),
    gridColumnStart: createUtilityPlugin("gridColumnStart", [["col-start", ["gridColumnStart"]]]),
    gridColumnEnd: createUtilityPlugin("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]),
    gridRow: createUtilityPlugin("gridRow", [["row", ["gridRow"]]]),
    gridRowStart: createUtilityPlugin("gridRowStart", [["row-start", ["gridRowStart"]]]),
    gridRowEnd: createUtilityPlugin("gridRowEnd", [["row-end", ["gridRowEnd"]]]),
    float: ({ addUtilities }) => {
      addUtilities({
        ".float-right": { float: "right" },
        ".float-left": { float: "left" },
        ".float-none": { float: "none" }
      });
    },
    clear: ({ addUtilities }) => {
      addUtilities({
        ".clear-left": { clear: "left" },
        ".clear-right": { clear: "right" },
        ".clear-both": { clear: "both" },
        ".clear-none": { clear: "none" }
      });
    },
    margin: createUtilityPlugin(
      "margin",
      [
        ["m", ["margin"]],
        [
          ["mx", ["margin-left", "margin-right"]],
          ["my", ["margin-top", "margin-bottom"]]
        ],
        [
          ["mt", ["margin-top"]],
          ["mr", ["margin-right"]],
          ["mb", ["margin-bottom"]],
          ["ml", ["margin-left"]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    boxSizing: ({ addUtilities }) => {
      addUtilities({
        ".box-border": { "box-sizing": "border-box" },
        ".box-content": { "box-sizing": "content-box" }
      });
    },
    display: ({ addUtilities }) => {
      addUtilities({
        ".block": { display: "block" },
        ".inline-block": { display: "inline-block" },
        ".inline": { display: "inline" },
        ".flex": { display: "flex" },
        ".inline-flex": { display: "inline-flex" },
        ".table": { display: "table" },
        ".inline-table": { display: "inline-table" },
        ".table-caption": { display: "table-caption" },
        ".table-cell": { display: "table-cell" },
        ".table-column": { display: "table-column" },
        ".table-column-group": { display: "table-column-group" },
        ".table-footer-group": { display: "table-footer-group" },
        ".table-header-group": { display: "table-header-group" },
        ".table-row-group": { display: "table-row-group" },
        ".table-row": { display: "table-row" },
        ".flow-root": { display: "flow-root" },
        ".grid": { display: "grid" },
        ".inline-grid": { display: "inline-grid" },
        ".contents": { display: "contents" },
        ".list-item": { display: "list-item" },
        ".hidden": { display: "none" }
      });
    },
    aspectRatio: createUtilityPlugin("aspectRatio", [["aspect", ["aspect-ratio"]]]),
    height: createUtilityPlugin("height", [["h", ["height"]]]),
    maxHeight: createUtilityPlugin("maxHeight", [["max-h", ["maxHeight"]]]),
    minHeight: createUtilityPlugin("minHeight", [["min-h", ["minHeight"]]]),
    width: createUtilityPlugin("width", [["w", ["width"]]]),
    minWidth: createUtilityPlugin("minWidth", [["min-w", ["minWidth"]]]),
    maxWidth: createUtilityPlugin("maxWidth", [["max-w", ["maxWidth"]]]),
    flex: createUtilityPlugin("flex"),
    flexShrink: createUtilityPlugin("flexShrink", [
      ["flex-shrink", ["flex-shrink"]],
      // Deprecated
      ["shrink", ["flex-shrink"]]
    ]),
    flexGrow: createUtilityPlugin("flexGrow", [
      ["flex-grow", ["flex-grow"]],
      // Deprecated
      ["grow", ["flex-grow"]]
    ]),
    flexBasis: createUtilityPlugin("flexBasis", [["basis", ["flex-basis"]]]),
    tableLayout: ({ addUtilities }) => {
      addUtilities({
        ".table-auto": { "table-layout": "auto" },
        ".table-fixed": { "table-layout": "fixed" }
      });
    },
    borderCollapse: ({ addUtilities }) => {
      addUtilities({
        ".border-collapse": { "border-collapse": "collapse" },
        ".border-separate": { "border-collapse": "separate" }
      });
    },
    borderSpacing: ({ addDefaults, matchUtilities, theme }) => {
      addDefaults("border-spacing", {
        "--tw-border-spacing-x": 0,
        "--tw-border-spacing-y": 0
      });
      matchUtilities(
        {
          "border-spacing": (value2) => {
            return {
              "--tw-border-spacing-x": value2,
              "--tw-border-spacing-y": value2,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          },
          "border-spacing-x": (value2) => {
            return {
              "--tw-border-spacing-x": value2,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          },
          "border-spacing-y": (value2) => {
            return {
              "--tw-border-spacing-y": value2,
              "@defaults border-spacing": {},
              "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
            };
          }
        },
        { values: theme("borderSpacing") }
      );
    },
    transformOrigin: createUtilityPlugin("transformOrigin", [["origin", ["transformOrigin"]]]),
    translate: createUtilityPlugin(
      "translate",
      [
        [
          [
            "translate-x",
            [["@defaults transform", {}], "--tw-translate-x", ["transform", cssTransformValue]]
          ],
          [
            "translate-y",
            [["@defaults transform", {}], "--tw-translate-y", ["transform", cssTransformValue]]
          ]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    rotate: createUtilityPlugin(
      "rotate",
      [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", cssTransformValue]]]],
      { supportsNegativeValues: true }
    ),
    skew: createUtilityPlugin(
      "skew",
      [
        [
          ["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", cssTransformValue]]],
          ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", cssTransformValue]]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    scale: createUtilityPlugin(
      "scale",
      [
        [
          "scale",
          [
            ["@defaults transform", {}],
            "--tw-scale-x",
            "--tw-scale-y",
            ["transform", cssTransformValue]
          ]
        ],
        [
          [
            "scale-x",
            [["@defaults transform", {}], "--tw-scale-x", ["transform", cssTransformValue]]
          ],
          [
            "scale-y",
            [["@defaults transform", {}], "--tw-scale-y", ["transform", cssTransformValue]]
          ]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    transform: ({ addDefaults, addUtilities }) => {
      addDefaults("transform", {
        "--tw-translate-x": "0",
        "--tw-translate-y": "0",
        "--tw-rotate": "0",
        "--tw-skew-x": "0",
        "--tw-skew-y": "0",
        "--tw-scale-x": "1",
        "--tw-scale-y": "1"
      });
      addUtilities({
        ".transform": { "@defaults transform": {}, transform: cssTransformValue },
        ".transform-cpu": {
          transform: cssTransformValue
        },
        ".transform-gpu": {
          transform: cssTransformValue.replace(
            "translate(var(--tw-translate-x), var(--tw-translate-y))",
            "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)"
          )
        },
        ".transform-none": { transform: "none" }
      });
    },
    animation: ({ matchUtilities, theme, config }) => {
      let prefixName = (name) => `${config("prefix")}${escapeClassName(name)}`;
      let keyframes = Object.fromEntries(
        Object.entries(theme("keyframes") ?? {}).map(([key, value2]) => {
          return [key, { [`@keyframes ${prefixName(key)}`]: value2 }];
        })
      );
      matchUtilities(
        {
          animate: (value2) => {
            let animations = parseAnimationValue(value2);
            return [
              ...animations.flatMap((animation) => keyframes[animation.name]),
              {
                animation: animations.map(({ name, value: value3 }) => {
                  if (name === void 0 || keyframes[name] === void 0) {
                    return value3;
                  }
                  return value3.replace(name, prefixName(name));
                }).join(", ")
              }
            ];
          }
        },
        { values: theme("animation") }
      );
    },
    cursor: createUtilityPlugin("cursor"),
    touchAction: ({ addDefaults, addUtilities }) => {
      addDefaults("touch-action", {
        "--tw-pan-x": " ",
        "--tw-pan-y": " ",
        "--tw-pinch-zoom": " "
      });
      let cssTouchActionValue = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
      addUtilities({
        ".touch-auto": { "touch-action": "auto" },
        ".touch-none": { "touch-action": "none" },
        ".touch-pan-x": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-x",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-left": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-left",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-right": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-right",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-y": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-y",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-up": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-up",
          "touch-action": cssTouchActionValue
        },
        ".touch-pan-down": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-down",
          "touch-action": cssTouchActionValue
        },
        ".touch-pinch-zoom": {
          "@defaults touch-action": {},
          "--tw-pinch-zoom": "pinch-zoom",
          "touch-action": cssTouchActionValue
        },
        ".touch-manipulation": { "touch-action": "manipulation" }
      });
    },
    userSelect: ({ addUtilities }) => {
      addUtilities({
        ".select-none": { "user-select": "none" },
        ".select-text": { "user-select": "text" },
        ".select-all": { "user-select": "all" },
        ".select-auto": { "user-select": "auto" }
      });
    },
    resize: ({ addUtilities }) => {
      addUtilities({
        ".resize-none": { resize: "none" },
        ".resize-y": { resize: "vertical" },
        ".resize-x": { resize: "horizontal" },
        ".resize": { resize: "both" }
      });
    },
    scrollSnapType: ({ addDefaults, addUtilities }) => {
      addDefaults("scroll-snap-type", {
        "--tw-scroll-snap-strictness": "proximity"
      });
      addUtilities({
        ".snap-none": { "scroll-snap-type": "none" },
        ".snap-x": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
        },
        ".snap-y": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
        },
        ".snap-both": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
        },
        ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" },
        ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" }
      });
    },
    scrollSnapAlign: ({ addUtilities }) => {
      addUtilities({
        ".snap-start": { "scroll-snap-align": "start" },
        ".snap-end": { "scroll-snap-align": "end" },
        ".snap-center": { "scroll-snap-align": "center" },
        ".snap-align-none": { "scroll-snap-align": "none" }
      });
    },
    scrollSnapStop: ({ addUtilities }) => {
      addUtilities({
        ".snap-normal": { "scroll-snap-stop": "normal" },
        ".snap-always": { "scroll-snap-stop": "always" }
      });
    },
    scrollMargin: createUtilityPlugin(
      "scrollMargin",
      [
        ["scroll-m", ["scroll-margin"]],
        [
          ["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]],
          ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]
        ],
        [
          ["scroll-mt", ["scroll-margin-top"]],
          ["scroll-mr", ["scroll-margin-right"]],
          ["scroll-mb", ["scroll-margin-bottom"]],
          ["scroll-ml", ["scroll-margin-left"]]
        ]
      ],
      { supportsNegativeValues: true }
    ),
    scrollPadding: createUtilityPlugin("scrollPadding", [
      ["scroll-p", ["scroll-padding"]],
      [
        ["scroll-px", ["scroll-padding-left", "scroll-padding-right"]],
        ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]
      ],
      [
        ["scroll-pt", ["scroll-padding-top"]],
        ["scroll-pr", ["scroll-padding-right"]],
        ["scroll-pb", ["scroll-padding-bottom"]],
        ["scroll-pl", ["scroll-padding-left"]]
      ]
    ]),
    listStylePosition: ({ addUtilities }) => {
      addUtilities({
        ".list-inside": { "list-style-position": "inside" },
        ".list-outside": { "list-style-position": "outside" }
      });
    },
    listStyleType: createUtilityPlugin("listStyleType", [["list", ["listStyleType"]]]),
    appearance: ({ addUtilities }) => {
      addUtilities({
        ".appearance-none": { appearance: "none" }
      });
    },
    columns: createUtilityPlugin("columns", [["columns", ["columns"]]]),
    breakBefore: ({ addUtilities }) => {
      addUtilities({
        ".break-before-auto": { "break-before": "auto" },
        ".break-before-avoid": { "break-before": "avoid" },
        ".break-before-all": { "break-before": "all" },
        ".break-before-avoid-page": { "break-before": "avoid-page" },
        ".break-before-page": { "break-before": "page" },
        ".break-before-left": { "break-before": "left" },
        ".break-before-right": { "break-before": "right" },
        ".break-before-column": { "break-before": "column" }
      });
    },
    breakInside: ({ addUtilities }) => {
      addUtilities({
        ".break-inside-auto": { "break-inside": "auto" },
        ".break-inside-avoid": { "break-inside": "avoid" },
        ".break-inside-avoid-page": { "break-inside": "avoid-page" },
        ".break-inside-avoid-column": { "break-inside": "avoid-column" }
      });
    },
    breakAfter: ({ addUtilities }) => {
      addUtilities({
        ".break-after-auto": { "break-after": "auto" },
        ".break-after-avoid": { "break-after": "avoid" },
        ".break-after-all": { "break-after": "all" },
        ".break-after-avoid-page": { "break-after": "avoid-page" },
        ".break-after-page": { "break-after": "page" },
        ".break-after-left": { "break-after": "left" },
        ".break-after-right": { "break-after": "right" },
        ".break-after-column": { "break-after": "column" }
      });
    },
    gridAutoColumns: createUtilityPlugin("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]),
    gridAutoFlow: ({ addUtilities }) => {
      addUtilities({
        ".grid-flow-row": { gridAutoFlow: "row" },
        ".grid-flow-col": { gridAutoFlow: "column" },
        ".grid-flow-dense": { gridAutoFlow: "dense" },
        ".grid-flow-row-dense": { gridAutoFlow: "row dense" },
        ".grid-flow-col-dense": { gridAutoFlow: "column dense" }
      });
    },
    gridAutoRows: createUtilityPlugin("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]),
    gridTemplateColumns: createUtilityPlugin("gridTemplateColumns", [
      ["grid-cols", ["gridTemplateColumns"]]
    ]),
    gridTemplateRows: createUtilityPlugin("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]),
    flexDirection: ({ addUtilities }) => {
      addUtilities({
        ".flex-row": { "flex-direction": "row" },
        ".flex-row-reverse": { "flex-direction": "row-reverse" },
        ".flex-col": { "flex-direction": "column" },
        ".flex-col-reverse": { "flex-direction": "column-reverse" }
      });
    },
    flexWrap: ({ addUtilities }) => {
      addUtilities({
        ".flex-wrap": { "flex-wrap": "wrap" },
        ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" },
        ".flex-nowrap": { "flex-wrap": "nowrap" }
      });
    },
    placeContent: ({ addUtilities }) => {
      addUtilities({
        ".place-content-center": { "place-content": "center" },
        ".place-content-start": { "place-content": "start" },
        ".place-content-end": { "place-content": "end" },
        ".place-content-between": { "place-content": "space-between" },
        ".place-content-around": { "place-content": "space-around" },
        ".place-content-evenly": { "place-content": "space-evenly" },
        ".place-content-baseline": { "place-content": "baseline" },
        ".place-content-stretch": { "place-content": "stretch" }
      });
    },
    placeItems: ({ addUtilities }) => {
      addUtilities({
        ".place-items-start": { "place-items": "start" },
        ".place-items-end": { "place-items": "end" },
        ".place-items-center": { "place-items": "center" },
        ".place-items-baseline": { "place-items": "baseline" },
        ".place-items-stretch": { "place-items": "stretch" }
      });
    },
    alignContent: ({ addUtilities }) => {
      addUtilities({
        ".content-center": { "align-content": "center" },
        ".content-start": { "align-content": "flex-start" },
        ".content-end": { "align-content": "flex-end" },
        ".content-between": { "align-content": "space-between" },
        ".content-around": { "align-content": "space-around" },
        ".content-evenly": { "align-content": "space-evenly" },
        ".content-baseline": { "align-content": "baseline" }
      });
    },
    alignItems: ({ addUtilities }) => {
      addUtilities({
        ".items-start": { "align-items": "flex-start" },
        ".items-end": { "align-items": "flex-end" },
        ".items-center": { "align-items": "center" },
        ".items-baseline": { "align-items": "baseline" },
        ".items-stretch": { "align-items": "stretch" }
      });
    },
    justifyContent: ({ addUtilities }) => {
      addUtilities({
        ".justify-start": { "justify-content": "flex-start" },
        ".justify-end": { "justify-content": "flex-end" },
        ".justify-center": { "justify-content": "center" },
        ".justify-between": { "justify-content": "space-between" },
        ".justify-around": { "justify-content": "space-around" },
        ".justify-evenly": { "justify-content": "space-evenly" }
      });
    },
    justifyItems: ({ addUtilities }) => {
      addUtilities({
        ".justify-items-start": { "justify-items": "start" },
        ".justify-items-end": { "justify-items": "end" },
        ".justify-items-center": { "justify-items": "center" },
        ".justify-items-stretch": { "justify-items": "stretch" }
      });
    },
    gap: createUtilityPlugin("gap", [
      ["gap", ["gap"]],
      [
        ["gap-x", ["columnGap"]],
        ["gap-y", ["rowGap"]]
      ]
    ]),
    space: ({ matchUtilities, addUtilities, theme }) => {
      matchUtilities(
        {
          "space-x": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-x-reverse": "0",
                "margin-right": `calc(${value2} * var(--tw-space-x-reverse))`,
                "margin-left": `calc(${value2} * calc(1 - var(--tw-space-x-reverse)))`
              }
            };
          },
          "space-y": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-y-reverse": "0",
                "margin-top": `calc(${value2} * calc(1 - var(--tw-space-y-reverse)))`,
                "margin-bottom": `calc(${value2} * var(--tw-space-y-reverse))`
              }
            };
          }
        },
        { values: theme("space"), supportsNegativeValues: true }
      );
      addUtilities({
        ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" },
        ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" }
      });
    },
    divideWidth: ({ matchUtilities, addUtilities, theme }) => {
      matchUtilities(
        {
          "divide-x": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-x-reverse": "0",
                "border-right-width": `calc(${value2} * var(--tw-divide-x-reverse))`,
                "border-left-width": `calc(${value2} * calc(1 - var(--tw-divide-x-reverse)))`
              }
            };
          },
          "divide-y": (value2) => {
            value2 = value2 === "0" ? "0px" : value2;
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-y-reverse": "0",
                "border-top-width": `calc(${value2} * calc(1 - var(--tw-divide-y-reverse)))`,
                "border-bottom-width": `calc(${value2} * var(--tw-divide-y-reverse))`
              }
            };
          }
        },
        { values: theme("divideWidth"), type: ["line-width", "length", "any"] }
      );
      addUtilities({
        ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
          "@defaults border-width": {},
          "--tw-divide-y-reverse": "1"
        },
        ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
          "@defaults border-width": {},
          "--tw-divide-x-reverse": "1"
        }
      });
    },
    divideStyle: ({ addUtilities }) => {
      addUtilities({
        ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" },
        ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" },
        ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" },
        ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" },
        ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" }
      });
    },
    divideColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          divide: (value2) => {
            if (!corePlugins2("divideOpacity")) {
              return {
                ["& > :not([hidden]) ~ :not([hidden])"]: {
                  "border-color": toColorValue(value2)
                }
              };
            }
            return {
              ["& > :not([hidden]) ~ :not([hidden])"]: withAlphaVariable({
                color: value2,
                property: "border-color",
                variable: "--tw-divide-opacity"
              })
            };
          }
        },
        {
          values: (({ DEFAULT: _, ...colors }) => colors)(flattenColorPalette_default(theme("divideColor"))),
          type: ["color", "any"]
        }
      );
    },
    divideOpacity: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "divide-opacity": (value2) => {
            return { [`& > :not([hidden]) ~ :not([hidden])`]: { "--tw-divide-opacity": value2 } };
          }
        },
        { values: theme("divideOpacity") }
      );
    },
    placeSelf: ({ addUtilities }) => {
      addUtilities({
        ".place-self-auto": { "place-self": "auto" },
        ".place-self-start": { "place-self": "start" },
        ".place-self-end": { "place-self": "end" },
        ".place-self-center": { "place-self": "center" },
        ".place-self-stretch": { "place-self": "stretch" }
      });
    },
    alignSelf: ({ addUtilities }) => {
      addUtilities({
        ".self-auto": { "align-self": "auto" },
        ".self-start": { "align-self": "flex-start" },
        ".self-end": { "align-self": "flex-end" },
        ".self-center": { "align-self": "center" },
        ".self-stretch": { "align-self": "stretch" },
        ".self-baseline": { "align-self": "baseline" }
      });
    },
    justifySelf: ({ addUtilities }) => {
      addUtilities({
        ".justify-self-auto": { "justify-self": "auto" },
        ".justify-self-start": { "justify-self": "start" },
        ".justify-self-end": { "justify-self": "end" },
        ".justify-self-center": { "justify-self": "center" },
        ".justify-self-stretch": { "justify-self": "stretch" }
      });
    },
    overflow: ({ addUtilities }) => {
      addUtilities({
        ".overflow-auto": { overflow: "auto" },
        ".overflow-hidden": { overflow: "hidden" },
        ".overflow-clip": { overflow: "clip" },
        ".overflow-visible": { overflow: "visible" },
        ".overflow-scroll": { overflow: "scroll" },
        ".overflow-x-auto": { "overflow-x": "auto" },
        ".overflow-y-auto": { "overflow-y": "auto" },
        ".overflow-x-hidden": { "overflow-x": "hidden" },
        ".overflow-y-hidden": { "overflow-y": "hidden" },
        ".overflow-x-clip": { "overflow-x": "clip" },
        ".overflow-y-clip": { "overflow-y": "clip" },
        ".overflow-x-visible": { "overflow-x": "visible" },
        ".overflow-y-visible": { "overflow-y": "visible" },
        ".overflow-x-scroll": { "overflow-x": "scroll" },
        ".overflow-y-scroll": { "overflow-y": "scroll" }
      });
    },
    overscrollBehavior: ({ addUtilities }) => {
      addUtilities({
        ".overscroll-auto": { "overscroll-behavior": "auto" },
        ".overscroll-contain": { "overscroll-behavior": "contain" },
        ".overscroll-none": { "overscroll-behavior": "none" },
        ".overscroll-y-auto": { "overscroll-behavior-y": "auto" },
        ".overscroll-y-contain": { "overscroll-behavior-y": "contain" },
        ".overscroll-y-none": { "overscroll-behavior-y": "none" },
        ".overscroll-x-auto": { "overscroll-behavior-x": "auto" },
        ".overscroll-x-contain": { "overscroll-behavior-x": "contain" },
        ".overscroll-x-none": { "overscroll-behavior-x": "none" }
      });
    },
    scrollBehavior: ({ addUtilities }) => {
      addUtilities({
        ".scroll-auto": { "scroll-behavior": "auto" },
        ".scroll-smooth": { "scroll-behavior": "smooth" }
      });
    },
    textOverflow: ({ addUtilities }) => {
      addUtilities({
        ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" },
        ".overflow-ellipsis": { "text-overflow": "ellipsis" },
        // Deprecated
        ".text-ellipsis": { "text-overflow": "ellipsis" },
        ".text-clip": { "text-overflow": "clip" }
      });
    },
    whitespace: ({ addUtilities }) => {
      addUtilities({
        ".whitespace-normal": { "white-space": "normal" },
        ".whitespace-nowrap": { "white-space": "nowrap" },
        ".whitespace-pre": { "white-space": "pre" },
        ".whitespace-pre-line": { "white-space": "pre-line" },
        ".whitespace-pre-wrap": { "white-space": "pre-wrap" }
      });
    },
    wordBreak: ({ addUtilities }) => {
      addUtilities({
        ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" },
        ".break-words": { "overflow-wrap": "break-word" },
        ".break-all": { "word-break": "break-all" },
        ".break-keep": { "word-break": "keep-all" }
      });
    },
    borderRadius: createUtilityPlugin("borderRadius", [
      ["rounded", ["border-radius"]],
      [
        ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]],
        ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]],
        ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]],
        ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]
      ],
      [
        ["rounded-tl", ["border-top-left-radius"]],
        ["rounded-tr", ["border-top-right-radius"]],
        ["rounded-br", ["border-bottom-right-radius"]],
        ["rounded-bl", ["border-bottom-left-radius"]]
      ]
    ]),
    borderWidth: createUtilityPlugin(
      "borderWidth",
      [
        ["border", [["@defaults border-width", {}], "border-width"]],
        [
          ["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]],
          ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]
        ],
        [
          ["border-t", [["@defaults border-width", {}], "border-top-width"]],
          ["border-r", [["@defaults border-width", {}], "border-right-width"]],
          ["border-b", [["@defaults border-width", {}], "border-bottom-width"]],
          ["border-l", [["@defaults border-width", {}], "border-left-width"]]
        ]
      ],
      { type: ["line-width", "length"] }
    ),
    borderStyle: ({ addUtilities }) => {
      addUtilities({
        ".border-solid": { "border-style": "solid" },
        ".border-dashed": { "border-style": "dashed" },
        ".border-dotted": { "border-style": "dotted" },
        ".border-double": { "border-style": "double" },
        ".border-hidden": { "border-style": "hidden" },
        ".border-none": { "border-style": "none" }
      });
    },
    borderColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          border: (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-color",
              variable: "--tw-border-opacity"
            });
          }
        },
        {
          values: (({ DEFAULT: _, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
          type: ["color", "any"]
        }
      );
      matchUtilities(
        {
          "border-x": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-left-color": toColorValue(value2),
                "border-right-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: ["border-left-color", "border-right-color"],
              variable: "--tw-border-opacity"
            });
          },
          "border-y": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-top-color": toColorValue(value2),
                "border-bottom-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: ["border-top-color", "border-bottom-color"],
              variable: "--tw-border-opacity"
            });
          }
        },
        {
          values: (({ DEFAULT: _, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
          type: ["color", "any"]
        }
      );
      matchUtilities(
        {
          "border-t": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-top-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-top-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-r": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-right-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-right-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-b": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-bottom-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-bottom-color",
              variable: "--tw-border-opacity"
            });
          },
          "border-l": (value2) => {
            if (!corePlugins2("borderOpacity")) {
              return {
                "border-left-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "border-left-color",
              variable: "--tw-border-opacity"
            });
          }
        },
        {
          values: (({ DEFAULT: _, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
          type: ["color", "any"]
        }
      );
    },
    borderOpacity: createUtilityPlugin("borderOpacity", [
      ["border-opacity", ["--tw-border-opacity"]]
    ]),
    backgroundColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          bg: (value2) => {
            if (!corePlugins2("backgroundOpacity")) {
              return {
                "background-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "background-color",
              variable: "--tw-bg-opacity"
            });
          }
        },
        { values: flattenColorPalette_default(theme("backgroundColor")), type: ["color", "any"] }
      );
    },
    backgroundOpacity: createUtilityPlugin("backgroundOpacity", [
      ["bg-opacity", ["--tw-bg-opacity"]]
    ]),
    backgroundImage: createUtilityPlugin("backgroundImage", [["bg", ["background-image"]]], {
      type: ["lookup", "image", "url"]
    }),
    gradientColorStops: /* @__PURE__ */ (() => {
      function transparentTo(value2) {
        return withAlphaValue(value2, 0, "rgb(255 255 255 / 0)");
      }
      return function({ matchUtilities, theme }) {
        let options = {
          values: flattenColorPalette_default(theme("gradientColorStops")),
          type: ["color", "any"]
        };
        matchUtilities(
          {
            from: (value2) => {
              let transparentToValue = transparentTo(value2);
              return {
                "--tw-gradient-from": toColorValue(value2, "from"),
                "--tw-gradient-to": transparentToValue,
                "--tw-gradient-stops": `var(--tw-gradient-from), var(--tw-gradient-to)`
              };
            }
          },
          options
        );
        matchUtilities(
          {
            via: (value2) => {
              let transparentToValue = transparentTo(value2);
              return {
                "--tw-gradient-to": transparentToValue,
                "--tw-gradient-stops": `var(--tw-gradient-from), ${toColorValue(
                  value2,
                  "via"
                )}, var(--tw-gradient-to)`
              };
            }
          },
          options
        );
        matchUtilities(
          { to: (value2) => ({ "--tw-gradient-to": toColorValue(value2, "to") }) },
          options
        );
      };
    })(),
    boxDecorationBreak: ({ addUtilities }) => {
      addUtilities({
        ".decoration-slice": { "box-decoration-break": "slice" },
        // Deprecated
        ".decoration-clone": { "box-decoration-break": "clone" },
        // Deprecated
        ".box-decoration-slice": { "box-decoration-break": "slice" },
        ".box-decoration-clone": { "box-decoration-break": "clone" }
      });
    },
    backgroundSize: createUtilityPlugin("backgroundSize", [["bg", ["background-size"]]], {
      type: ["lookup", "length", "percentage", "size"]
    }),
    backgroundAttachment: ({ addUtilities }) => {
      addUtilities({
        ".bg-fixed": { "background-attachment": "fixed" },
        ".bg-local": { "background-attachment": "local" },
        ".bg-scroll": { "background-attachment": "scroll" }
      });
    },
    backgroundClip: ({ addUtilities }) => {
      addUtilities({
        ".bg-clip-border": { "background-clip": "border-box" },
        ".bg-clip-padding": { "background-clip": "padding-box" },
        ".bg-clip-content": { "background-clip": "content-box" },
        ".bg-clip-text": { "background-clip": "text" }
      });
    },
    backgroundPosition: createUtilityPlugin("backgroundPosition", [["bg", ["background-position"]]], {
      type: ["lookup", ["position", { preferOnConflict: true }]]
    }),
    backgroundRepeat: ({ addUtilities }) => {
      addUtilities({
        ".bg-repeat": { "background-repeat": "repeat" },
        ".bg-no-repeat": { "background-repeat": "no-repeat" },
        ".bg-repeat-x": { "background-repeat": "repeat-x" },
        ".bg-repeat-y": { "background-repeat": "repeat-y" },
        ".bg-repeat-round": { "background-repeat": "round" },
        ".bg-repeat-space": { "background-repeat": "space" }
      });
    },
    backgroundOrigin: ({ addUtilities }) => {
      addUtilities({
        ".bg-origin-border": { "background-origin": "border-box" },
        ".bg-origin-padding": { "background-origin": "padding-box" },
        ".bg-origin-content": { "background-origin": "content-box" }
      });
    },
    fill: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          fill: (value2) => {
            return { fill: toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("fill")), type: ["color", "any"] }
      );
    },
    stroke: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          stroke: (value2) => {
            return { stroke: toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("stroke")), type: ["color", "url", "any"] }
      );
    },
    strokeWidth: createUtilityPlugin("strokeWidth", [["stroke", ["stroke-width"]]], {
      type: ["length", "number", "percentage"]
    }),
    objectFit: ({ addUtilities }) => {
      addUtilities({
        ".object-contain": { "object-fit": "contain" },
        ".object-cover": { "object-fit": "cover" },
        ".object-fill": { "object-fit": "fill" },
        ".object-none": { "object-fit": "none" },
        ".object-scale-down": { "object-fit": "scale-down" }
      });
    },
    objectPosition: createUtilityPlugin("objectPosition", [["object", ["object-position"]]]),
    padding: createUtilityPlugin("padding", [
      ["p", ["padding"]],
      [
        ["px", ["padding-left", "padding-right"]],
        ["py", ["padding-top", "padding-bottom"]]
      ],
      [
        ["pt", ["padding-top"]],
        ["pr", ["padding-right"]],
        ["pb", ["padding-bottom"]],
        ["pl", ["padding-left"]]
      ]
    ]),
    textAlign: ({ addUtilities }) => {
      addUtilities({
        ".text-left": { "text-align": "left" },
        ".text-center": { "text-align": "center" },
        ".text-right": { "text-align": "right" },
        ".text-justify": { "text-align": "justify" },
        ".text-start": { "text-align": "start" },
        ".text-end": { "text-align": "end" }
      });
    },
    textIndent: createUtilityPlugin("textIndent", [["indent", ["text-indent"]]], {
      supportsNegativeValues: true
    }),
    verticalAlign: ({ addUtilities, matchUtilities }) => {
      addUtilities({
        ".align-baseline": { "vertical-align": "baseline" },
        ".align-top": { "vertical-align": "top" },
        ".align-middle": { "vertical-align": "middle" },
        ".align-bottom": { "vertical-align": "bottom" },
        ".align-text-top": { "vertical-align": "text-top" },
        ".align-text-bottom": { "vertical-align": "text-bottom" },
        ".align-sub": { "vertical-align": "sub" },
        ".align-super": { "vertical-align": "super" }
      });
      matchUtilities({ align: (value2) => ({ "vertical-align": value2 }) });
    },
    fontFamily: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          font: (value2) => {
            let [families, options = {}] = Array.isArray(value2) && isPlainObject(value2[1]) ? value2 : [value2];
            let { fontFeatureSettings } = options;
            return {
              "font-family": Array.isArray(families) ? families.join(", ") : families,
              ...fontFeatureSettings === void 0 ? {} : { "font-feature-settings": fontFeatureSettings }
            };
          }
        },
        {
          values: theme("fontFamily"),
          type: ["lookup", "generic-name", "family-name"]
        }
      );
    },
    fontSize: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          text: (value2) => {
            let [fontSize, options] = Array.isArray(value2) ? value2 : [value2];
            let { lineHeight, letterSpacing, fontWeight } = isPlainObject(options) ? options : { lineHeight: options };
            return {
              "font-size": fontSize,
              ...lineHeight === void 0 ? {} : { "line-height": lineHeight },
              ...letterSpacing === void 0 ? {} : { "letter-spacing": letterSpacing },
              ...fontWeight === void 0 ? {} : { "font-weight": fontWeight }
            };
          }
        },
        {
          values: theme("fontSize"),
          type: ["absolute-size", "relative-size", "length", "percentage"]
        }
      );
    },
    fontWeight: createUtilityPlugin("fontWeight", [["font", ["fontWeight"]]], {
      type: ["lookup", "number", "any"]
    }),
    textTransform: ({ addUtilities }) => {
      addUtilities({
        ".uppercase": { "text-transform": "uppercase" },
        ".lowercase": { "text-transform": "lowercase" },
        ".capitalize": { "text-transform": "capitalize" },
        ".normal-case": { "text-transform": "none" }
      });
    },
    fontStyle: ({ addUtilities }) => {
      addUtilities({
        ".italic": { "font-style": "italic" },
        ".not-italic": { "font-style": "normal" }
      });
    },
    fontVariantNumeric: ({ addDefaults, addUtilities }) => {
      let cssFontVariantNumericValue = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
      addDefaults("font-variant-numeric", {
        "--tw-ordinal": " ",
        "--tw-slashed-zero": " ",
        "--tw-numeric-figure": " ",
        "--tw-numeric-spacing": " ",
        "--tw-numeric-fraction": " "
      });
      addUtilities({
        ".normal-nums": { "font-variant-numeric": "normal" },
        ".ordinal": {
          "@defaults font-variant-numeric": {},
          "--tw-ordinal": "ordinal",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".slashed-zero": {
          "@defaults font-variant-numeric": {},
          "--tw-slashed-zero": "slashed-zero",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".lining-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-figure": "lining-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".oldstyle-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-figure": "oldstyle-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".proportional-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-spacing": "proportional-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".tabular-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-spacing": "tabular-nums",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".diagonal-fractions": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-fraction": "diagonal-fractions",
          "font-variant-numeric": cssFontVariantNumericValue
        },
        ".stacked-fractions": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-fraction": "stacked-fractions",
          "font-variant-numeric": cssFontVariantNumericValue
        }
      });
    },
    lineHeight: createUtilityPlugin("lineHeight", [["leading", ["lineHeight"]]]),
    letterSpacing: createUtilityPlugin("letterSpacing", [["tracking", ["letterSpacing"]]], {
      supportsNegativeValues: true
    }),
    textColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          text: (value2) => {
            if (!corePlugins2("textOpacity")) {
              return { color: toColorValue(value2) };
            }
            return withAlphaVariable({
              color: value2,
              property: "color",
              variable: "--tw-text-opacity"
            });
          }
        },
        { values: flattenColorPalette_default(theme("textColor")), type: ["color", "any"] }
      );
    },
    textOpacity: createUtilityPlugin("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]),
    textDecoration: ({ addUtilities }) => {
      addUtilities({
        ".underline": { "text-decoration-line": "underline" },
        ".overline": { "text-decoration-line": "overline" },
        ".line-through": { "text-decoration-line": "line-through" },
        ".no-underline": { "text-decoration-line": "none" }
      });
    },
    textDecorationColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          decoration: (value2) => {
            return { "text-decoration-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("textDecorationColor")), type: ["color", "any"] }
      );
    },
    textDecorationStyle: ({ addUtilities }) => {
      addUtilities({
        ".decoration-solid": { "text-decoration-style": "solid" },
        ".decoration-double": { "text-decoration-style": "double" },
        ".decoration-dotted": { "text-decoration-style": "dotted" },
        ".decoration-dashed": { "text-decoration-style": "dashed" },
        ".decoration-wavy": { "text-decoration-style": "wavy" }
      });
    },
    textDecorationThickness: createUtilityPlugin(
      "textDecorationThickness",
      [["decoration", ["text-decoration-thickness"]]],
      { type: ["length", "percentage"] }
    ),
    textUnderlineOffset: createUtilityPlugin(
      "textUnderlineOffset",
      [["underline-offset", ["text-underline-offset"]]],
      { type: ["length", "percentage", "any"] }
    ),
    fontSmoothing: ({ addUtilities }) => {
      addUtilities({
        ".antialiased": {
          "-webkit-font-smoothing": "antialiased",
          "-moz-osx-font-smoothing": "grayscale"
        },
        ".subpixel-antialiased": {
          "-webkit-font-smoothing": "auto",
          "-moz-osx-font-smoothing": "auto"
        }
      });
    },
    placeholderColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          placeholder: (value2) => {
            if (!corePlugins2("placeholderOpacity")) {
              return {
                "&::placeholder": {
                  color: toColorValue(value2)
                }
              };
            }
            return {
              "&::placeholder": withAlphaVariable({
                color: value2,
                property: "color",
                variable: "--tw-placeholder-opacity"
              })
            };
          }
        },
        { values: flattenColorPalette_default(theme("placeholderColor")), type: ["color", "any"] }
      );
    },
    placeholderOpacity: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "placeholder-opacity": (value2) => {
            return { ["&::placeholder"]: { "--tw-placeholder-opacity": value2 } };
          }
        },
        { values: theme("placeholderOpacity") }
      );
    },
    caretColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          caret: (value2) => {
            return { "caret-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("caretColor")), type: ["color", "any"] }
      );
    },
    accentColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          accent: (value2) => {
            return { "accent-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("accentColor")), type: ["color", "any"] }
      );
    },
    opacity: createUtilityPlugin("opacity", [["opacity", ["opacity"]]]),
    backgroundBlendMode: ({ addUtilities }) => {
      addUtilities({
        ".bg-blend-normal": { "background-blend-mode": "normal" },
        ".bg-blend-multiply": { "background-blend-mode": "multiply" },
        ".bg-blend-screen": { "background-blend-mode": "screen" },
        ".bg-blend-overlay": { "background-blend-mode": "overlay" },
        ".bg-blend-darken": { "background-blend-mode": "darken" },
        ".bg-blend-lighten": { "background-blend-mode": "lighten" },
        ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" },
        ".bg-blend-color-burn": { "background-blend-mode": "color-burn" },
        ".bg-blend-hard-light": { "background-blend-mode": "hard-light" },
        ".bg-blend-soft-light": { "background-blend-mode": "soft-light" },
        ".bg-blend-difference": { "background-blend-mode": "difference" },
        ".bg-blend-exclusion": { "background-blend-mode": "exclusion" },
        ".bg-blend-hue": { "background-blend-mode": "hue" },
        ".bg-blend-saturation": { "background-blend-mode": "saturation" },
        ".bg-blend-color": { "background-blend-mode": "color" },
        ".bg-blend-luminosity": { "background-blend-mode": "luminosity" }
      });
    },
    mixBlendMode: ({ addUtilities }) => {
      addUtilities({
        ".mix-blend-normal": { "mix-blend-mode": "normal" },
        ".mix-blend-multiply": { "mix-blend-mode": "multiply" },
        ".mix-blend-screen": { "mix-blend-mode": "screen" },
        ".mix-blend-overlay": { "mix-blend-mode": "overlay" },
        ".mix-blend-darken": { "mix-blend-mode": "darken" },
        ".mix-blend-lighten": { "mix-blend-mode": "lighten" },
        ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" },
        ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" },
        ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" },
        ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" },
        ".mix-blend-difference": { "mix-blend-mode": "difference" },
        ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" },
        ".mix-blend-hue": { "mix-blend-mode": "hue" },
        ".mix-blend-saturation": { "mix-blend-mode": "saturation" },
        ".mix-blend-color": { "mix-blend-mode": "color" },
        ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" },
        ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" }
      });
    },
    boxShadow: (() => {
      let transformValue = transformThemeValue("boxShadow");
      let defaultBoxShadow = [
        `var(--tw-ring-offset-shadow, 0 0 #0000)`,
        `var(--tw-ring-shadow, 0 0 #0000)`,
        `var(--tw-shadow)`
      ].join(", ");
      return function({ matchUtilities, addDefaults, theme }) {
        addDefaults(" box-shadow", {
          "--tw-ring-offset-shadow": "0 0 #0000",
          "--tw-ring-shadow": "0 0 #0000",
          "--tw-shadow": "0 0 #0000",
          "--tw-shadow-colored": "0 0 #0000"
        });
        matchUtilities(
          {
            shadow: (value2) => {
              value2 = transformValue(value2);
              let ast = parseBoxShadowValue(value2);
              for (let shadow2 of ast) {
                if (!shadow2.valid) {
                  continue;
                }
                shadow2.color = "var(--tw-shadow-color)";
              }
              return {
                "@defaults box-shadow": {},
                "--tw-shadow": value2 === "none" ? "0 0 #0000" : value2,
                "--tw-shadow-colored": value2 === "none" ? "0 0 #0000" : formatBoxShadowValue(ast),
                "box-shadow": defaultBoxShadow
              };
            }
          },
          { values: theme("boxShadow"), type: ["shadow"] }
        );
      };
    })(),
    boxShadowColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          shadow: (value2) => {
            return {
              "--tw-shadow-color": toColorValue(value2),
              "--tw-shadow": "var(--tw-shadow-colored)"
            };
          }
        },
        { values: flattenColorPalette_default(theme("boxShadowColor")), type: ["color", "any"] }
      );
    },
    outlineStyle: ({ addUtilities }) => {
      addUtilities({
        ".outline-none": {
          outline: "2px solid transparent",
          "outline-offset": "2px"
        },
        ".outline": { "outline-style": "solid" },
        ".outline-dashed": { "outline-style": "dashed" },
        ".outline-dotted": { "outline-style": "dotted" },
        ".outline-double": { "outline-style": "double" }
      });
    },
    outlineWidth: createUtilityPlugin("outlineWidth", [["outline", ["outline-width"]]], {
      type: ["length", "number", "percentage"]
    }),
    outlineOffset: createUtilityPlugin("outlineOffset", [["outline-offset", ["outline-offset"]]], {
      type: ["length", "number", "percentage", "any"],
      supportsNegativeValues: true
    }),
    outlineColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          outline: (value2) => {
            return { "outline-color": toColorValue(value2) };
          }
        },
        { values: flattenColorPalette_default(theme("outlineColor")), type: ["color", "any"] }
      );
    },
    ringWidth: ({ matchUtilities, addDefaults, addUtilities, theme, config }) => {
      let ringColorDefault = (() => {
        if (flagEnabled(config(), "respectDefaultRingColorOpacity")) {
          return theme("ringColor.DEFAULT");
        }
        let ringOpacityDefault = theme("ringOpacity.DEFAULT", "0.5");
        if (!theme("ringColor")?.DEFAULT) {
          return `rgb(147 197 253 / ${ringOpacityDefault})`;
        }
        return withAlphaValue(
          theme("ringColor")?.DEFAULT,
          ringOpacityDefault,
          `rgb(147 197 253 / ${ringOpacityDefault})`
        );
      })();
      addDefaults("ring-width", {
        "--tw-ring-inset": " ",
        "--tw-ring-offset-width": theme("ringOffsetWidth.DEFAULT", "0px"),
        "--tw-ring-offset-color": theme("ringOffsetColor.DEFAULT", "#fff"),
        "--tw-ring-color": ringColorDefault,
        "--tw-ring-offset-shadow": "0 0 #0000",
        "--tw-ring-shadow": "0 0 #0000",
        "--tw-shadow": "0 0 #0000",
        "--tw-shadow-colored": "0 0 #0000"
      });
      matchUtilities(
        {
          ring: (value2) => {
            return {
              "@defaults ring-width": {},
              "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
              "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${value2} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
              "box-shadow": [
                `var(--tw-ring-offset-shadow)`,
                `var(--tw-ring-shadow)`,
                `var(--tw-shadow, 0 0 #0000)`
              ].join(", ")
            };
          }
        },
        { values: theme("ringWidth"), type: "length" }
      );
      addUtilities({
        ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" }
      });
    },
    ringColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
      matchUtilities(
        {
          ring: (value2) => {
            if (!corePlugins2("ringOpacity")) {
              return {
                "--tw-ring-color": toColorValue(value2)
              };
            }
            return withAlphaVariable({
              color: value2,
              property: "--tw-ring-color",
              variable: "--tw-ring-opacity"
            });
          }
        },
        {
          values: Object.fromEntries(
            Object.entries(flattenColorPalette_default(theme("ringColor"))).filter(
              ([modifier]) => modifier !== "DEFAULT"
            )
          ),
          type: ["color", "any"]
        }
      );
    },
    ringOpacity: (helpers) => {
      let { config } = helpers;
      return createUtilityPlugin("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], {
        filterDefault: !flagEnabled(config(), "respectDefaultRingColorOpacity")
      })(helpers);
    },
    ringOffsetWidth: createUtilityPlugin(
      "ringOffsetWidth",
      [["ring-offset", ["--tw-ring-offset-width"]]],
      { type: "length" }
    ),
    ringOffsetColor: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "ring-offset": (value2) => {
            return {
              "--tw-ring-offset-color": toColorValue(value2)
            };
          }
        },
        { values: flattenColorPalette_default(theme("ringOffsetColor")), type: ["color", "any"] }
      );
    },
    blur: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          blur: (value2) => {
            return {
              "--tw-blur": `blur(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("blur") }
      );
    },
    brightness: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          brightness: (value2) => {
            return {
              "--tw-brightness": `brightness(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("brightness") }
      );
    },
    contrast: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          contrast: (value2) => {
            return {
              "--tw-contrast": `contrast(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("contrast") }
      );
    },
    dropShadow: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "drop-shadow": (value2) => {
            return {
              "--tw-drop-shadow": Array.isArray(value2) ? value2.map((v) => `drop-shadow(${v})`).join(" ") : `drop-shadow(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("dropShadow") }
      );
    },
    grayscale: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          grayscale: (value2) => {
            return {
              "--tw-grayscale": `grayscale(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("grayscale") }
      );
    },
    hueRotate: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "hue-rotate": (value2) => {
            return {
              "--tw-hue-rotate": `hue-rotate(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("hueRotate"), supportsNegativeValues: true }
      );
    },
    invert: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          invert: (value2) => {
            return {
              "--tw-invert": `invert(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("invert") }
      );
    },
    saturate: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          saturate: (value2) => {
            return {
              "--tw-saturate": `saturate(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("saturate") }
      );
    },
    sepia: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          sepia: (value2) => {
            return {
              "--tw-sepia": `sepia(${value2})`,
              "@defaults filter": {},
              filter: cssFilterValue
            };
          }
        },
        { values: theme("sepia") }
      );
    },
    filter: ({ addDefaults, addUtilities }) => {
      addDefaults("filter", {
        "--tw-blur": " ",
        "--tw-brightness": " ",
        "--tw-contrast": " ",
        "--tw-grayscale": " ",
        "--tw-hue-rotate": " ",
        "--tw-invert": " ",
        "--tw-saturate": " ",
        "--tw-sepia": " ",
        "--tw-drop-shadow": " "
      });
      addUtilities({
        ".filter": { "@defaults filter": {}, filter: cssFilterValue },
        ".filter-none": { filter: "none" }
      });
    },
    backdropBlur: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-blur": (value2) => {
            return {
              "--tw-backdrop-blur": `blur(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropBlur") }
      );
    },
    backdropBrightness: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-brightness": (value2) => {
            return {
              "--tw-backdrop-brightness": `brightness(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropBrightness") }
      );
    },
    backdropContrast: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-contrast": (value2) => {
            return {
              "--tw-backdrop-contrast": `contrast(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropContrast") }
      );
    },
    backdropGrayscale: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-grayscale": (value2) => {
            return {
              "--tw-backdrop-grayscale": `grayscale(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropGrayscale") }
      );
    },
    backdropHueRotate: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-hue-rotate": (value2) => {
            return {
              "--tw-backdrop-hue-rotate": `hue-rotate(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropHueRotate"), supportsNegativeValues: true }
      );
    },
    backdropInvert: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-invert": (value2) => {
            return {
              "--tw-backdrop-invert": `invert(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropInvert") }
      );
    },
    backdropOpacity: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-opacity": (value2) => {
            return {
              "--tw-backdrop-opacity": `opacity(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropOpacity") }
      );
    },
    backdropSaturate: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-saturate": (value2) => {
            return {
              "--tw-backdrop-saturate": `saturate(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropSaturate") }
      );
    },
    backdropSepia: ({ matchUtilities, theme }) => {
      matchUtilities(
        {
          "backdrop-sepia": (value2) => {
            return {
              "--tw-backdrop-sepia": `sepia(${value2})`,
              "@defaults backdrop-filter": {},
              "backdrop-filter": cssBackdropFilterValue
            };
          }
        },
        { values: theme("backdropSepia") }
      );
    },
    backdropFilter: ({ addDefaults, addUtilities }) => {
      addDefaults("backdrop-filter", {
        "--tw-backdrop-blur": " ",
        "--tw-backdrop-brightness": " ",
        "--tw-backdrop-contrast": " ",
        "--tw-backdrop-grayscale": " ",
        "--tw-backdrop-hue-rotate": " ",
        "--tw-backdrop-invert": " ",
        "--tw-backdrop-opacity": " ",
        "--tw-backdrop-saturate": " ",
        "--tw-backdrop-sepia": " "
      });
      addUtilities({
        ".backdrop-filter": {
          "@defaults backdrop-filter": {},
          "backdrop-filter": cssBackdropFilterValue
        },
        ".backdrop-filter-none": { "backdrop-filter": "none" }
      });
    },
    transitionProperty: ({ matchUtilities, theme }) => {
      let defaultTimingFunction = theme("transitionTimingFunction.DEFAULT");
      let defaultDuration = theme("transitionDuration.DEFAULT");
      matchUtilities(
        {
          transition: (value2) => {
            return {
              "transition-property": value2,
              ...value2 === "none" ? {} : {
                "transition-timing-function": defaultTimingFunction,
                "transition-duration": defaultDuration
              }
            };
          }
        },
        { values: theme("transitionProperty") }
      );
    },
    transitionDelay: createUtilityPlugin("transitionDelay", [["delay", ["transitionDelay"]]]),
    transitionDuration: createUtilityPlugin(
      "transitionDuration",
      [["duration", ["transitionDuration"]]],
      { filterDefault: true }
    ),
    transitionTimingFunction: createUtilityPlugin(
      "transitionTimingFunction",
      [["ease", ["transitionTimingFunction"]]],
      { filterDefault: true }
    ),
    willChange: createUtilityPlugin("willChange", [["will-change", ["will-change"]]]),
    content: createUtilityPlugin("content", [
      ["content", ["--tw-content", ["content", "var(--tw-content)"]]]
    ])
  };
  function toPath(path) {
    if (Array.isArray(path))
      return path;
    let openBrackets = path.split("[").length - 1;
    let closedBrackets = path.split("]").length - 1;
    if (openBrackets !== closedBrackets) {
      throw new Error(`Path is invalid. Has unbalanced brackets: ${path}`);
    }
    return path.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
  }
  var matchingBrackets = /* @__PURE__ */ new Map([
    ["{", "}"],
    ["[", "]"],
    ["(", ")"]
  ]);
  var inverseMatchingBrackets = new Map(
    Array.from(matchingBrackets.entries()).map(([k2, v]) => [v, k2])
  );
  var quotes = /* @__PURE__ */ new Set(['"', "'", "`"]);
  function isSyntacticallyValidPropertyValue(value2) {
    let stack = [];
    let inQuotes = false;
    for (let i = 0; i < value2.length; i++) {
      let char = value2[i];
      if (char === ":" && !inQuotes && stack.length === 0) {
        return false;
      }
      if (quotes.has(char) && value2[i - 1] !== "\\") {
        inQuotes = !inQuotes;
      }
      if (inQuotes)
        continue;
      if (value2[i - 1] === "\\")
        continue;
      if (matchingBrackets.has(char)) {
        stack.push(char);
      } else if (inverseMatchingBrackets.has(char)) {
        let inverse = inverseMatchingBrackets.get(char);
        if (stack.length <= 0) {
          return false;
        }
        if (stack.pop() !== inverse) {
          return false;
        }
      }
    }
    if (stack.length > 0) {
      return false;
    }
    return true;
  }
  function bigSign(bigIntValue) {
    return (bigIntValue > 0n) - (bigIntValue < 0n);
  }
  function remapBitfield(num2, mapping) {
    let oldMask = 0n;
    let newMask = 0n;
    for (let [oldBit, newBit] of mapping) {
      if (num2 & oldBit) {
        oldMask = oldMask | oldBit;
        newMask = newMask | newBit;
      }
    }
    return num2 & ~oldMask | newMask;
  }
  var Offsets = class {
    constructor() {
      this.offsets = {
        defaults: 0n,
        base: 0n,
        components: 0n,
        utilities: 0n,
        variants: 0n,
        user: 0n
      };
      this.layerPositions = {
        defaults: 0n,
        base: 1n,
        components: 2n,
        utilities: 3n,
        // There isn't technically a "user" layer, but we need to give it a position
        // Because it's used for ordering user-css from @apply
        user: 4n,
        variants: 5n
      };
      this.reservedVariantBits = 0n;
      this.variantOffsets = /* @__PURE__ */ new Map();
    }
    /**
     * @param {Layer} layer
     * @returns {RuleOffset}
     */
    create(layer) {
      return {
        layer,
        parentLayer: layer,
        arbitrary: 0n,
        variants: 0n,
        parallelIndex: 0n,
        index: this.offsets[layer]++,
        options: []
      };
    }
    /**
     * @returns {RuleOffset}
     */
    arbitraryProperty() {
      return {
        ...this.create("utilities"),
        arbitrary: 1n
      };
    }
    /**
     * Get the offset for a variant
     *
     * @param {string} variant
     * @param {number} index
     * @returns {RuleOffset}
     */
    forVariant(variant, index2 = 0) {
      let offset = this.variantOffsets.get(variant);
      if (offset === void 0) {
        throw new Error(`Cannot find offset for unknown variant ${variant}`);
      }
      return {
        ...this.create("variants"),
        variants: offset << BigInt(index2)
      };
    }
    /**
     * @param {RuleOffset} rule
     * @param {RuleOffset} variant
     * @param {VariantOption} options
     * @returns {RuleOffset}
     */
    applyVariantOffset(rule2, variant, options) {
      options.variant = variant.variants;
      return {
        ...rule2,
        layer: "variants",
        parentLayer: rule2.layer === "variants" ? rule2.parentLayer : rule2.layer,
        variants: rule2.variants | variant.variants,
        options: options.sort ? [].concat(options, rule2.options) : rule2.options,
        // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
        // We'll take the max of all the parallel indexes for now.
        // @ts-ignore
        parallelIndex: max([rule2.parallelIndex, variant.parallelIndex])
      };
    }
    /**
     * @param {RuleOffset} offset
     * @param {number} parallelIndex
     * @returns {RuleOffset}
     */
    applyParallelOffset(offset, parallelIndex) {
      return {
        ...offset,
        parallelIndex: BigInt(parallelIndex)
      };
    }
    /**
     * Each variant gets 1 bit per function / rule registered.
     * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
     * Additionally, every unique group of variants is grouped together in the stylesheet.
     *
     * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
     *
     * @param {string[]} variants
     * @param {(name: string) => number} getLength
     */
    recordVariants(variants, getLength) {
      for (let variant of variants) {
        this.recordVariant(variant, getLength(variant));
      }
    }
    /**
     * The same as `recordVariants` but for a single arbitrary variant at runtime.
     * @param {string} variant
     * @param {number} fnCount
     *
     * @returns {RuleOffset} The highest offset for this variant
     */
    recordVariant(variant, fnCount = 1) {
      this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
      this.reservedVariantBits += BigInt(fnCount);
      return {
        ...this.create("variants"),
        variants: this.variantOffsets.get(variant)
      };
    }
    /**
     * @param {RuleOffset} a
     * @param {RuleOffset} b
     * @returns {bigint}
     */
    compare(a, b) {
      if (a.layer !== b.layer) {
        return this.layerPositions[a.layer] - this.layerPositions[b.layer];
      }
      if (a.parentLayer !== b.parentLayer) {
        return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];
      }
      for (let aOptions of a.options) {
        for (let bOptions of b.options) {
          if (aOptions.id !== bOptions.id)
            continue;
          if (!aOptions.sort || !bOptions.sort)
            continue;
          let maxFnVariant = max([aOptions.variant, bOptions.variant]) ?? 0n;
          let mask = ~(maxFnVariant | maxFnVariant - 1n);
          let aVariantsAfterFn = a.variants & mask;
          let bVariantsAfterFn = b.variants & mask;
          if (aVariantsAfterFn !== bVariantsAfterFn) {
            continue;
          }
          let result = aOptions.sort(
            {
              value: aOptions.value,
              modifier: aOptions.modifier
            },
            {
              value: bOptions.value,
              modifier: bOptions.modifier
            }
          );
          if (result !== 0)
            return result;
        }
      }
      if (a.variants !== b.variants) {
        return a.variants - b.variants;
      }
      if (a.parallelIndex !== b.parallelIndex) {
        return a.parallelIndex - b.parallelIndex;
      }
      if (a.arbitrary !== b.arbitrary) {
        return a.arbitrary - b.arbitrary;
      }
      return a.index - b.index;
    }
    /**
     * Arbitrary variants are recorded in the order they're encountered.
     * This means that the order is not stable between environments and sets of content files.
     *
     * In order to make the order stable, we need to remap the arbitrary variant offsets to
     * be in alphabetical order starting from the offset of the first arbitrary variant.
     */
    recalculateVariantOffsets() {
      let variants = Array.from(this.variantOffsets.entries()).filter(([v]) => v.startsWith("[")).sort(([a], [z]) => fastCompare(a, z));
      let newOffsets = variants.map(([, offset]) => offset).sort((a, z) => bigSign(a - z));
      let mapping = variants.map(([, oldOffset], i) => [oldOffset, newOffsets[i]]);
      return mapping.filter(([a, z]) => a !== z);
    }
    /**
     * @template T
     * @param {[RuleOffset, T][]} list
     * @returns {[RuleOffset, T][]}
     */
    remapArbitraryVariantOffsets(list22) {
      let mapping = this.recalculateVariantOffsets();
      if (mapping.length === 0) {
        return list22;
      }
      return list22.map((item) => {
        let [offset, rule2] = item;
        offset = {
          ...offset,
          variants: remapBitfield(offset.variants, mapping)
        };
        return [offset, rule2];
      });
    }
    /**
     * @template T
     * @param {[RuleOffset, T][]} list
     * @returns {[RuleOffset, T][]}
     */
    sort(list22) {
      list22 = this.remapArbitraryVariantOffsets(list22);
      return list22.sort(([a], [b]) => bigSign(this.compare(a, b)));
    }
  };
  function max(nums) {
    let max2 = null;
    for (const num2 of nums) {
      max2 = max2 ?? num2;
      max2 = max2 > num2 ? max2 : num2;
    }
    return max2;
  }
  function fastCompare(a, b) {
    let aLen = a.length;
    let bLen = b.length;
    let minLen = aLen < bLen ? aLen : bLen;
    for (let i = 0; i < minLen; i++) {
      let cmp = a.charCodeAt(i) - b.charCodeAt(i);
      if (cmp !== 0)
        return cmp;
    }
    return aLen - bLen;
  }
  var VARIANT_TYPES = {
    AddVariant: Symbol.for("ADD_VARIANT"),
    MatchVariant: Symbol.for("MATCH_VARIANT")
  };
  var VARIANT_INFO = {
    Base: 1 << 0,
    Dynamic: 1 << 1
  };
  function prefix(context, selector) {
    let prefix3 = context.tailwindConfig.prefix;
    return typeof prefix3 === "function" ? prefix3(selector) : prefix3 + selector;
  }
  function normalizeOptionTypes({ type = "any", ...options }) {
    let types2 = [].concat(type);
    return {
      ...options,
      types: types2.map((type2) => {
        if (Array.isArray(type2)) {
          return { type: type2[0], ...type2[1] };
        }
        return { type: type2, preferOnConflict: false };
      })
    };
  }
  function parseVariantFormatString(input) {
    let parts = [];
    let current = "";
    let depth = 0;
    for (let idx = 0; idx < input.length; idx++) {
      let char = input[idx];
      if (char === "\\") {
        current += "\\" + input[++idx];
      } else if (char === "{") {
        ++depth;
        parts.push(current.trim());
        current = "";
      } else if (char === "}") {
        if (--depth < 0) {
          throw new Error(`Your { and } are unbalanced.`);
        }
        parts.push(current.trim());
        current = "";
      } else {
        current += char;
      }
    }
    if (current.length > 0) {
      parts.push(current.trim());
    }
    parts = parts.filter((part) => part !== "");
    return parts;
  }
  function insertInto(list22, value2, { before = [] } = {}) {
    before = [].concat(before);
    if (before.length <= 0) {
      list22.push(value2);
      return;
    }
    let idx = list22.length - 1;
    for (let other of before) {
      let iidx = list22.indexOf(other);
      if (iidx === -1)
        continue;
      idx = Math.min(idx, iidx);
    }
    list22.splice(idx, 0, value2);
  }
  function parseStyles(styles) {
    if (!Array.isArray(styles)) {
      return parseStyles([styles]);
    }
    return styles.flatMap((style) => {
      let isNode = !Array.isArray(style) && !isPlainObject(style);
      return isNode ? style : parseObjectStyles(style);
    });
  }
  function getClasses(selector, mutate) {
    let parser4 = (0, import_postcss_selector_parser7.default)((selectors) => {
      let allClasses = [];
      if (mutate) {
        mutate(selectors);
      }
      selectors.walkClasses((classNode) => {
        allClasses.push(classNode.value);
      });
      return allClasses;
    });
    return parser4.transformSync(selector);
  }
  function extractCandidates(node, state = { containsNonOnDemandable: false }, depth = 0) {
    let classes = [];
    if (node.type === "rule") {
      let ignoreNot = function(selectors) {
        selectors.walkPseudos((pseudo) => {
          if (pseudo.value === ":not") {
            pseudo.remove();
          }
        });
      };
      for (let selector of node.selectors) {
        let classCandidates = getClasses(selector, ignoreNot);
        if (classCandidates.length === 0) {
          state.containsNonOnDemandable = true;
        }
        for (let classCandidate of classCandidates) {
          classes.push(classCandidate);
        }
      }
    } else if (node.type === "atrule") {
      node.walkRules((rule2) => {
        for (let classCandidate of rule2.selectors.flatMap((selector) => getClasses(selector))) {
          classes.push(classCandidate);
        }
      });
    }
    if (depth === 0) {
      return [state.containsNonOnDemandable || classes.length === 0, classes];
    }
    return classes;
  }
  function withIdentifiers(styles) {
    return parseStyles(styles).flatMap((node) => {
      let nodeMap = /* @__PURE__ */ new Map();
      let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);
      if (containsNonOnDemandableSelectors) {
        candidates.unshift(NOT_ON_DEMAND);
      }
      return candidates.map((c4) => {
        if (!nodeMap.has(node)) {
          nodeMap.set(node, node);
        }
        return [c4, nodeMap.get(node)];
      });
    });
  }
  function isValidVariantFormatString(format) {
    return format.startsWith("@") || format.includes("&");
  }
  function parseVariant(variant) {
    variant = variant.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
    let fns = parseVariantFormatString(variant).map((str) => {
      if (!str.startsWith("@")) {
        return ({ format }) => format(str);
      }
      let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);
      return ({ wrap }) => wrap(postcss_default.atRule({ name, params: params.trim() }));
    }).reverse();
    return (api) => {
      for (let fn2 of fns) {
        fn2(api);
      }
    };
  }
  function buildPluginApi(tailwindConfig, context, { variantList, variantMap, offsets, classList }) {
    function getConfigValue(path, defaultValue) {
      return path ? (0, import_dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;
    }
    function applyConfiguredPrefix(selector) {
      return prefixSelector_default(tailwindConfig.prefix, selector);
    }
    function prefixIdentifier(identifier, options) {
      if (identifier === NOT_ON_DEMAND) {
        return NOT_ON_DEMAND;
      }
      if (!options.respectPrefix) {
        return identifier;
      }
      return context.tailwindConfig.prefix + identifier;
    }
    function resolveThemeValue(path, defaultValue, opts = {}) {
      let parts = toPath(path);
      let value2 = getConfigValue(["theme", ...parts], defaultValue);
      return transformThemeValue(parts[0])(value2, opts);
    }
    let variantIdentifier = 0;
    let api = {
      postcss: postcss_default,
      prefix: applyConfiguredPrefix,
      e: escapeClassName,
      config: getConfigValue,
      theme: resolveThemeValue,
      corePlugins: (path) => {
        if (Array.isArray(tailwindConfig.corePlugins)) {
          return tailwindConfig.corePlugins.includes(path);
        }
        return getConfigValue(["corePlugins", path], true);
      },
      variants: () => {
        return [];
      },
      addBase(base) {
        for (let [identifier, rule2] of withIdentifiers(base)) {
          let prefixedIdentifier = prefixIdentifier(identifier, {});
          let offset = offsets.create("base");
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offset, layer: "base" }, rule2]);
        }
      },
      /**
       * @param {string} group
       * @param {Record<string, string | string[]>} declarations
       */
      addDefaults(group, declarations) {
        const groups = {
          [`@defaults ${group}`]: declarations
        };
        for (let [identifier, rule2] of withIdentifiers(groups)) {
          let prefixedIdentifier = prefixIdentifier(identifier, {});
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("defaults"), layer: "defaults" }, rule2]);
        }
      },
      addComponents(components, options) {
        let defaultOptions = {
          preserveSource: false,
          respectPrefix: true,
          respectImportant: false
        };
        options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
        for (let [identifier, rule2] of withIdentifiers(components)) {
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          classList.add(prefixedIdentifier);
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("components"), layer: "components", options }, rule2]);
        }
      },
      addUtilities(utilities, options) {
        let defaultOptions = {
          preserveSource: false,
          respectPrefix: true,
          respectImportant: true
        };
        options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
        for (let [identifier, rule2] of withIdentifiers(utilities)) {
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          classList.add(prefixedIdentifier);
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("utilities"), layer: "utilities", options }, rule2]);
        }
      },
      matchUtilities: function(utilities, options) {
        let defaultOptions = {
          respectPrefix: true,
          respectImportant: true,
          modifiers: false
        };
        options = normalizeOptionTypes({ ...defaultOptions, ...options });
        let offset = offsets.create("utilities");
        for (let identifier in utilities) {
          let wrapped = function(modifier, { isOnlyPlugin }) {
            let [value2, coercedType, utilityModifier] = coerceValue(
              options.types,
              modifier,
              options,
              tailwindConfig
            );
            if (value2 === void 0) {
              return [];
            }
            if (!options.types.some(({ type }) => type === coercedType)) {
              if (isOnlyPlugin) {
                log_default.warn([
                  `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                  `You can safely update it to \`${identifier}-${modifier.replace(
                    coercedType + ":",
                    ""
                  )}\`.`
                ]);
              } else {
                return [];
              }
            }
            if (!isSyntacticallyValidPropertyValue(value2)) {
              return [];
            }
            let extras = {
              get modifier() {
                if (!options.modifiers) {
                  log_default.warn(`modifier-used-without-options-for-${identifier}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]);
                }
                return utilityModifier;
              }
            };
            let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
            let ruleSets = [].concat(modifiersEnabled ? rule2(value2, extras) : rule2(value2)).filter(Boolean).map((declaration) => ({
              [nameClass(identifier, modifier)]: declaration
            }));
            return ruleSets;
          };
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          let rule2 = utilities[identifier];
          classList.add([prefixedIdentifier, options]);
          let withOffsets = [{ sort: offset, layer: "utilities", options }, wrapped];
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
        }
      },
      matchComponents: function(components, options) {
        let defaultOptions = {
          respectPrefix: true,
          respectImportant: false,
          modifiers: false
        };
        options = normalizeOptionTypes({ ...defaultOptions, ...options });
        let offset = offsets.create("components");
        for (let identifier in components) {
          let wrapped = function(modifier, { isOnlyPlugin }) {
            let [value2, coercedType, utilityModifier] = coerceValue(
              options.types,
              modifier,
              options,
              tailwindConfig
            );
            if (value2 === void 0) {
              return [];
            }
            if (!options.types.some(({ type }) => type === coercedType)) {
              if (isOnlyPlugin) {
                log_default.warn([
                  `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                  `You can safely update it to \`${identifier}-${modifier.replace(
                    coercedType + ":",
                    ""
                  )}\`.`
                ]);
              } else {
                return [];
              }
            }
            if (!isSyntacticallyValidPropertyValue(value2)) {
              return [];
            }
            let extras = {
              get modifier() {
                if (!options.modifiers) {
                  log_default.warn(`modifier-used-without-options-for-${identifier}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]);
                }
                return utilityModifier;
              }
            };
            let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
            let ruleSets = [].concat(modifiersEnabled ? rule2(value2, extras) : rule2(value2)).filter(Boolean).map((declaration) => ({
              [nameClass(identifier, modifier)]: declaration
            }));
            return ruleSets;
          };
          let prefixedIdentifier = prefixIdentifier(identifier, options);
          let rule2 = components[identifier];
          classList.add([prefixedIdentifier, options]);
          let withOffsets = [{ sort: offset, layer: "components", options }, wrapped];
          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }
          context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
        }
      },
      addVariant(variantName, variantFunctions, options = {}) {
        variantFunctions = [].concat(variantFunctions).map((variantFunction) => {
          if (typeof variantFunction !== "string") {
            return (api2 = {}) => {
              let { args, modifySelectors, container, separator, wrap, format } = api2;
              let result = variantFunction(
                Object.assign(
                  { modifySelectors, container, separator },
                  options.type === VARIANT_TYPES.MatchVariant && { args, wrap, format }
                )
              );
              if (typeof result === "string" && !isValidVariantFormatString(result)) {
                throw new Error(
                  `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
                );
              }
              if (Array.isArray(result)) {
                return result.filter((variant) => typeof variant === "string").map((variant) => parseVariant(variant));
              }
              return result && typeof result === "string" && parseVariant(result)(api2);
            };
          }
          if (!isValidVariantFormatString(variantFunction)) {
            throw new Error(
              `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
            );
          }
          return parseVariant(variantFunction);
        });
        insertInto(variantList, variantName, options);
        variantMap.set(variantName, variantFunctions);
        context.variantOptions.set(variantName, options);
      },
      matchVariant(variant, variantFn, options) {
        let id = options?.id ?? ++variantIdentifier;
        let isSpecial = variant === "@";
        let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
        for (let [key, value2] of Object.entries(options?.values ?? {})) {
          if (key === "DEFAULT")
            continue;
          api.addVariant(
            isSpecial ? `${variant}${key}` : `${variant}-${key}`,
            ({ args, container }) => {
              return variantFn(
                value2,
                modifiersEnabled ? { modifier: args?.modifier, container } : { container }
              );
            },
            {
              ...options,
              value: value2,
              id,
              type: VARIANT_TYPES.MatchVariant,
              variantInfo: VARIANT_INFO.Base
            }
          );
        }
        let hasDefault = "DEFAULT" in (options?.values ?? {});
        api.addVariant(
          variant,
          ({ args, container }) => {
            if (args?.value === NONE && !hasDefault) {
              return null;
            }
            return variantFn(
              args?.value === NONE ? options.values.DEFAULT : (
                // Falling back to args if it is a string, otherwise '' for older intellisense
                // (JetBrains) plugins.
                args?.value ?? (typeof args === "string" ? args : "")
              ),
              modifiersEnabled ? { modifier: args?.modifier, container } : { container }
            );
          },
          {
            ...options,
            id,
            type: VARIANT_TYPES.MatchVariant,
            variantInfo: VARIANT_INFO.Dynamic
          }
        );
      }
    };
    return api;
  }
  function extractVariantAtRules(node) {
    node.walkAtRules((atRule2) => {
      if (["responsive", "variants"].includes(atRule2.name)) {
        extractVariantAtRules(atRule2);
        atRule2.before(atRule2.nodes);
        atRule2.remove();
      }
    });
  }
  function collectLayerPlugins(root2) {
    let layerPlugins = [];
    root2.each((node) => {
      if (node.type === "atrule" && ["responsive", "variants"].includes(node.name)) {
        node.name = "layer";
        node.params = "utilities";
      }
    });
    root2.walkAtRules("layer", (layerRule) => {
      extractVariantAtRules(layerRule);
      if (layerRule.params === "base") {
        for (let node of layerRule.nodes) {
          layerPlugins.push(function({ addBase }) {
            addBase(node, { respectPrefix: false });
          });
        }
        layerRule.remove();
      } else if (layerRule.params === "components") {
        for (let node of layerRule.nodes) {
          layerPlugins.push(function({ addComponents }) {
            addComponents(node, { respectPrefix: false, preserveSource: true });
          });
        }
        layerRule.remove();
      } else if (layerRule.params === "utilities") {
        for (let node of layerRule.nodes) {
          layerPlugins.push(function({ addUtilities }) {
            addUtilities(node, { respectPrefix: false, preserveSource: true });
          });
        }
        layerRule.remove();
      }
    });
    return layerPlugins;
  }
  function resolvePlugins(context, root2) {
    let corePluginList = Object.entries({ ...variantPlugins, ...corePlugins }).map(([name, plugin2]) => {
      if (!context.tailwindConfig.corePlugins.includes(name)) {
        return null;
      }
      return plugin2;
    }).filter(Boolean);
    let userPlugins = context.tailwindConfig.plugins.map((plugin2) => {
      if (plugin2.__isOptionsFunction) {
        plugin2 = plugin2();
      }
      return typeof plugin2 === "function" ? plugin2 : plugin2.handler;
    });
    let layerPlugins = collectLayerPlugins(root2);
    let beforeVariants = [
      variantPlugins["pseudoElementVariants"],
      variantPlugins["pseudoClassVariants"],
      variantPlugins["ariaVariants"],
      variantPlugins["dataVariants"]
    ];
    let afterVariants = [
      variantPlugins["supportsVariants"],
      variantPlugins["directionVariants"],
      variantPlugins["reducedMotionVariants"],
      variantPlugins["prefersContrastVariants"],
      variantPlugins["darkVariants"],
      variantPlugins["printVariant"],
      variantPlugins["screenVariants"],
      variantPlugins["orientationVariants"]
    ];
    return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];
  }
  function registerPlugins(plugins, context) {
    let variantList = [];
    let variantMap = /* @__PURE__ */ new Map();
    context.variantMap = variantMap;
    let offsets = new Offsets();
    context.offsets = offsets;
    let classList = /* @__PURE__ */ new Set();
    let pluginApi = buildPluginApi(context.tailwindConfig, context, {
      variantList,
      variantMap,
      offsets,
      classList
    });
    for (let plugin2 of plugins) {
      if (Array.isArray(plugin2)) {
        for (let pluginItem of plugin2) {
          pluginItem(pluginApi);
        }
      } else {
        plugin2?.(pluginApi);
      }
    }
    offsets.recordVariants(variantList, (variant) => variantMap.get(variant).length);
    for (let [variantName, variantFunctions] of variantMap.entries()) {
      context.variantMap.set(
        variantName,
        variantFunctions.map((variantFunction, idx) => [
          offsets.forVariant(variantName, idx),
          variantFunction
        ])
      );
    }
    let safelist = (context.tailwindConfig.safelist ?? []).filter(Boolean);
    if (safelist.length > 0) {
      let checks = [];
      for (let value2 of safelist) {
        if (typeof value2 === "string") {
          context.changedContent.push({ content: value2, extension: "html" });
          continue;
        }
        if (value2 instanceof RegExp) {
          log_default.warn("root-regex", [
            "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
            "Update your `safelist` configuration to eliminate this warning.",
            "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
          ]);
          continue;
        }
        checks.push(value2);
      }
      if (checks.length > 0) {
        let patternMatchingCount = /* @__PURE__ */ new Map();
        let prefixLength = context.tailwindConfig.prefix.length;
        let checkImportantUtils = checks.some((check) => check.pattern.source.includes("!"));
        for (let util of classList) {
          let utils = Array.isArray(util) ? (() => {
            let [utilName, options] = util;
            let values = Object.keys(options?.values ?? {});
            let classes = values.map((value2) => formatClass(utilName, value2));
            if (options?.supportsNegativeValues) {
              classes = [...classes, ...classes.map((cls) => "-" + cls)];
              classes = [
                ...classes,
                ...classes.map(
                  (cls) => cls.slice(0, prefixLength) + "-" + cls.slice(prefixLength)
                )
              ];
            }
            if (options.types.some(({ type }) => type === "color")) {
              classes = [
                ...classes,
                ...classes.flatMap(
                  (cls) => Object.keys(context.tailwindConfig.theme.opacity).map(
                    (opacity) => `${cls}/${opacity}`
                  )
                )
              ];
            }
            if (checkImportantUtils && options?.respectImportant) {
              classes = [...classes, ...classes.map((cls) => "!" + cls)];
            }
            return classes;
          })() : [util];
          for (let util2 of utils) {
            for (let { pattern: pattern2, variants = [] } of checks) {
              pattern2.lastIndex = 0;
              if (!patternMatchingCount.has(pattern2)) {
                patternMatchingCount.set(pattern2, 0);
              }
              if (!pattern2.test(util2))
                continue;
              patternMatchingCount.set(pattern2, patternMatchingCount.get(pattern2) + 1);
              context.changedContent.push({ content: util2, extension: "html" });
              for (let variant of variants) {
                context.changedContent.push({
                  content: variant + context.tailwindConfig.separator + util2,
                  extension: "html"
                });
              }
            }
          }
        }
        for (let [regex, count] of patternMatchingCount.entries()) {
          if (count !== 0)
            continue;
          log_default.warn([
            `The safelist pattern \`${regex}\` doesn't match any Tailwind CSS classes.`,
            "Fix this pattern or remove it from your `safelist` configuration.",
            "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
          ]);
        }
      }
    }
    let darkClassName = [].concat(context.tailwindConfig.darkMode ?? "media")[1] ?? "dark";
    let parasiteUtilities = [
      prefix(context, darkClassName),
      prefix(context, "group"),
      prefix(context, "peer")
    ];
    context.getClassOrder = function getClassOrder(classes) {
      let sortedClassNames = new Map(classes.map((className) => [className, null]));
      let rules = generateRules(new Set(classes), context);
      rules = context.offsets.sort(rules);
      let idx = BigInt(parasiteUtilities.length);
      for (const [, rule2] of rules) {
        sortedClassNames.set(rule2.raws.tailwind.candidate, idx++);
      }
      return classes.map((className) => {
        let order = sortedClassNames.get(className) ?? null;
        let parasiteIndex = parasiteUtilities.indexOf(className);
        if (order === null && parasiteIndex !== -1) {
          order = BigInt(parasiteIndex);
        }
        return [className, order];
      });
    };
    context.getClassList = function getClassList(options = {}) {
      let output = [];
      for (let util of classList) {
        if (Array.isArray(util)) {
          let [utilName, utilOptions] = util;
          let negativeClasses = [];
          let modifiers = Object.keys(utilOptions?.modifiers ?? {});
          if (utilOptions?.types?.some(({ type }) => type === "color")) {
            modifiers.push(...Object.keys(context.tailwindConfig.theme.opacity ?? {}));
          }
          let metadata = { modifiers };
          let includeMetadata = options.includeMetadata && modifiers.length > 0;
          for (let [key, value2] of Object.entries(utilOptions?.values ?? {})) {
            if (value2 == null) {
              continue;
            }
            let cls = formatClass(utilName, key);
            output.push(includeMetadata ? [cls, metadata] : cls);
            if (utilOptions?.supportsNegativeValues && negateValue(value2)) {
              let cls2 = formatClass(utilName, `-${key}`);
              negativeClasses.push(includeMetadata ? [cls2, metadata] : cls2);
            }
          }
          output.push(...negativeClasses);
        } else {
          output.push(util);
        }
      }
      return output;
    };
    context.getVariants = function getVariants() {
      let result = [];
      for (let [name, options] of context.variantOptions.entries()) {
        if (options.variantInfo === VARIANT_INFO.Base)
          continue;
        result.push({
          name,
          isArbitrary: options.type === Symbol.for("MATCH_VARIANT"),
          values: Object.keys(options.values ?? {}),
          hasDash: name !== "@",
          selectors({ modifier, value: value2 } = {}) {
            let candidate = "__TAILWIND_PLACEHOLDER__";
            let rule2 = postcss_default.rule({ selector: `.${candidate}` });
            let container = postcss_default.root({ nodes: [rule2.clone()] });
            let before = container.toString();
            let fns = (context.variantMap.get(name) ?? []).flatMap(([_, fn2]) => fn2);
            let formatStrings = [];
            for (let fn2 of fns) {
              let localFormatStrings = [];
              let api = {
                args: { modifier, value: options.values?.[value2] ?? value2 },
                separator: context.tailwindConfig.separator,
                modifySelectors(modifierFunction) {
                  container.each((rule22) => {
                    if (rule22.type !== "rule") {
                      return;
                    }
                    rule22.selectors = rule22.selectors.map((selector) => {
                      return modifierFunction({
                        get className() {
                          return getClassNameFromSelector(selector);
                        },
                        selector
                      });
                    });
                  });
                  return container;
                },
                format(str) {
                  localFormatStrings.push(str);
                },
                wrap(wrapper) {
                  localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);
                },
                container
              };
              let ruleWithVariant = fn2(api);
              if (localFormatStrings.length > 0) {
                formatStrings.push(localFormatStrings);
              }
              if (Array.isArray(ruleWithVariant)) {
                for (let variantFunction of ruleWithVariant) {
                  localFormatStrings = [];
                  variantFunction(api);
                  formatStrings.push(localFormatStrings);
                }
              }
            }
            let manualFormatStrings = [];
            let after = container.toString();
            if (before !== after) {
              container.walkRules((rule22) => {
                let modified = rule22.selector;
                let rebuiltBase = (0, import_postcss_selector_parser7.default)((selectors) => {
                  selectors.walkClasses((classNode) => {
                    classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;
                  });
                }).processSync(modified);
                manualFormatStrings.push(modified.replace(rebuiltBase, "&").replace(candidate, "&"));
              });
              container.walkAtRules((atrule) => {
                manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);
              });
            }
            let isArbitraryVariant = !(value2 in (options.values ?? {}));
            formatStrings = formatStrings.map(
              (format) => format.map((str) => ({
                format: str,
                isArbitraryVariant
              }))
            );
            manualFormatStrings = manualFormatStrings.map((format) => ({
              format,
              isArbitraryVariant
            }));
            let opts = {
              candidate,
              context
            };
            let result2 = formatStrings.map(
              (formats) => finalizeSelector(`.${candidate}`, formatVariantSelector(formats, opts), opts).replace(`.${candidate}`, "&").replace("{ & }", "").trim()
            );
            if (manualFormatStrings.length > 0) {
              result2.push(
                formatVariantSelector(manualFormatStrings, opts).toString().replace(`.${candidate}`, "&")
              );
            }
            return result2;
          }
        });
      }
      return result;
    };
  }
  function markInvalidUtilityCandidate(context, candidate) {
    if (!context.classCache.has(candidate)) {
      return;
    }
    context.notClassCache.add(candidate);
    context.classCache.delete(candidate);
    context.applyClassCache.delete(candidate);
    context.candidateRuleMap.delete(candidate);
    context.candidateRuleCache.delete(candidate);
    context.stylesheetCache = null;
  }
  function markInvalidUtilityNode(context, node) {
    let candidate = node.raws.tailwind.candidate;
    if (!candidate) {
      return;
    }
    for (const entry of context.ruleCache) {
      if (entry[1].raws.tailwind.candidate === candidate) {
        context.ruleCache.delete(entry);
      }
    }
    markInvalidUtilityCandidate(context, candidate);
  }
  function createContext(tailwindConfig, changedContent = [], root2 = postcss_default.root()) {
    let context = {
      disposables: [],
      ruleCache: /* @__PURE__ */ new Set(),
      candidateRuleCache: /* @__PURE__ */ new Map(),
      classCache: /* @__PURE__ */ new Map(),
      applyClassCache: /* @__PURE__ */ new Map(),
      // Seed the not class cache with the blocklist (which is only strings)
      notClassCache: new Set(tailwindConfig.blocklist ?? []),
      postCssNodeCache: /* @__PURE__ */ new Map(),
      candidateRuleMap: /* @__PURE__ */ new Map(),
      tailwindConfig,
      changedContent,
      variantMap: /* @__PURE__ */ new Map(),
      stylesheetCache: null,
      variantOptions: /* @__PURE__ */ new Map(),
      markInvalidUtilityCandidate: (candidate) => markInvalidUtilityCandidate(context, candidate),
      markInvalidUtilityNode: (node) => markInvalidUtilityNode(context, node)
    };
    let resolvedPlugins = resolvePlugins(context, root2);
    registerPlugins(resolvedPlugins, context);
    return context;
  }
  var classNameParser = (0, import_postcss_selector_parser3.default)((selectors) => {
    return selectors.first.filter(({ type }) => type === "class").pop().value;
  });
  function getClassNameFromSelector(selector) {
    return classNameParser.transformSync(selector);
  }
  function* candidatePermutations(candidate) {
    let lastIndex = Infinity;
    while (lastIndex >= 0) {
      let dashIdx;
      let wasSlash = false;
      if (lastIndex === Infinity && candidate.endsWith("]")) {
        let bracketIdx = candidate.indexOf("[");
        if (candidate[bracketIdx - 1] === "-") {
          dashIdx = bracketIdx - 1;
        } else if (candidate[bracketIdx - 1] === "/") {
          dashIdx = bracketIdx - 1;
          wasSlash = true;
        } else {
          dashIdx = -1;
        }
      } else if (lastIndex === Infinity && candidate.includes("/")) {
        dashIdx = candidate.lastIndexOf("/");
        wasSlash = true;
      } else {
        dashIdx = candidate.lastIndexOf("-", lastIndex);
      }
      if (dashIdx < 0) {
        break;
      }
      let prefix3 = candidate.slice(0, dashIdx);
      let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);
      lastIndex = dashIdx - 1;
      if (prefix3 === "" || modifier === "/") {
        continue;
      }
      yield [prefix3, modifier];
    }
  }
  function applyPrefix(matches, context) {
    if (matches.length === 0 || context.tailwindConfig.prefix === "") {
      return matches;
    }
    for (let match of matches) {
      let [meta] = match;
      if (meta.options.respectPrefix) {
        let container = postcss_default.root({ nodes: [match[1].clone()] });
        let classCandidate = match[1].raws.tailwind.classCandidate;
        container.walkRules((r2) => {
          let shouldPrependNegative = classCandidate.startsWith("-");
          r2.selector = prefixSelector_default(
            context.tailwindConfig.prefix,
            r2.selector,
            shouldPrependNegative
          );
        });
        match[1] = container.nodes[0];
      }
    }
    return matches;
  }
  function applyImportant(matches, classCandidate) {
    if (matches.length === 0) {
      return matches;
    }
    let result = [];
    for (let [meta, rule2] of matches) {
      let container = postcss_default.root({ nodes: [rule2.clone()] });
      container.walkRules((r2) => {
        let ast = (0, import_postcss_selector_parser3.default)().astSync(r2.selector);
        ast.each((sel) => eliminateIrrelevantSelectors(sel, classCandidate));
        updateAllClasses(
          ast,
          (className) => className === classCandidate ? `!${className}` : className
        );
        r2.selector = ast.toString();
        r2.walkDecls((d) => d.important = true);
      });
      result.push([{ ...meta, important: true }, container.nodes[0]]);
    }
    return result;
  }
  function applyVariant(variant, matches, context) {
    if (matches.length === 0) {
      return matches;
    }
    let args = { modifier: null, value: NONE };
    {
      let [baseVariant, ...modifiers] = splitAtTopLevelOnly(variant, "/");
      if (modifiers.length > 1) {
        baseVariant = baseVariant + "/" + modifiers.slice(0, -1).join("/");
        modifiers = modifiers.slice(-1);
      }
      if (modifiers.length && !context.variantMap.has(variant)) {
        variant = baseVariant;
        args.modifier = modifiers[0];
        if (!flagEnabled(context.tailwindConfig, "generalizedModifiers")) {
          return [];
        }
      }
    }
    if (variant.endsWith("]") && !variant.startsWith("[")) {
      let match = /(.)(-?)\[(.*)\]/g.exec(variant);
      if (match) {
        let [, char, seperator, value2] = match;
        if (char === "@" && seperator === "-")
          return [];
        if (char !== "@" && seperator === "")
          return [];
        variant = variant.replace(`${seperator}[${value2}]`, "");
        args.value = value2;
      }
    }
    if (isArbitraryValue2(variant) && !context.variantMap.has(variant)) {
      let selector = normalize2(variant.slice(1, -1));
      if (!isValidVariantFormatString(selector)) {
        return [];
      }
      let fn2 = parseVariant(selector);
      let sort = context.offsets.recordVariant(variant);
      context.variantMap.set(variant, [[sort, fn2]]);
    }
    if (context.variantMap.has(variant)) {
      let isArbitraryVariant = isArbitraryValue2(variant);
      let variantFunctionTuples = context.variantMap.get(variant).slice();
      let result = [];
      for (let [meta, rule2] of matches) {
        if (meta.layer === "user") {
          continue;
        }
        let container = postcss_default.root({ nodes: [rule2.clone()] });
        for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {
          let prepareBackup = function() {
            if (clone.raws.neededBackup) {
              return;
            }
            clone.raws.neededBackup = true;
            clone.walkRules((rule22) => rule22.raws.originalSelector = rule22.selector);
          }, modifySelectors = function(modifierFunction) {
            prepareBackup();
            clone.each((rule22) => {
              if (rule22.type !== "rule") {
                return;
              }
              rule22.selectors = rule22.selectors.map((selector) => {
                return modifierFunction({
                  get className() {
                    return getClassNameFromSelector(selector);
                  },
                  selector
                });
              });
            });
            return clone;
          };
          let clone = (containerFromArray ?? container).clone();
          let collectedFormats = [];
          let ruleWithVariant = variantFunction({
            // Public API
            get container() {
              prepareBackup();
              return clone;
            },
            separator: context.tailwindConfig.separator,
            modifySelectors,
            // Private API for now
            wrap(wrapper) {
              let nodes = clone.nodes;
              clone.removeAll();
              wrapper.append(nodes);
              clone.append(wrapper);
            },
            format(selectorFormat) {
              collectedFormats.push({
                format: selectorFormat,
                isArbitraryVariant
              });
            },
            args
          });
          if (Array.isArray(ruleWithVariant)) {
            for (let [idx, variantFunction2] of ruleWithVariant.entries()) {
              variantFunctionTuples.push([
                context.offsets.applyParallelOffset(variantSort, idx),
                variantFunction2,
                // If the clone has been modified we have to pass that back
                // though so each rule can use the modified container
                clone.clone()
              ]);
            }
            continue;
          }
          if (typeof ruleWithVariant === "string") {
            collectedFormats.push({
              format: ruleWithVariant,
              isArbitraryVariant
            });
          }
          if (ruleWithVariant === null) {
            continue;
          }
          if (clone.raws.neededBackup) {
            delete clone.raws.neededBackup;
            clone.walkRules((rule22) => {
              let before = rule22.raws.originalSelector;
              if (!before)
                return;
              delete rule22.raws.originalSelector;
              if (before === rule22.selector)
                return;
              let modified = rule22.selector;
              let rebuiltBase = (0, import_postcss_selector_parser3.default)((selectors) => {
                selectors.walkClasses((classNode) => {
                  classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;
                });
              }).processSync(before);
              collectedFormats.push({
                format: modified.replace(rebuiltBase, "&"),
                isArbitraryVariant
              });
              rule22.selector = before;
            });
          }
          clone.nodes[0].raws.tailwind = { ...clone.nodes[0].raws.tailwind, parentLayer: meta.layer };
          let withOffset = [
            {
              ...meta,
              sort: context.offsets.applyVariantOffset(
                meta.sort,
                variantSort,
                Object.assign(args, context.variantOptions.get(variant))
              ),
              collectedFormats: (meta.collectedFormats ?? []).concat(collectedFormats)
            },
            clone.nodes[0]
          ];
          result.push(withOffset);
        }
      }
      return result;
    }
    return [];
  }
  function parseRules(rule2, cache3, options = {}) {
    if (!isPlainObject(rule2) && !Array.isArray(rule2)) {
      return [[rule2], options];
    }
    if (Array.isArray(rule2)) {
      return parseRules(rule2[0], cache3, rule2[1]);
    }
    if (!cache3.has(rule2)) {
      cache3.set(rule2, parseObjectStyles(rule2));
    }
    return [cache3.get(rule2), options];
  }
  var IS_VALID_PROPERTY_NAME = /^[a-z_-]/;
  function isValidPropName(name) {
    return IS_VALID_PROPERTY_NAME.test(name);
  }
  function looksLikeUri(declaration) {
    if (!declaration.includes("://")) {
      return false;
    }
    try {
      const url2 = new URL(declaration);
      return url2.scheme !== "" && url2.host !== "";
    } catch (err) {
      return false;
    }
  }
  function isParsableNode(node) {
    let isParsable = true;
    node.walkDecls((decl2) => {
      if (!isParsableCssValue(decl2.prop, decl2.value)) {
        isParsable = false;
        return false;
      }
    });
    return isParsable;
  }
  function isParsableCssValue(property, value2) {
    if (looksLikeUri(`${property}:${value2}`)) {
      return false;
    }
    try {
      postcss_default.parse(`a{${property}:${value2}}`).toResult();
      return true;
    } catch (err) {
      return false;
    }
  }
  function extractArbitraryProperty(classCandidate, context) {
    let [, property, value2] = classCandidate.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/) ?? [];
    if (value2 === void 0) {
      return null;
    }
    if (!isValidPropName(property)) {
      return null;
    }
    if (!isSyntacticallyValidPropertyValue(value2)) {
      return null;
    }
    let normalized = normalize2(value2);
    if (!isParsableCssValue(property, normalized)) {
      return null;
    }
    let sort = context.offsets.arbitraryProperty();
    return [
      [
        { sort, layer: "utilities" },
        () => ({
          [asClass(classCandidate)]: {
            [property]: normalized
          }
        })
      ]
    ];
  }
  function* resolveMatchedPlugins(classCandidate, context) {
    if (context.candidateRuleMap.has(classCandidate)) {
      yield [context.candidateRuleMap.get(classCandidate), "DEFAULT"];
    }
    yield* function* (arbitraryPropertyRule) {
      if (arbitraryPropertyRule !== null) {
        yield [arbitraryPropertyRule, "DEFAULT"];
      }
    }(extractArbitraryProperty(classCandidate, context));
    let candidatePrefix = classCandidate;
    let negative = false;
    const twConfigPrefix = context.tailwindConfig.prefix;
    const twConfigPrefixLen = twConfigPrefix.length;
    const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);
    if (candidatePrefix[twConfigPrefixLen] === "-" && hasMatchingPrefix) {
      negative = true;
      candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);
    }
    if (negative && context.candidateRuleMap.has(candidatePrefix)) {
      yield [context.candidateRuleMap.get(candidatePrefix), "-DEFAULT"];
    }
    for (let [prefix3, modifier] of candidatePermutations(candidatePrefix)) {
      if (context.candidateRuleMap.has(prefix3)) {
        yield [context.candidateRuleMap.get(prefix3), negative ? `-${modifier}` : modifier];
      }
    }
  }
  function splitWithSeparator(input, separator) {
    if (input === NOT_ON_DEMAND) {
      return [NOT_ON_DEMAND];
    }
    return splitAtTopLevelOnly(input, separator);
  }
  function* recordCandidates(matches, classCandidate) {
    for (const match of matches) {
      match[1].raws.tailwind = {
        ...match[1].raws.tailwind,
        classCandidate,
        preserveSource: match[0].options?.preserveSource ?? false
      };
      yield match;
    }
  }
  function* resolveMatches(candidate, context, original = candidate) {
    let separator = context.tailwindConfig.separator;
    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();
    let important = false;
    if (classCandidate.startsWith("!")) {
      important = true;
      classCandidate = classCandidate.slice(1);
    }
    if (flagEnabled(context.tailwindConfig, "variantGrouping")) {
      if (classCandidate.startsWith("(") && classCandidate.endsWith(")")) {
        let base = variants.slice().reverse().join(separator);
        for (let part of splitAtTopLevelOnly(classCandidate.slice(1, -1), ",")) {
          yield* resolveMatches(base + separator + part, context, original);
        }
      }
    }
    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {
      let matches = [];
      let typesByMatches = /* @__PURE__ */ new Map();
      let [plugins, modifier] = matchedPlugins;
      let isOnlyPlugin = plugins.length === 1;
      for (let [sort, plugin2] of plugins) {
        let matchesPerPlugin = [];
        if (typeof plugin2 === "function") {
          for (let ruleSet of [].concat(plugin2(modifier, { isOnlyPlugin }))) {
            let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
            for (let rule2 of rules) {
              matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule2]);
            }
          }
        } else if (modifier === "DEFAULT" || modifier === "-DEFAULT") {
          let ruleSet = plugin2;
          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
          for (let rule2 of rules) {
            matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule2]);
          }
        }
        if (matchesPerPlugin.length > 0) {
          let matchingTypes = Array.from(
            getMatchingTypes(
              sort.options?.types ?? [],
              modifier,
              sort.options ?? {},
              context.tailwindConfig
            )
          ).map(([_, type]) => type);
          if (matchingTypes.length > 0) {
            typesByMatches.set(matchesPerPlugin, matchingTypes);
          }
          matches.push(matchesPerPlugin);
        }
      }
      if (isArbitraryValue2(modifier)) {
        if (matches.length > 1) {
          let findFallback = function(matches2) {
            if (matches2.length === 1) {
              return matches2[0];
            }
            return matches2.find((rules) => {
              let matchingTypes = typesByMatches.get(rules);
              return rules.some(([{ options }, rule2]) => {
                if (!isParsableNode(rule2)) {
                  return false;
                }
                return options.types.some(
                  ({ type, preferOnConflict }) => matchingTypes.includes(type) && preferOnConflict
                );
              });
            });
          };
          let [withAny, withoutAny] = matches.reduce(
            (group, plugin2) => {
              let hasAnyType = plugin2.some(
                ([{ options }]) => options.types.some(({ type }) => type === "any")
              );
              if (hasAnyType) {
                group[0].push(plugin2);
              } else {
                group[1].push(plugin2);
              }
              return group;
            },
            [[], []]
          );
          let fallback = findFallback(withoutAny) ?? findFallback(withAny);
          if (fallback) {
            matches = [fallback];
          } else {
            let typesPerPlugin = matches.map(
              (match) => /* @__PURE__ */ new Set([...typesByMatches.get(match) ?? []])
            );
            for (let pluginTypes of typesPerPlugin) {
              for (let type of pluginTypes) {
                let removeFromOwnGroup = false;
                for (let otherGroup of typesPerPlugin) {
                  if (pluginTypes === otherGroup)
                    continue;
                  if (otherGroup.has(type)) {
                    otherGroup.delete(type);
                    removeFromOwnGroup = true;
                  }
                }
                if (removeFromOwnGroup)
                  pluginTypes.delete(type);
              }
            }
            let messages = [];
            for (let [idx, group] of typesPerPlugin.entries()) {
              for (let type of group) {
                let rules = matches[idx].map(([, rule2]) => rule2).flat().map(
                  (rule2) => rule2.toString().split("\n").slice(1, -1).map((line) => line.trim()).map((x) => `      ${x}`).join("\n")
                ).join("\n\n");
                messages.push(
                  `  Use \`${candidate.replace("[", `[${type}:`)}\` for \`${rules.trim()}\``
                );
                break;
              }
            }
            log_default.warn([
              `The class \`${candidate}\` is ambiguous and matches multiple utilities.`,
              ...messages,
              `If this is content and not a class, replace it with \`${candidate.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
            ]);
            continue;
          }
        }
        matches = matches.map((list22) => list22.filter((match) => isParsableNode(match[1])));
      }
      matches = matches.flat();
      matches = Array.from(recordCandidates(matches, classCandidate));
      matches = applyPrefix(matches, context);
      if (important) {
        matches = applyImportant(matches, classCandidate);
      }
      for (let variant of variants) {
        matches = applyVariant(variant, matches, context);
      }
      for (let match of matches) {
        match[1].raws.tailwind = { ...match[1].raws.tailwind, candidate };
        match = applyFinalFormat(match, { context, candidate, original });
        if (match === null) {
          continue;
        }
        yield match;
      }
    }
  }
  function applyFinalFormat(match, { context, candidate, original }) {
    if (!match[0].collectedFormats) {
      return match;
    }
    let isValid = true;
    let finalFormat;
    try {
      finalFormat = formatVariantSelector(match[0].collectedFormats, {
        context,
        candidate
      });
    } catch {
      return null;
    }
    let container = postcss_default.root({ nodes: [match[1].clone()] });
    container.walkRules((rule2) => {
      if (inKeyframes(rule2)) {
        return;
      }
      try {
        rule2.selector = finalizeSelector(rule2.selector, finalFormat, {
          candidate: original,
          context
        });
      } catch {
        isValid = false;
        return false;
      }
    });
    if (!isValid) {
      return null;
    }
    match[1] = container.nodes[0];
    return match;
  }
  function inKeyframes(rule2) {
    return rule2.parent && rule2.parent.type === "atrule" && rule2.parent.name === "keyframes";
  }
  function getImportantStrategy(important) {
    if (important === true) {
      return (rule2) => {
        if (inKeyframes(rule2)) {
          return;
        }
        rule2.walkDecls((d) => {
          if (d.parent.type === "rule" && !inKeyframes(d.parent)) {
            d.important = true;
          }
        });
      };
    }
    if (typeof important === "string") {
      return (rule2) => {
        if (inKeyframes(rule2)) {
          return;
        }
        rule2.selectors = rule2.selectors.map((selector) => {
          return `${important} ${selector}`;
        });
      };
    }
  }
  function generateRules(candidates, context) {
    let allRules = [];
    let strategy = getImportantStrategy(context.tailwindConfig.important);
    for (let candidate of candidates) {
      if (context.notClassCache.has(candidate)) {
        continue;
      }
      if (context.candidateRuleCache.has(candidate)) {
        allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));
        continue;
      }
      let matches = Array.from(resolveMatches(candidate, context));
      if (matches.length === 0) {
        context.notClassCache.add(candidate);
        continue;
      }
      context.classCache.set(candidate, matches);
      let rules = context.candidateRuleCache.get(candidate) ?? /* @__PURE__ */ new Set();
      context.candidateRuleCache.set(candidate, rules);
      for (const match of matches) {
        let [{ sort, options }, rule2] = match;
        if (options.respectImportant && strategy) {
          let container = postcss_default.root({ nodes: [rule2.clone()] });
          container.walkRules(strategy);
          rule2 = container.nodes[0];
        }
        let newEntry = [sort, rule2];
        rules.add(newEntry);
        context.ruleCache.add(newEntry);
        allRules.push(newEntry);
      }
    }
    return allRules;
  }
  function isArbitraryValue2(input) {
    return input.startsWith("[") && input.endsWith("]");
  }
  function extractClasses(node) {
    let groups = /* @__PURE__ */ new Map();
    let container = postcss_default.root({ nodes: [node.clone()] });
    container.walkRules((rule2) => {
      (0, import_postcss_selector_parser2.default)((selectors) => {
        selectors.walkClasses((classSelector) => {
          let parentSelector = classSelector.parent.toString();
          let classes2 = groups.get(parentSelector);
          if (!classes2) {
            groups.set(parentSelector, classes2 = /* @__PURE__ */ new Set());
          }
          classes2.add(classSelector.value);
        });
      }).processSync(rule2.selector);
    });
    let normalizedGroups = Array.from(groups.values(), (classes2) => Array.from(classes2));
    let classes = normalizedGroups.flat();
    return Object.assign(classes, { groups: normalizedGroups });
  }
  var selectorExtractor = (0, import_postcss_selector_parser2.default)();
  function extractSelectors(ruleSelectors) {
    return selectorExtractor.astSync(ruleSelectors);
  }
  function extractBaseCandidates(candidates, separator) {
    let baseClasses = /* @__PURE__ */ new Set();
    for (let candidate of candidates) {
      baseClasses.add(candidate.split(separator).pop());
    }
    return Array.from(baseClasses);
  }
  function prefix2(context, selector) {
    let prefix3 = context.tailwindConfig.prefix;
    return typeof prefix3 === "function" ? prefix3(selector) : prefix3 + selector;
  }
  function* pathToRoot(node) {
    yield node;
    while (node.parent) {
      yield node.parent;
      node = node.parent;
    }
  }
  function shallowClone(node, overrides = {}) {
    let children = node.nodes;
    node.nodes = [];
    let tmp = node.clone(overrides);
    node.nodes = children;
    return tmp;
  }
  function nestedClone(node) {
    for (let parent of pathToRoot(node)) {
      if (node === parent) {
        continue;
      }
      if (parent.type === "root") {
        break;
      }
      node = shallowClone(parent, {
        nodes: [node]
      });
    }
    return node;
  }
  function buildLocalApplyCache(root2, context) {
    let cache3 = /* @__PURE__ */ new Map();
    root2.walkRules((rule2) => {
      for (let node of pathToRoot(rule2)) {
        if (node.raws.tailwind?.layer !== void 0) {
          return;
        }
      }
      let container = nestedClone(rule2);
      let sort = context.offsets.create("user");
      for (let className of extractClasses(rule2)) {
        let list22 = cache3.get(className) || [];
        cache3.set(className, list22);
        list22.push([
          {
            layer: "user",
            sort,
            important: false
          },
          container
        ]);
      }
    });
    return cache3;
  }
  function buildApplyCache(applyCandidates, context) {
    for (let candidate of applyCandidates) {
      if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {
        continue;
      }
      if (context.classCache.has(candidate)) {
        context.applyClassCache.set(
          candidate,
          context.classCache.get(candidate).map(([meta, rule2]) => [meta, rule2.clone()])
        );
        continue;
      }
      let matches = Array.from(resolveMatches(candidate, context));
      if (matches.length === 0) {
        context.notClassCache.add(candidate);
        continue;
      }
      context.applyClassCache.set(candidate, matches);
    }
    return context.applyClassCache;
  }
  function lazyCache(buildCacheFn) {
    let cache3 = null;
    return {
      get: (name) => {
        cache3 = cache3 || buildCacheFn();
        return cache3.get(name);
      },
      has: (name) => {
        cache3 = cache3 || buildCacheFn();
        return cache3.has(name);
      }
    };
  }
  function combineCaches(caches) {
    return {
      get: (name) => caches.flatMap((cache3) => cache3.get(name) || []),
      has: (name) => caches.some((cache3) => cache3.has(name))
    };
  }
  function extractApplyCandidates(params) {
    let candidates = params.split(/[\s\t\n]+/g);
    if (candidates[candidates.length - 1] === "!important") {
      return [candidates.slice(0, -1), true];
    }
    return [candidates, false];
  }
  function processApply(root2, context, localCache) {
    let applyCandidates = /* @__PURE__ */ new Set();
    let applies = [];
    root2.walkAtRules("apply", (rule2) => {
      let [candidates] = extractApplyCandidates(rule2.params);
      for (let util of candidates) {
        applyCandidates.add(util);
      }
      applies.push(rule2);
    });
    if (applies.length === 0) {
      return;
    }
    let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)]);
    function replaceSelector(selector, utilitySelectors, candidate) {
      let selectorList = extractSelectors(selector);
      let utilitySelectorsList = extractSelectors(utilitySelectors);
      let candidateList = extractSelectors(`.${escapeClassName(candidate)}`);
      let candidateClass = candidateList.nodes[0].nodes[0];
      selectorList.each((sel) => {
        let replaced = /* @__PURE__ */ new Set();
        utilitySelectorsList.each((utilitySelector) => {
          let hasReplaced = false;
          utilitySelector = utilitySelector.clone();
          utilitySelector.walkClasses((node) => {
            if (node.value !== candidateClass.value) {
              return;
            }
            if (hasReplaced) {
              return;
            }
            node.replaceWith(...sel.nodes.map((node2) => node2.clone()));
            replaced.add(utilitySelector);
            hasReplaced = true;
          });
        });
        for (let sel2 of replaced) {
          let groups = [[]];
          for (let node of sel2.nodes) {
            if (node.type === "combinator") {
              groups.push(node);
              groups.push([]);
            } else {
              let last = groups[groups.length - 1];
              last.push(node);
            }
          }
          sel2.nodes = [];
          for (let group of groups) {
            if (Array.isArray(group)) {
              group.sort((a, b) => {
                if (a.type === "tag" && b.type === "class") {
                  return -1;
                } else if (a.type === "class" && b.type === "tag") {
                  return 1;
                } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
                  return -1;
                } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
                  return 1;
                }
                return 0;
              });
            }
            sel2.nodes = sel2.nodes.concat(group);
          }
        }
        sel.replaceWith(...replaced);
      });
      return selectorList.toString();
    }
    let perParentApplies = /* @__PURE__ */ new Map();
    for (let apply of applies) {
      let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source];
      perParentApplies.set(apply.parent, [candidates, apply.source]);
      let [applyCandidates2, important] = extractApplyCandidates(apply.params);
      if (apply.parent.type === "atrule") {
        if (apply.parent.name === "screen") {
          let screenType = apply.parent.params;
          throw apply.error(
            `@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates2.map((c4) => `${screenType}:${c4}`).join(" ")} instead.`
          );
        }
        throw apply.error(
          `@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`
        );
      }
      for (let applyCandidate of applyCandidates2) {
        if ([prefix2(context, "group"), prefix2(context, "peer")].includes(applyCandidate)) {
          throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);
        }
        if (!applyClassCache.has(applyCandidate)) {
          throw apply.error(
            `The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`
          );
        }
        let rules = applyClassCache.get(applyCandidate);
        candidates.push([applyCandidate, important, rules]);
      }
    }
    for (let [parent, [candidates, atApplySource]] of perParentApplies) {
      let siblings = [];
      for (let [applyCandidate, important, rules] of candidates) {
        let potentialApplyCandidates = [
          applyCandidate,
          ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator)
        ];
        for (let [meta, node] of rules) {
          let parentClasses = extractClasses(parent);
          let nodeClasses = extractClasses(node);
          nodeClasses = nodeClasses.groups.filter(
            (classList) => classList.some((className) => potentialApplyCandidates.includes(className))
          ).flat();
          nodeClasses = nodeClasses.concat(
            extractBaseCandidates(nodeClasses, context.tailwindConfig.separator)
          );
          let intersects = parentClasses.some((selector) => nodeClasses.includes(selector));
          if (intersects) {
            throw node.error(
              `You cannot \`@apply\` the \`${applyCandidate}\` utility here because it creates a circular dependency.`
            );
          }
          let root22 = postcss_default.root({ nodes: [node.clone()] });
          root22.walk((node2) => {
            node2.source = atApplySource;
          });
          let canRewriteSelector = node.type !== "atrule" || node.type === "atrule" && node.name !== "keyframes";
          if (canRewriteSelector) {
            root22.walkRules((rule2) => {
              if (!extractClasses(rule2).some((candidate) => candidate === applyCandidate)) {
                rule2.remove();
                return;
              }
              let importantSelector = typeof context.tailwindConfig.important === "string" ? context.tailwindConfig.important : null;
              let isGenerated = parent.raws.tailwind !== void 0;
              let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;
              rule2.selector = replaceSelector(parentSelector, rule2.selector, applyCandidate);
              if (importantSelector && parentSelector !== parent.selector) {
                rule2.selector = `${importantSelector} ${rule2.selector}`;
              }
              rule2.walkDecls((d) => {
                d.important = meta.important || important;
              });
            });
          }
          if (!root22.nodes[0]) {
            continue;
          }
          siblings.push([meta.sort, root22.nodes[0]]);
        }
      }
      let nodes = context.offsets.sort(siblings).map((s2) => s2[1]);
      parent.after(nodes);
    }
    for (let apply of applies) {
      if (apply.parent.nodes.length > 1) {
        apply.remove();
      } else {
        apply.parent.remove();
      }
    }
    processApply(root2, context, localCache);
  }
  function expandApplyAtRules(context) {
    return (root2) => {
      let localCache = lazyCache(() => buildLocalApplyCache(root2, context));
      processApply(root2, context, localCache);
    };
  }
  function normalizeTailwindDirectives(root2) {
    let tailwindDirectives = /* @__PURE__ */ new Set();
    let layerDirectives = /* @__PURE__ */ new Set();
    let applyDirectives = /* @__PURE__ */ new Set();
    root2.walkAtRules((atRule2) => {
      if (atRule2.name === "apply") {
        applyDirectives.add(atRule2);
      }
      if (atRule2.name === "import") {
        if (atRule2.params === '"tailwindcss/base"' || atRule2.params === "'tailwindcss/base'") {
          atRule2.name = "tailwind";
          atRule2.params = "base";
        } else if (atRule2.params === '"tailwindcss/components"' || atRule2.params === "'tailwindcss/components'") {
          atRule2.name = "tailwind";
          atRule2.params = "components";
        } else if (atRule2.params === '"tailwindcss/utilities"' || atRule2.params === "'tailwindcss/utilities'") {
          atRule2.name = "tailwind";
          atRule2.params = "utilities";
        } else if (atRule2.params === '"tailwindcss/screens"' || atRule2.params === "'tailwindcss/screens'" || atRule2.params === '"tailwindcss/variants"' || atRule2.params === "'tailwindcss/variants'") {
          atRule2.name = "tailwind";
          atRule2.params = "variants";
        }
      }
      if (atRule2.name === "tailwind") {
        if (atRule2.params === "screens") {
          atRule2.params = "variants";
        }
        tailwindDirectives.add(atRule2.params);
      }
      if (["layer", "responsive", "variants"].includes(atRule2.name)) {
        if (["responsive", "variants"].includes(atRule2.name)) {
          log_default.warn(`${atRule2.name}-at-rule-deprecated`, [
            `The \`@${atRule2.name}\` directive has been deprecated in Tailwind CSS v3.0.`,
            `Use \`@layer utilities\` or \`@layer components\` instead.`,
            "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"
          ]);
        }
        layerDirectives.add(atRule2);
      }
    });
    if (!tailwindDirectives.has("base") || !tailwindDirectives.has("components") || !tailwindDirectives.has("utilities")) {
      for (let rule2 of layerDirectives) {
        if (rule2.name === "layer" && ["base", "components", "utilities"].includes(rule2.params)) {
          if (!tailwindDirectives.has(rule2.params)) {
            throw rule2.error(
              `\`@layer ${rule2.params}\` is used but no matching \`@tailwind ${rule2.params}\` directive is present.`
            );
          }
        } else if (rule2.name === "responsive") {
          if (!tailwindDirectives.has("utilities")) {
            throw rule2.error("`@responsive` is used but `@tailwind utilities` is missing.");
          }
        } else if (rule2.name === "variants") {
          if (!tailwindDirectives.has("utilities")) {
            throw rule2.error("`@variants` is used but `@tailwind utilities` is missing.");
          }
        }
      }
    }
    return { tailwindDirectives, applyDirectives };
  }
  function cloneNodes(nodes, source = void 0, raws = void 0) {
    return nodes.map((node) => {
      let cloned = node.clone();
      let shouldOverwriteSource = node.raws.tailwind?.preserveSource !== true || !cloned.source;
      if (source !== void 0 && shouldOverwriteSource) {
        cloned.source = source;
        if ("walk" in cloned) {
          cloned.walk((child) => {
            child.source = source;
          });
        }
      }
      if (raws !== void 0) {
        cloned.raws.tailwind = {
          ...cloned.raws.tailwind,
          ...raws
        };
      }
      return cloned;
    });
  }
  var REGEX_SPECIAL = /[\\^$.*+?()[\]{}|]/g;
  var REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);
  function toSource(source) {
    source = Array.isArray(source) ? source : [source];
    source = source.map((item) => item instanceof RegExp ? item.source : item);
    return source.join("");
  }
  function pattern(source) {
    return new RegExp(toSource(source), "g");
  }
  function any(sources) {
    return `(?:${sources.map(toSource).join("|")})`;
  }
  function optional(source) {
    return `(?:${toSource(source)})?`;
  }
  function zeroOrMore(source) {
    return `(?:${toSource(source)})*`;
  }
  function escape(string) {
    return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, "\\$&") : string || "";
  }
  function defaultExtractor(context) {
    let patterns = Array.from(buildRegExps(context));
    return (content) => {
      let results = [];
      for (let pattern2 of patterns) {
        results = [...results, ...content.match(pattern2) ?? []];
      }
      return results.filter((v) => v !== void 0).map(clipAtBalancedParens);
    };
  }
  function* buildRegExps(context) {
    let separator = context.tailwindConfig.separator;
    let variantGroupingEnabled = flagEnabled(context.tailwindConfig, "variantGrouping");
    let prefix3 = context.tailwindConfig.prefix !== "" ? optional(pattern([/-?/, escape(context.tailwindConfig.prefix)])) : "";
    let utility = any([
      // Arbitrary properties (without square brackets)
      /\[[^\s:'"`]+:[^\s\[\]]+\]/,
      // Arbitrary properties with balanced square brackets
      // This is a targeted fix to continue to allow theme()
      // with square brackets to work in arbitrary properties
      // while fixing a problem with the regex matching too much
      /\[[^\s:'"`]+:[^\s]+?\[[^\s]+?\][^\s]+?\]/,
      // Utilities
      pattern([
        // Utility Name / Group Name
        /-?(?:\w+)/,
        // Normal/Arbitrary values
        optional(
          any([
            pattern([
              // Arbitrary values
              /-(?:\w+-)*\[[^\s:]+\]/,
              // Not immediately followed by an `{[(`
              /(?![{([]])/,
              // optionally followed by an opacity modifier
              /(?:\/[^\s'"`\\><$]*)?/
            ]),
            pattern([
              // Arbitrary values
              /-(?:\w+-)*\[[^\s]+\]/,
              // Not immediately followed by an `{[(`
              /(?![{([]])/,
              // optionally followed by an opacity modifier
              /(?:\/[^\s'"`\\$]*)?/
            ]),
            // Normal values w/o quotes  may include an opacity modifier
            /[-\/][^\s'"`\\$={><]*/
          ])
        )
      ])
    ]);
    let variantPatterns = [
      // Without quotes
      any([
        // This is here to provide special support for the `@` variant
        pattern([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, separator]),
        pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, separator]),
        pattern([/[^\s"'`\[\\]+/, separator])
      ]),
      // With quotes allowed
      any([
        pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, separator]),
        pattern([/[^\s`\[\\]+/, separator])
      ])
    ];
    for (const variantPattern of variantPatterns) {
      yield pattern([
        // Variants
        "((?=((",
        variantPattern,
        ")+))\\2)?",
        // Important (optional)
        /!?/,
        prefix3,
        variantGroupingEnabled ? any([
          // Or any of those things but grouped separated by commas
          pattern([/\(/, utility, zeroOrMore([/,/, utility]), /\)/]),
          // Arbitrary properties, constrained utilities, arbitrary values, etc
          utility
        ]) : utility
      ]);
    }
    yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
  }
  var SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g;
  var ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/;
  function clipAtBalancedParens(input) {
    if (!input.includes("-[")) {
      return input;
    }
    let depth = 0;
    let openStringTypes = [];
    let matches = input.matchAll(SPECIALS);
    matches = Array.from(matches).flatMap((match) => {
      const [, ...groups] = match;
      return groups.map(
        (group, idx) => Object.assign([], match, {
          index: match.index + idx,
          0: group
        })
      );
    });
    for (let match of matches) {
      let char = match[0];
      let inStringType = openStringTypes[openStringTypes.length - 1];
      if (char === inStringType) {
        openStringTypes.pop();
      } else if (char === "'" || char === '"' || char === "`") {
        openStringTypes.push(char);
      }
      if (inStringType) {
        continue;
      } else if (char === "[") {
        depth++;
        continue;
      } else if (char === "]") {
        depth--;
        continue;
      }
      if (depth < 0) {
        return input.substring(0, match.index - 1);
      }
      if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {
        return input.substring(0, match.index);
      }
    }
    return input;
  }
  var builtInExtractors = {
    DEFAULT: defaultExtractor
  };
  var builtInTransformers = {
    DEFAULT: (content) => content,
    svelte: (content) => content.replace(/(?:^|\s)class:/g, " ")
  };
  function getExtractor(context, fileExtension) {
    let extractors = context.tailwindConfig.content.extract;
    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
  }
  function getTransformer(tailwindConfig, fileExtension) {
    let transformers = tailwindConfig.content.transform;
    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
  }
  var extractorCache = /* @__PURE__ */ new WeakMap();
  function getClassCandidates(content, extractor, candidates, seen) {
    if (!extractorCache.has(extractor)) {
      extractorCache.set(extractor, new QuickLRU({ maxSize: 25e3 }));
    }
    for (let line of content.split("\n")) {
      line = line.trim();
      if (seen.has(line)) {
        continue;
      }
      seen.add(line);
      if (extractorCache.get(extractor).has(line)) {
        for (let match of extractorCache.get(extractor).get(line)) {
          candidates.add(match);
        }
      } else {
        let extractorMatches = extractor(line).filter((s2) => s2 !== "!*");
        let lineMatchesSet = new Set(extractorMatches);
        for (let match of lineMatchesSet) {
          candidates.add(match);
        }
        extractorCache.get(extractor).set(line, lineMatchesSet);
      }
    }
  }
  function buildStylesheet(rules, context) {
    let sortedRules = context.offsets.sort(rules);
    let returnValue = {
      base: /* @__PURE__ */ new Set(),
      defaults: /* @__PURE__ */ new Set(),
      components: /* @__PURE__ */ new Set(),
      utilities: /* @__PURE__ */ new Set(),
      variants: /* @__PURE__ */ new Set()
    };
    for (let [sort, rule2] of sortedRules) {
      returnValue[sort.layer].add(rule2);
    }
    return returnValue;
  }
  function expandTailwindAtRules(context) {
    return (root2) => {
      let layerNodes = {
        base: null,
        components: null,
        utilities: null,
        variants: null
      };
      root2.walkAtRules((rule2) => {
        if (rule2.name === "tailwind") {
          if (Object.keys(layerNodes).includes(rule2.params)) {
            layerNodes[rule2.params] = rule2;
          }
        }
      });
      if (Object.values(layerNodes).every((n2) => n2 === null)) {
        return root2;
      }
      let candidates = /* @__PURE__ */ new Set([...context.candidates ?? [], NOT_ON_DEMAND]);
      let seen = /* @__PURE__ */ new Set();
      if (void 0) {
        for (let candidate of null.parseCandidateStringsFromFiles(
          context.changedContent
          // Object.assign({}, builtInTransformers, context.tailwindConfig.content.transform)
        )) {
          candidates.add(candidate);
        }
      } else {
        for (let { file, content, extension } of context.changedContent) {
          let transformer = getTransformer(context.tailwindConfig, extension);
          let extractor = getExtractor(context, extension);
          content = file ? fs_default.readFileSync(file, "utf8") : content;
          getClassCandidates(transformer(content), extractor, candidates, seen);
        }
      }
      let classCacheCount = context.classCache.size;
      let sortedCandidates = void 0 ? candidates : new Set(
        [...candidates].sort((a, z) => {
          if (a === z)
            return 0;
          if (a < z)
            return -1;
          return 1;
        })
      );
      generateRules(sortedCandidates, context);
      if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
        context.stylesheetCache = buildStylesheet([...context.ruleCache], context);
      }
      let {
        defaults: defaultNodes,
        base: baseNodes,
        components: componentNodes,
        utilities: utilityNodes,
        variants: screenNodes
      } = context.stylesheetCache;
      if (layerNodes.base) {
        layerNodes.base.before(
          cloneNodes([...baseNodes, ...defaultNodes], layerNodes.base.source, {
            layer: "base"
          })
        );
        layerNodes.base.remove();
      }
      if (layerNodes.components) {
        layerNodes.components.before(
          cloneNodes([...componentNodes], layerNodes.components.source, {
            layer: "components"
          })
        );
        layerNodes.components.remove();
      }
      if (layerNodes.utilities) {
        layerNodes.utilities.before(
          cloneNodes([...utilityNodes], layerNodes.utilities.source, {
            layer: "utilities"
          })
        );
        layerNodes.utilities.remove();
      }
      const variantNodes = Array.from(screenNodes).filter((node) => {
        const parentLayer = node.raws.tailwind?.parentLayer;
        if (parentLayer === "components") {
          return layerNodes.components !== null;
        }
        if (parentLayer === "utilities") {
          return layerNodes.utilities !== null;
        }
        return true;
      });
      if (layerNodes.variants) {
        layerNodes.variants.before(
          cloneNodes(variantNodes, layerNodes.variants.source, {
            layer: "variants"
          })
        );
        layerNodes.variants.remove();
      } else if (variantNodes.length > 0) {
        root2.append(
          cloneNodes(variantNodes, root2.source, {
            layer: "variants"
          })
        );
      }
      const hasUtilityVariants = variantNodes.some(
        (node) => node.raws.tailwind?.parentLayer === "utilities"
      );
      if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {
        log_default.warn("content-problems", [
          "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
          "https://tailwindcss.com/docs/content-configuration"
        ]);
      }
      if (void 0) {
        console.log("Potential classes: ", candidates.size);
        console.log("Active contexts: ", contextSourcesMap.size);
      }
      context.changedContent = [];
      root2.walkAtRules("layer", (rule2) => {
        if (Object.keys(layerNodes).includes(rule2.params)) {
          rule2.remove();
        }
      });
    };
  }
  function isObject3(input) {
    return typeof input === "object" && input !== null;
  }
  function findClosestExistingPath(theme, path) {
    let parts = toPath(path);
    do {
      parts.pop();
      if ((0, import_dlv2.default)(theme, parts) !== void 0)
        break;
    } while (parts.length);
    return parts.length ? parts : void 0;
  }
  function pathToString(path) {
    if (typeof path === "string")
      return path;
    return path.reduce((acc, cur, i) => {
      if (cur.includes("."))
        return `${acc}[${cur}]`;
      return i === 0 ? cur : `${acc}.${cur}`;
    }, "");
  }
  function list2(items) {
    return items.map((key) => `'${key}'`).join(", ");
  }
  function listKeys(obj) {
    return list2(Object.keys(obj));
  }
  function validatePath(config, path, defaultValue, themeOpts = {}) {
    const pathString = Array.isArray(path) ? pathToString(path) : path.replace(/^['"]+|['"]+$/g, "");
    const pathSegments = Array.isArray(path) ? path : toPath(pathString);
    const value2 = (0, import_dlv2.default)(config.theme, pathSegments, defaultValue);
    if (value2 === void 0) {
      let error = `'${pathString}' does not exist in your theme config.`;
      const parentSegments = pathSegments.slice(0, -1);
      const parentValue = (0, import_dlv2.default)(config.theme, parentSegments);
      if (isObject3(parentValue)) {
        const validKeys = Object.keys(parentValue).filter(
          (key) => validatePath(config, [...parentSegments, key]).isValid
        );
        const suggestion = (0, import_didyoumean.default)(pathSegments[pathSegments.length - 1], validKeys);
        if (suggestion) {
          error += ` Did you mean '${pathToString([...parentSegments, suggestion])}'?`;
        } else if (validKeys.length > 0) {
          error += ` '${pathToString(parentSegments)}' has the following valid keys: ${list2(
            validKeys
          )}`;
        }
      } else {
        const closestPath = findClosestExistingPath(config.theme, pathString);
        if (closestPath) {
          const closestValue = (0, import_dlv2.default)(config.theme, closestPath);
          if (isObject3(closestValue)) {
            error += ` '${pathToString(closestPath)}' has the following keys: ${listKeys(
              closestValue
            )}`;
          } else {
            error += ` '${pathToString(closestPath)}' is not an object.`;
          }
        } else {
          error += ` Your theme has the following top-level keys: ${listKeys(config.theme)}`;
        }
      }
      return {
        isValid: false,
        error
      };
    }
    if (!(typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "function" || value2 instanceof String || value2 instanceof Number || Array.isArray(value2))) {
      let error = `'${pathString}' was found but does not resolve to a string.`;
      if (isObject3(value2)) {
        let validKeys = Object.keys(value2).filter(
          (key) => validatePath(config, [...pathSegments, key]).isValid
        );
        if (validKeys.length) {
          error += ` Did you mean something like '${pathToString([...pathSegments, validKeys[0]])}'?`;
        }
      }
      return {
        isValid: false,
        error
      };
    }
    const [themeSection] = pathSegments;
    return {
      isValid: true,
      value: transformThemeValue(themeSection)(value2, themeOpts)
    };
  }
  function extractArgs(node, vNodes, functions) {
    vNodes = vNodes.map((vNode) => resolveVNode(node, vNode, functions));
    let args = [""];
    for (let vNode of vNodes) {
      if (vNode.type === "div" && vNode.value === ",") {
        args.push("");
      } else {
        args[args.length - 1] += import_postcss_value_parser.default.stringify(vNode);
      }
    }
    return args;
  }
  function resolveVNode(node, vNode, functions) {
    if (vNode.type === "function" && functions[vNode.value] !== void 0) {
      let args = extractArgs(node, vNode.nodes, functions);
      vNode.type = "word";
      vNode.value = functions[vNode.value](node, ...args);
    }
    return vNode;
  }
  function resolveFunctions(node, input, functions) {
    return (0, import_postcss_value_parser.default)(input).walk((vNode) => {
      resolveVNode(node, vNode, functions);
    }).toString();
  }
  var nodeTypePropertyMap = {
    atrule: "params",
    decl: "value"
  };
  function* toPaths(path) {
    path = path.replace(/^['"]+|['"]+$/g, "");
    let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
    let alpha = void 0;
    yield [path, void 0];
    if (matches) {
      path = matches[1];
      alpha = matches[2];
      yield [path, alpha];
    }
  }
  function resolvePath(config, path, defaultValue) {
    const results = Array.from(toPaths(path)).map(([path2, alpha]) => {
      return Object.assign(validatePath(config, path2, defaultValue, { opacityValue: alpha }), {
        resolvedPath: path2,
        alpha
      });
    });
    return results.find((result) => result.isValid) ?? results[0];
  }
  function evaluateTailwindFunctions_default(context) {
    let config = context.tailwindConfig;
    let functions = {
      theme: (node, path, ...defaultValue) => {
        let { isValid, value: value2, error, alpha } = resolvePath(
          config,
          path,
          defaultValue.length ? defaultValue : void 0
        );
        if (!isValid) {
          let parentNode = node.parent;
          let candidate = parentNode?.raws.tailwind?.candidate;
          if (parentNode && candidate !== void 0) {
            context.markInvalidUtilityNode(parentNode);
            parentNode.remove();
            log_default.warn("invalid-theme-key-in-class", [
              `The utility \`${candidate}\` contains an invalid theme value and was not generated.`
            ]);
            return;
          }
          throw node.error(error);
        }
        let maybeColor = parseColorFormat(value2);
        let isColorFunction = maybeColor !== void 0 && typeof maybeColor === "function";
        if (alpha !== void 0 || isColorFunction) {
          if (alpha === void 0) {
            alpha = 1;
          }
          value2 = withAlphaValue(maybeColor, alpha, maybeColor);
        }
        return value2;
      },
      screen: (node, screen) => {
        screen = screen.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
        let screens = normalizeScreens(config.theme.screens);
        let screenDefinition = screens.find(({ name }) => name === screen);
        if (!screenDefinition) {
          throw node.error(`The '${screen}' screen does not exist in your theme.`);
        }
        return buildMediaQuery(screenDefinition);
      }
    };
    return (root2) => {
      root2.walk((node) => {
        let property = nodeTypePropertyMap[node.type];
        if (property === void 0) {
          return;
        }
        node[property] = resolveFunctions(node, node[property], functions);
      });
    };
  }
  function substituteScreenAtRules_default({ tailwindConfig: { theme } }) {
    return function(css) {
      css.walkAtRules("screen", (atRule2) => {
        let screen = atRule2.params;
        let screens = normalizeScreens(theme.screens);
        let screenDefinition = screens.find(({ name }) => name === screen);
        if (!screenDefinition) {
          throw atRule2.error(`No \`${screen}\` screen found.`);
        }
        atRule2.name = "media";
        atRule2.params = buildMediaQuery(screenDefinition);
      });
    };
  }
  var getNode = {
    id(node) {
      return import_postcss_selector_parser8.default.attribute({
        attribute: "id",
        operator: "=",
        value: node.value,
        quoteMark: '"'
      });
    }
  };
  function minimumImpactSelector(nodes) {
    let rest = nodes.filter((node2) => {
      if (node2.type !== "pseudo")
        return true;
      if (node2.nodes.length > 0)
        return true;
      return node2.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(node2.value);
    }).reverse();
    let searchFor = /* @__PURE__ */ new Set(["tag", "class", "id", "attribute"]);
    let splitPointIdx = rest.findIndex((n2) => searchFor.has(n2.type));
    if (splitPointIdx === -1)
      return rest.reverse().join("").trim();
    let node = rest[splitPointIdx];
    let bestNode = getNode[node.type] ? getNode[node.type](node) : node;
    rest = rest.slice(0, splitPointIdx);
    let combinatorIdx = rest.findIndex((n2) => n2.type === "combinator" && n2.value === ">");
    if (combinatorIdx !== -1) {
      rest.splice(0, combinatorIdx);
      rest.unshift(import_postcss_selector_parser8.default.universal());
    }
    return [bestNode, ...rest.reverse()].join("").trim();
  }
  var elementSelectorParser = (0, import_postcss_selector_parser8.default)((selectors) => {
    return selectors.map((s2) => {
      let nodes = s2.split((n2) => n2.type === "combinator" && n2.value === " ").pop();
      return minimumImpactSelector(nodes);
    });
  });
  var cache = /* @__PURE__ */ new Map();
  function extractElementSelector(selector) {
    if (!cache.has(selector)) {
      cache.set(selector, elementSelectorParser.transformSync(selector));
    }
    return cache.get(selector);
  }
  function resolveDefaultsAtRules({ tailwindConfig }) {
    return (root2) => {
      let variableNodeMap = /* @__PURE__ */ new Map();
      let universals = /* @__PURE__ */ new Set();
      root2.walkAtRules("defaults", (rule2) => {
        if (rule2.nodes && rule2.nodes.length > 0) {
          universals.add(rule2);
          return;
        }
        let variable = rule2.params;
        if (!variableNodeMap.has(variable)) {
          variableNodeMap.set(variable, /* @__PURE__ */ new Set());
        }
        variableNodeMap.get(variable).add(rule2.parent);
        rule2.remove();
      });
      if (flagEnabled(tailwindConfig, "optimizeUniversalDefaults")) {
        for (let universal of universals) {
          let selectorGroups = /* @__PURE__ */ new Map();
          let rules = variableNodeMap.get(universal.params) ?? [];
          for (let rule2 of rules) {
            for (let selector of extractElementSelector(rule2.selector)) {
              let selectorGroupName = selector.includes(":-") || selector.includes("::-") ? selector : "__DEFAULT__";
              let selectors = selectorGroups.get(selectorGroupName) ?? /* @__PURE__ */ new Set();
              selectorGroups.set(selectorGroupName, selectors);
              selectors.add(selector);
            }
          }
          if (flagEnabled(tailwindConfig, "optimizeUniversalDefaults")) {
            if (selectorGroups.size === 0) {
              universal.remove();
              continue;
            }
            for (let [, selectors] of selectorGroups) {
              let universalRule = postcss_default.rule({
                source: universal.source
              });
              universalRule.selectors = [...selectors];
              universalRule.append(universal.nodes.map((node) => node.clone()));
              universal.before(universalRule);
            }
          }
          universal.remove();
        }
      } else if (universals.size) {
        let universalRule = postcss_default.rule({
          selectors: ["*", "::before", "::after"]
        });
        for (let universal of universals) {
          universalRule.append(universal.nodes);
          if (!universalRule.parent) {
            universal.before(universalRule);
          }
          if (!universalRule.source) {
            universalRule.source = universal.source;
          }
          universal.remove();
        }
        let backdropRule = universalRule.clone({
          selectors: ["::backdrop"]
        });
        universalRule.after(backdropRule);
      }
    };
  }
  var comparisonMap = {
    atrule: ["name", "params"],
    rule: ["selector"]
  };
  var types = new Set(Object.keys(comparisonMap));
  function collapseAdjacentRules() {
    function collapseRulesIn(root2) {
      let currentRule = null;
      root2.each((node) => {
        if (!types.has(node.type)) {
          currentRule = null;
          return;
        }
        if (currentRule === null) {
          currentRule = node;
          return;
        }
        let properties = comparisonMap[node.type];
        if (node.type === "atrule" && node.name === "font-face") {
          currentRule = node;
        } else if (properties.every(
          (property) => (node[property] ?? "").replace(/\s+/g, " ") === (currentRule[property] ?? "").replace(/\s+/g, " ")
        )) {
          if (node.nodes) {
            currentRule.append(node.nodes);
          }
          node.remove();
        } else {
          currentRule = node;
        }
      });
      root2.each((node) => {
        if (node.type === "atrule") {
          collapseRulesIn(node);
        }
      });
    }
    return (root2) => {
      collapseRulesIn(root2);
    };
  }
  function collapseDuplicateDeclarations() {
    return (root2) => {
      root2.walkRules((node) => {
        let seen = /* @__PURE__ */ new Map();
        let droppable = /* @__PURE__ */ new Set([]);
        let byProperty = /* @__PURE__ */ new Map();
        node.walkDecls((decl2) => {
          if (decl2.parent !== node) {
            return;
          }
          if (seen.has(decl2.prop)) {
            if (seen.get(decl2.prop).value === decl2.value) {
              droppable.add(seen.get(decl2.prop));
              seen.set(decl2.prop, decl2);
              return;
            }
            if (!byProperty.has(decl2.prop)) {
              byProperty.set(decl2.prop, /* @__PURE__ */ new Set());
            }
            byProperty.get(decl2.prop).add(seen.get(decl2.prop));
            byProperty.get(decl2.prop).add(decl2);
          }
          seen.set(decl2.prop, decl2);
        });
        for (let decl2 of droppable) {
          decl2.remove();
        }
        for (let declarations of byProperty.values()) {
          let byUnit = /* @__PURE__ */ new Map();
          for (let decl2 of declarations) {
            let unit = resolveUnit(decl2.value);
            if (unit === null) {
              continue;
            }
            if (!byUnit.has(unit)) {
              byUnit.set(unit, /* @__PURE__ */ new Set());
            }
            byUnit.get(unit).add(decl2);
          }
          for (let declarations2 of byUnit.values()) {
            let removableDeclarations = Array.from(declarations2).slice(0, -1);
            for (let decl2 of removableDeclarations) {
              decl2.remove();
            }
          }
        }
      });
    };
  }
  var UNITLESS_NUMBER = Symbol("unitless-number");
  function resolveUnit(input) {
    let result = /^-?\d*.?\d+([\w%]+)?$/g.exec(input);
    if (result) {
      return result[1] ?? UNITLESS_NUMBER;
    }
    return null;
  }
  function partitionRules(root2) {
    if (!root2.walkAtRules)
      return;
    let applyParents = /* @__PURE__ */ new Set();
    root2.walkAtRules("apply", (rule2) => {
      applyParents.add(rule2.parent);
    });
    if (applyParents.size === 0) {
      return;
    }
    for (let rule2 of applyParents) {
      let nodeGroups = [];
      let lastGroup = [];
      for (let node of rule2.nodes) {
        if (node.type === "atrule" && node.name === "apply") {
          if (lastGroup.length > 0) {
            nodeGroups.push(lastGroup);
            lastGroup = [];
          }
          nodeGroups.push([node]);
        } else {
          lastGroup.push(node);
        }
      }
      if (lastGroup.length > 0) {
        nodeGroups.push(lastGroup);
      }
      if (nodeGroups.length === 1) {
        continue;
      }
      for (let group of [...nodeGroups].reverse()) {
        let clone = rule2.clone({ nodes: [] });
        clone.append(group);
        rule2.after(clone);
      }
      rule2.remove();
    }
  }
  function expandApplyAtRules2() {
    return (root2) => {
      partitionRules(root2);
    };
  }
  function isRoot(node) {
    return node.type === "root";
  }
  function isAtLayer(node) {
    return node.type === "atrule" && node.name === "layer";
  }
  function detectNesting_default(_context) {
    return (root2, result) => {
      let found = false;
      root2.walkAtRules("tailwind", (node) => {
        if (found)
          return false;
        if (node.parent && !(isRoot(node.parent) || isAtLayer(node.parent))) {
          found = true;
          node.warn(
            result,
            [
              "Nested @tailwind rules were detected, but are not supported.",
              "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix",
              "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"
            ].join("\n")
          );
          return false;
        }
      });
      root2.walkRules((rule2) => {
        if (found)
          return false;
        rule2.walkRules((nestedRule) => {
          found = true;
          nestedRule.warn(
            result,
            [
              "Nested CSS was detected, but CSS nesting has not been configured correctly.",
              "Please enable a CSS nesting plugin *before* Tailwind in your configuration.",
              "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"
            ].join("\n")
          );
          return false;
        });
      });
    };
  }
  function processTailwindFeatures(setupContext) {
    return function(root2, result) {
      let { tailwindDirectives, applyDirectives } = normalizeTailwindDirectives(root2);
      detectNesting_default()(root2, result);
      expandApplyAtRules2()(root2, result);
      let context = setupContext({
        tailwindDirectives,
        applyDirectives,
        registerDependency(dependency) {
          result.messages.push({
            plugin: "tailwindcss",
            parent: result.opts.from,
            ...dependency
          });
        },
        createContext(tailwindConfig, changedContent) {
          return createContext(tailwindConfig, changedContent, root2);
        }
      })(root2, result);
      if (context.tailwindConfig.separator === "-") {
        throw new Error(
          "The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead."
        );
      }
      issueFlagNotices(context.tailwindConfig);
      expandTailwindAtRules(context)(root2, result);
      expandApplyAtRules2()(root2, result);
      expandApplyAtRules(context)(root2, result);
      evaluateTailwindFunctions_default(context)(root2, result);
      substituteScreenAtRules_default(context)(root2, result);
      resolveDefaultsAtRules(context)(root2, result);
      collapseAdjacentRules(context)(root2, result);
      collapseDuplicateDeclarations(context)(root2, result);
    };
  }
  var corePluginList_default = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
  function configurePlugins_default(pluginConfig, plugins) {
    if (pluginConfig === void 0) {
      return plugins;
    }
    const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [
      ...new Set(
        plugins.filter((pluginName) => {
          return pluginConfig !== false && pluginConfig[pluginName] !== false;
        }).concat(
          Object.keys(pluginConfig).filter((pluginName) => {
            return pluginConfig[pluginName] !== false;
          })
        )
      )
    ];
    return pluginNames;
  }
  function warn({ version: version2, from, to }) {
    log_default.warn(`${from}-color-renamed`, [
      `As of Tailwind CSS ${version2}, \`${from}\` has been renamed to \`${to}\`.`,
      "Update your configuration file to silence this warning."
    ]);
  }
  var colors_default = {
    inherit: "inherit",
    current: "currentColor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337"
    },
    get lightBlue() {
      warn({ version: "v2.2", from: "lightBlue", to: "sky" });
      return this.sky;
    },
    get warmGray() {
      warn({ version: "v3.0", from: "warmGray", to: "stone" });
      return this.stone;
    },
    get trueGray() {
      warn({ version: "v3.0", from: "trueGray", to: "neutral" });
      return this.neutral;
    },
    get coolGray() {
      warn({ version: "v3.0", from: "coolGray", to: "gray" });
      return this.gray;
    },
    get blueGray() {
      warn({ version: "v3.0", from: "blueGray", to: "slate" });
      return this.slate;
    }
  };
  function defaults2(target, ...sources) {
    for (let source of sources) {
      for (let k2 in source) {
        if (!target?.hasOwnProperty?.(k2)) {
          target[k2] = source[k2];
        }
      }
      for (let k2 of Object.getOwnPropertySymbols(source)) {
        if (!target?.hasOwnProperty?.(k2)) {
          target[k2] = source[k2];
        }
      }
    }
    return target;
  }
  function normalizeConfig(config) {
    let valid = (() => {
      if (config.purge) {
        return false;
      }
      if (!config.content) {
        return false;
      }
      if (!Array.isArray(config.content) && !(typeof config.content === "object" && config.content !== null)) {
        return false;
      }
      if (Array.isArray(config.content)) {
        return config.content.every((path) => {
          if (typeof path === "string")
            return true;
          if (typeof path?.raw !== "string")
            return false;
          if (path?.extension && typeof path?.extension !== "string") {
            return false;
          }
          return true;
        });
      }
      if (typeof config.content === "object" && config.content !== null) {
        if (Object.keys(config.content).some(
          (key) => !["files", "relative", "extract", "transform"].includes(key)
        )) {
          return false;
        }
        if (Array.isArray(config.content.files)) {
          if (!config.content.files.every((path) => {
            if (typeof path === "string")
              return true;
            if (typeof path?.raw !== "string")
              return false;
            if (path?.extension && typeof path?.extension !== "string") {
              return false;
            }
            return true;
          })) {
            return false;
          }
          if (typeof config.content.extract === "object") {
            for (let value2 of Object.values(config.content.extract)) {
              if (typeof value2 !== "function") {
                return false;
              }
            }
          } else if (!(config.content.extract === void 0 || typeof config.content.extract === "function")) {
            return false;
          }
          if (typeof config.content.transform === "object") {
            for (let value2 of Object.values(config.content.transform)) {
              if (typeof value2 !== "function") {
                return false;
              }
            }
          } else if (!(config.content.transform === void 0 || typeof config.content.transform === "function")) {
            return false;
          }
          if (typeof config.content.relative !== "boolean" && typeof config.content.relative !== "undefined") {
            return false;
          }
        }
        return true;
      }
      return false;
    })();
    if (!valid) {
      log_default.warn("purge-deprecation", [
        "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
        "Update your configuration file to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
      ]);
    }
    config.safelist = (() => {
      let { content, purge, safelist } = config;
      if (Array.isArray(safelist))
        return safelist;
      if (Array.isArray(content?.safelist))
        return content.safelist;
      if (Array.isArray(purge?.safelist))
        return purge.safelist;
      if (Array.isArray(purge?.options?.safelist))
        return purge.options.safelist;
      return [];
    })();
    config.blocklist = (() => {
      let { blocklist } = config;
      if (Array.isArray(blocklist)) {
        if (blocklist.every((item) => typeof item === "string")) {
          return blocklist;
        }
        log_default.warn("blocklist-invalid", [
          "The `blocklist` option must be an array of strings.",
          "https://tailwindcss.com/docs/content-configuration#discarding-classes"
        ]);
      }
      return [];
    })();
    if (typeof config.prefix === "function") {
      log_default.warn("prefix-function", [
        "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
        "Update `prefix` in your configuration to be a string to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
      ]);
      config.prefix = "";
    } else {
      config.prefix = config.prefix ?? "";
    }
    config.content = {
      relative: (() => {
        let { content } = config;
        if (content?.relative) {
          return content.relative;
        }
        return config.future?.relativeContentPathsByDefault ?? false;
      })(),
      files: (() => {
        let { content, purge } = config;
        if (Array.isArray(purge))
          return purge;
        if (Array.isArray(purge?.content))
          return purge.content;
        if (Array.isArray(content))
          return content;
        if (Array.isArray(content?.content))
          return content.content;
        if (Array.isArray(content?.files))
          return content.files;
        return [];
      })(),
      extract: (() => {
        let extract = (() => {
          if (config.purge?.extract)
            return config.purge.extract;
          if (config.content?.extract)
            return config.content.extract;
          if (config.purge?.extract?.DEFAULT)
            return config.purge.extract.DEFAULT;
          if (config.content?.extract?.DEFAULT)
            return config.content.extract.DEFAULT;
          if (config.purge?.options?.extractors)
            return config.purge.options.extractors;
          if (config.content?.options?.extractors)
            return config.content.options.extractors;
          return {};
        })();
        let extractors = {};
        let defaultExtractor2 = (() => {
          if (config.purge?.options?.defaultExtractor) {
            return config.purge.options.defaultExtractor;
          }
          if (config.content?.options?.defaultExtractor) {
            return config.content.options.defaultExtractor;
          }
          return void 0;
        })();
        if (defaultExtractor2 !== void 0) {
          extractors.DEFAULT = defaultExtractor2;
        }
        if (typeof extract === "function") {
          extractors.DEFAULT = extract;
        } else if (Array.isArray(extract)) {
          for (let { extensions, extractor } of extract ?? []) {
            for (let extension of extensions) {
              extractors[extension] = extractor;
            }
          }
        } else if (typeof extract === "object" && extract !== null) {
          Object.assign(extractors, extract);
        }
        return extractors;
      })(),
      transform: (() => {
        let transform = (() => {
          if (config.purge?.transform)
            return config.purge.transform;
          if (config.content?.transform)
            return config.content.transform;
          if (config.purge?.transform?.DEFAULT)
            return config.purge.transform.DEFAULT;
          if (config.content?.transform?.DEFAULT)
            return config.content.transform.DEFAULT;
          return {};
        })();
        let transformers = {};
        if (typeof transform === "function") {
          transformers.DEFAULT = transform;
        }
        if (typeof transform === "object" && transform !== null) {
          Object.assign(transformers, transform);
        }
        return transformers;
      })()
    };
    for (let file of config.content.files) {
      if (typeof file === "string" && /{([^,]*?)}/g.test(file)) {
        log_default.warn("invalid-glob-braces", [
          `The glob pattern ${dim(file)} in your Tailwind CSS configuration is invalid.`,
          `Update it to ${dim(file.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
          // TODO: Add https://tw.wtf/invalid-glob-braces
        ]);
        break;
      }
    }
    return config;
  }
  function cloneDeep(value2) {
    if (Array.isArray(value2)) {
      return value2.map((child) => cloneDeep(child));
    }
    if (typeof value2 === "object" && value2 !== null) {
      return Object.fromEntries(Object.entries(value2).map(([k2, v]) => [k2, cloneDeep(v)]));
    }
    return value2;
  }
  function isFunction(input) {
    return typeof input === "function";
  }
  function mergeWith(target, ...sources) {
    let customizer = sources.pop();
    for (let source of sources) {
      for (let k2 in source) {
        let merged = customizer(target[k2], source[k2]);
        if (merged === void 0) {
          if (isPlainObject(target[k2]) && isPlainObject(source[k2])) {
            target[k2] = mergeWith({}, target[k2], source[k2], customizer);
          } else {
            target[k2] = source[k2];
          }
        } else {
          target[k2] = merged;
        }
      }
    }
    return target;
  }
  var configUtils = {
    colors: colors_default,
    negative(scale) {
      return Object.keys(scale).filter((key) => scale[key] !== "0").reduce((negativeScale, key) => {
        let negativeValue = negateValue(scale[key]);
        if (negativeValue !== void 0) {
          negativeScale[`-${key}`] = negativeValue;
        }
        return negativeScale;
      }, {});
    },
    breakpoints(screens) {
      return Object.keys(screens).filter((key) => typeof screens[key] === "string").reduce(
        (breakpoints, key) => ({
          ...breakpoints,
          [`screen-${key}`]: screens[key]
        }),
        {}
      );
    }
  };
  function value(valueToResolve, ...args) {
    return isFunction(valueToResolve) ? valueToResolve(...args) : valueToResolve;
  }
  function collectExtends(items) {
    return items.reduce((merged, { extend }) => {
      return mergeWith(merged, extend, (mergedValue, extendValue) => {
        if (mergedValue === void 0) {
          return [extendValue];
        }
        if (Array.isArray(mergedValue)) {
          return [extendValue, ...mergedValue];
        }
        return [extendValue, mergedValue];
      });
    }, {});
  }
  function mergeThemes(themes) {
    return {
      ...themes.reduce((merged, theme) => defaults2(merged, theme), {}),
      // In order to resolve n config objects, we combine all of their `extend` properties
      // into arrays instead of objects so they aren't overridden.
      extend: collectExtends(themes)
    };
  }
  function mergeExtensionCustomizer(merged, value2) {
    if (Array.isArray(merged) && isPlainObject(merged[0])) {
      return merged.concat(value2);
    }
    if (Array.isArray(value2) && isPlainObject(value2[0]) && isPlainObject(merged)) {
      return [merged, ...value2];
    }
    if (Array.isArray(value2)) {
      return value2;
    }
    return void 0;
  }
  function mergeExtensions({ extend, ...theme }) {
    return mergeWith(theme, extend, (themeValue, extensions) => {
      if (!isFunction(themeValue) && !extensions.some(isFunction)) {
        return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);
      }
      return (resolveThemePath, utils) => mergeWith(
        {},
        ...[themeValue, ...extensions].map((e2) => value(e2, resolveThemePath, utils)),
        mergeExtensionCustomizer
      );
    });
  }
  function* toPaths2(key) {
    let path = toPath(key);
    if (path.length === 0) {
      return;
    }
    yield path;
    if (Array.isArray(key)) {
      return;
    }
    let pattern2 = /^(.*?)\s*\/\s*([^/]+)$/;
    let matches = key.match(pattern2);
    if (matches !== null) {
      let [, prefix3, alpha] = matches;
      let newPath = toPath(prefix3);
      newPath.alpha = alpha;
      yield newPath;
    }
  }
  function resolveFunctionKeys(object) {
    const resolvePath2 = (key, defaultValue) => {
      for (const path of toPaths2(key)) {
        let index2 = 0;
        let val = object;
        while (val !== void 0 && val !== null && index2 < path.length) {
          val = val[path[index2++]];
          let shouldResolveAsFn = isFunction(val) && (path.alpha === void 0 || index2 <= path.length - 1);
          val = shouldResolveAsFn ? val(resolvePath2, configUtils) : val;
        }
        if (val !== void 0) {
          if (path.alpha !== void 0) {
            let normalized = parseColorFormat(val);
            return withAlphaValue(normalized, path.alpha, toColorValue(normalized));
          }
          if (isPlainObject(val)) {
            return cloneDeep(val);
          }
          return val;
        }
      }
      return defaultValue;
    };
    Object.assign(resolvePath2, {
      theme: resolvePath2,
      ...configUtils
    });
    return Object.keys(object).reduce((resolved, key) => {
      resolved[key] = isFunction(object[key]) ? object[key](resolvePath2, configUtils) : object[key];
      return resolved;
    }, {});
  }
  function extractPluginConfigs(configs) {
    let allConfigs = [];
    configs.forEach((config) => {
      allConfigs = [...allConfigs, config];
      const plugins = config?.plugins ?? [];
      if (plugins.length === 0) {
        return;
      }
      plugins.forEach((plugin2) => {
        if (plugin2.__isOptionsFunction) {
          plugin2 = plugin2();
        }
        allConfigs = [...allConfigs, ...extractPluginConfigs([plugin2?.config ?? {}])];
      });
    });
    return allConfigs;
  }
  function resolveCorePlugins(corePluginConfigs) {
    const result = [...corePluginConfigs].reduceRight((resolved, corePluginConfig) => {
      if (isFunction(corePluginConfig)) {
        return corePluginConfig({ corePlugins: resolved });
      }
      return configurePlugins_default(corePluginConfig, resolved);
    }, corePluginList_default);
    return result;
  }
  function resolvePluginLists(pluginLists) {
    const result = [...pluginLists].reduceRight((resolved, pluginList) => {
      return [...resolved, ...pluginList];
    }, []);
    return result;
  }
  function resolveConfig(configs) {
    let allConfigs = [
      ...extractPluginConfigs(configs),
      {
        prefix: "",
        important: false,
        separator: ":"
      }
    ];
    return normalizeConfig(
      defaults2(
        {
          theme: resolveFunctionKeys(
            mergeExtensions(mergeThemes(allConfigs.map((t) => t?.theme ?? {})))
          ),
          corePlugins: resolveCorePlugins(allConfigs.map((c4) => c4.corePlugins)),
          plugins: resolvePluginLists(configs.map((c4) => c4?.plugins ?? []))
        },
        ...allConfigs
      )
    );
  }
  var defaultConfig_stub_default = {
    content: [],
    presets: [],
    darkMode: "media",
    // or 'class'
    theme: {
      accentColor: ({ theme }) => ({
        ...theme("colors"),
        auto: "auto"
      }),
      animation: {
        none: "none",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite"
      },
      aria: {
        checked: 'checked="true"',
        disabled: 'disabled="true"',
        expanded: 'expanded="true"',
        hidden: 'hidden="true"',
        pressed: 'pressed="true"',
        readonly: 'readonly="true"',
        required: 'required="true"',
        selected: 'selected="true"'
      },
      aspectRatio: {
        auto: "auto",
        square: "1 / 1",
        video: "16 / 9"
      },
      backdropBlur: ({ theme }) => theme("blur"),
      backdropBrightness: ({ theme }) => theme("brightness"),
      backdropContrast: ({ theme }) => theme("contrast"),
      backdropGrayscale: ({ theme }) => theme("grayscale"),
      backdropHueRotate: ({ theme }) => theme("hueRotate"),
      backdropInvert: ({ theme }) => theme("invert"),
      backdropOpacity: ({ theme }) => theme("opacity"),
      backdropSaturate: ({ theme }) => theme("saturate"),
      backdropSepia: ({ theme }) => theme("sepia"),
      backgroundColor: ({ theme }) => theme("colors"),
      backgroundImage: {
        none: "none",
        "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
        "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
        "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
        "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
        "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
        "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
        "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
        "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
      },
      backgroundOpacity: ({ theme }) => theme("opacity"),
      backgroundPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
      },
      backgroundSize: {
        auto: "auto",
        cover: "cover",
        contain: "contain"
      },
      blur: {
        0: "0",
        none: "0",
        sm: "4px",
        DEFAULT: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
      },
      borderColor: ({ theme }) => ({
        ...theme("colors"),
        DEFAULT: theme("colors.gray.200", "currentColor")
      }),
      borderOpacity: ({ theme }) => theme("opacity"),
      borderRadius: {
        none: "0px",
        sm: "0.125rem",
        DEFAULT: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
      },
      borderSpacing: ({ theme }) => ({
        ...theme("spacing")
      }),
      borderWidth: {
        DEFAULT: "1px",
        0: "0px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      boxShadow: {
        sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
        DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        none: "none"
      },
      boxShadowColor: ({ theme }) => theme("colors"),
      brightness: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        200: "2"
      },
      caretColor: ({ theme }) => theme("colors"),
      colors: ({ colors }) => ({
        inherit: colors.inherit,
        current: colors.current,
        transparent: colors.transparent,
        black: colors.black,
        white: colors.white,
        slate: colors.slate,
        gray: colors.gray,
        zinc: colors.zinc,
        neutral: colors.neutral,
        stone: colors.stone,
        red: colors.red,
        orange: colors.orange,
        amber: colors.amber,
        yellow: colors.yellow,
        lime: colors.lime,
        green: colors.green,
        emerald: colors.emerald,
        teal: colors.teal,
        cyan: colors.cyan,
        sky: colors.sky,
        blue: colors.blue,
        indigo: colors.indigo,
        violet: colors.violet,
        purple: colors.purple,
        fuchsia: colors.fuchsia,
        pink: colors.pink,
        rose: colors.rose
      }),
      columns: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        "3xs": "16rem",
        "2xs": "18rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem"
      },
      container: {},
      content: {
        none: "none"
      },
      contrast: {
        0: "0",
        50: ".5",
        75: ".75",
        100: "1",
        125: "1.25",
        150: "1.5",
        200: "2"
      },
      cursor: {
        auto: "auto",
        default: "default",
        pointer: "pointer",
        wait: "wait",
        text: "text",
        move: "move",
        help: "help",
        "not-allowed": "not-allowed",
        none: "none",
        "context-menu": "context-menu",
        progress: "progress",
        cell: "cell",
        crosshair: "crosshair",
        "vertical-text": "vertical-text",
        alias: "alias",
        copy: "copy",
        "no-drop": "no-drop",
        grab: "grab",
        grabbing: "grabbing",
        "all-scroll": "all-scroll",
        "col-resize": "col-resize",
        "row-resize": "row-resize",
        "n-resize": "n-resize",
        "e-resize": "e-resize",
        "s-resize": "s-resize",
        "w-resize": "w-resize",
        "ne-resize": "ne-resize",
        "nw-resize": "nw-resize",
        "se-resize": "se-resize",
        "sw-resize": "sw-resize",
        "ew-resize": "ew-resize",
        "ns-resize": "ns-resize",
        "nesw-resize": "nesw-resize",
        "nwse-resize": "nwse-resize",
        "zoom-in": "zoom-in",
        "zoom-out": "zoom-out"
      },
      divideColor: ({ theme }) => theme("borderColor"),
      divideOpacity: ({ theme }) => theme("borderOpacity"),
      divideWidth: ({ theme }) => theme("borderWidth"),
      dropShadow: {
        sm: "0 1px 1px rgb(0 0 0 / 0.05)",
        DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
        md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
        lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
        xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
        "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
        none: "0 0 #0000"
      },
      fill: ({ theme }) => ({
        none: "none",
        ...theme("colors")
      }),
      flex: {
        1: "1 1 0%",
        auto: "1 1 auto",
        initial: "0 1 auto",
        none: "none"
      },
      flexBasis: ({ theme }) => ({
        auto: "auto",
        ...theme("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%"
      }),
      flexGrow: {
        0: "0",
        DEFAULT: "1"
      },
      flexShrink: {
        0: "0",
        DEFAULT: "1"
      },
      fontFamily: {
        sans: [
          "ui-sans-serif",
          "system-ui",
          "-apple-system",
          "BlinkMacSystemFont",
          '"Segoe UI"',
          "Roboto",
          '"Helvetica Neue"',
          "Arial",
          '"Noto Sans"',
          "sans-serif",
          '"Apple Color Emoji"',
          '"Segoe UI Emoji"',
          '"Segoe UI Symbol"',
          '"Noto Color Emoji"'
        ],
        serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
        mono: [
          "ui-monospace",
          "SFMono-Regular",
          "Menlo",
          "Monaco",
          "Consolas",
          '"Liberation Mono"',
          '"Courier New"',
          "monospace"
        ]
      },
      fontSize: {
        xs: ["0.75rem", { lineHeight: "1rem" }],
        sm: ["0.875rem", { lineHeight: "1.25rem" }],
        base: ["1rem", { lineHeight: "1.5rem" }],
        lg: ["1.125rem", { lineHeight: "1.75rem" }],
        xl: ["1.25rem", { lineHeight: "1.75rem" }],
        "2xl": ["1.5rem", { lineHeight: "2rem" }],
        "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
        "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
        "5xl": ["3rem", { lineHeight: "1" }],
        "6xl": ["3.75rem", { lineHeight: "1" }],
        "7xl": ["4.5rem", { lineHeight: "1" }],
        "8xl": ["6rem", { lineHeight: "1" }],
        "9xl": ["8rem", { lineHeight: "1" }]
      },
      fontWeight: {
        thin: "100",
        extralight: "200",
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
        black: "900"
      },
      gap: ({ theme }) => theme("spacing"),
      gradientColorStops: ({ theme }) => theme("colors"),
      grayscale: {
        0: "0",
        DEFAULT: "100%"
      },
      gridAutoColumns: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
      },
      gridAutoRows: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
      },
      gridColumn: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
      },
      gridColumnEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridColumnStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridRow: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-full": "1 / -1"
      },
      gridRowEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7"
      },
      gridRowStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7"
      },
      gridTemplateColumns: {
        none: "none",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))"
      },
      gridTemplateRows: {
        none: "none",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))"
      },
      height: ({ theme }) => ({
        auto: "auto",
        ...theme("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        full: "100%",
        screen: "100vh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      hueRotate: {
        0: "0deg",
        15: "15deg",
        30: "30deg",
        60: "60deg",
        90: "90deg",
        180: "180deg"
      },
      inset: ({ theme }) => ({
        auto: "auto",
        ...theme("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        full: "100%"
      }),
      invert: {
        0: "0",
        DEFAULT: "100%"
      },
      keyframes: {
        spin: {
          to: {
            transform: "rotate(360deg)"
          }
        },
        ping: {
          "75%, 100%": {
            transform: "scale(2)",
            opacity: "0"
          }
        },
        pulse: {
          "50%": {
            opacity: ".5"
          }
        },
        bounce: {
          "0%, 100%": {
            transform: "translateY(-25%)",
            animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
          },
          "50%": {
            transform: "none",
            animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
          }
        }
      },
      letterSpacing: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0em",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
      },
      lineHeight: {
        none: "1",
        tight: "1.25",
        snug: "1.375",
        normal: "1.5",
        relaxed: "1.625",
        loose: "2",
        3: ".75rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem"
      },
      listStyleType: {
        none: "none",
        disc: "disc",
        decimal: "decimal"
      },
      margin: ({ theme }) => ({
        auto: "auto",
        ...theme("spacing")
      }),
      maxHeight: ({ theme }) => ({
        ...theme("spacing"),
        none: "none",
        full: "100%",
        screen: "100vh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      maxWidth: ({ theme, breakpoints }) => ({
        none: "none",
        0: "0rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content",
        prose: "65ch",
        ...breakpoints(theme("screens"))
      }),
      minHeight: {
        0: "0px",
        full: "100%",
        screen: "100vh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      },
      minWidth: {
        0: "0px",
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      },
      objectPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
      },
      opacity: {
        0: "0",
        5: "0.05",
        10: "0.1",
        20: "0.2",
        25: "0.25",
        30: "0.3",
        40: "0.4",
        50: "0.5",
        60: "0.6",
        70: "0.7",
        75: "0.75",
        80: "0.8",
        90: "0.9",
        95: "0.95",
        100: "1"
      },
      order: {
        first: "-9999",
        last: "9999",
        none: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12"
      },
      outlineColor: ({ theme }) => theme("colors"),
      outlineOffset: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      outlineWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      padding: ({ theme }) => theme("spacing"),
      placeholderColor: ({ theme }) => theme("colors"),
      placeholderOpacity: ({ theme }) => theme("opacity"),
      ringColor: ({ theme }) => ({
        DEFAULT: theme("colors.blue.500", "#3b82f6"),
        ...theme("colors")
      }),
      ringOffsetColor: ({ theme }) => theme("colors"),
      ringOffsetWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      ringOpacity: ({ theme }) => ({
        DEFAULT: "0.5",
        ...theme("opacity")
      }),
      ringWidth: {
        DEFAULT: "3px",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      rotate: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        45: "45deg",
        90: "90deg",
        180: "180deg"
      },
      saturate: {
        0: "0",
        50: ".5",
        100: "1",
        150: "1.5",
        200: "2"
      },
      scale: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5"
      },
      screens: {
        sm: "640px",
        md: "768px",
        lg: "1024px",
        xl: "1280px",
        "2xl": "1536px"
      },
      scrollMargin: ({ theme }) => ({
        ...theme("spacing")
      }),
      scrollPadding: ({ theme }) => theme("spacing"),
      sepia: {
        0: "0",
        DEFAULT: "100%"
      },
      skew: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg"
      },
      space: ({ theme }) => ({
        ...theme("spacing")
      }),
      spacing: {
        px: "1px",
        0: "0px",
        0.5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        11: "2.75rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
      },
      stroke: ({ theme }) => ({
        none: "none",
        ...theme("colors")
      }),
      strokeWidth: {
        0: "0",
        1: "1",
        2: "2"
      },
      supports: {},
      data: {},
      textColor: ({ theme }) => theme("colors"),
      textDecorationColor: ({ theme }) => theme("colors"),
      textDecorationThickness: {
        auto: "auto",
        "from-font": "from-font",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      textIndent: ({ theme }) => ({
        ...theme("spacing")
      }),
      textOpacity: ({ theme }) => theme("opacity"),
      textUnderlineOffset: {
        auto: "auto",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      transformOrigin: {
        center: "center",
        top: "top",
        "top-right": "top right",
        right: "right",
        "bottom-right": "bottom right",
        bottom: "bottom",
        "bottom-left": "bottom left",
        left: "left",
        "top-left": "top left"
      },
      transitionDelay: {
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms"
      },
      transitionDuration: {
        DEFAULT: "150ms",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms"
      },
      transitionProperty: {
        none: "none",
        all: "all",
        DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
        colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
        opacity: "opacity",
        shadow: "box-shadow",
        transform: "transform"
      },
      transitionTimingFunction: {
        DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
        linear: "linear",
        in: "cubic-bezier(0.4, 0, 1, 1)",
        out: "cubic-bezier(0, 0, 0.2, 1)",
        "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
      },
      translate: ({ theme }) => ({
        ...theme("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        full: "100%"
      }),
      width: ({ theme }) => ({
        auto: "auto",
        ...theme("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%",
        screen: "100vw",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      willChange: {
        auto: "auto",
        scroll: "scroll-position",
        contents: "contents",
        transform: "transform"
      },
      zIndex: {
        auto: "auto",
        0: "0",
        10: "10",
        20: "20",
        30: "30",
        40: "40",
        50: "50"
      }
    },
    plugins: []
  };
  function getAllConfigs(config) {
    const configs = (config?.presets ?? [defaultConfig_stub_default]).slice().reverse().flatMap((preset) => getAllConfigs(preset instanceof Function ? preset() : preset));
    const features = {
      // Add experimental configs here...
      respectDefaultRingColorOpacity: {
        theme: {
          ringColor: ({ theme }) => ({
            DEFAULT: "#3b82f67f",
            ...theme("colors")
          })
        }
      },
      disableColorOpacityUtilitiesByDefault: {
        corePlugins: {
          backgroundOpacity: false,
          borderOpacity: false,
          divideOpacity: false,
          placeholderOpacity: false,
          ringOpacity: false,
          textOpacity: false
        }
      }
    };
    const experimentals = Object.keys(features).filter((feature) => flagEnabled(config, feature)).map((feature) => features[feature]);
    return [config, ...experimentals, ...configs];
  }
  function resolveConfig2(...configs) {
    let [, ...defaultConfigs] = getAllConfigs(configs[0]);
    return resolveConfig([...configs, ...defaultConfigs]);
  }
  var parseNumber = function(color2, len) {
    if (typeof color2 !== "number") {
      return;
    }
    if (len === 3) {
      return {
        mode: "rgb",
        r: (color2 >> 8 & 15 | color2 >> 4 & 240) / 255,
        g: (color2 >> 4 & 15 | color2 & 240) / 255,
        b: (color2 & 15 | color2 << 4 & 240) / 255
      };
    }
    if (len === 4) {
      return {
        mode: "rgb",
        r: (color2 >> 12 & 15 | color2 >> 8 & 240) / 255,
        g: (color2 >> 8 & 15 | color2 >> 4 & 240) / 255,
        b: (color2 >> 4 & 15 | color2 & 240) / 255,
        alpha: (color2 & 15 | color2 << 4 & 240) / 255
      };
    }
    if (len === 6) {
      return {
        mode: "rgb",
        r: (color2 >> 16 & 255) / 255,
        g: (color2 >> 8 & 255) / 255,
        b: (color2 & 255) / 255
      };
    }
    if (len === 8) {
      return {
        mode: "rgb",
        r: (color2 >> 24 & 255) / 255,
        g: (color2 >> 16 & 255) / 255,
        b: (color2 >> 8 & 255) / 255,
        alpha: (color2 & 255) / 255
      };
    }
  };
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    // Added in CSS Colors Level 4:
    // https://drafts.csswg.org/css-color/#changes-from-3
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  var parseNamed = function(color2) {
    return parseNumber(named[color2.toLowerCase()], 6);
  };
  var num = "/([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)/".replace(/^\/|\/$/g, "");
  var per = num + "%";
  var num_per = "(?:" + num + "%|" + num + ")";
  var hue$2 = "(?:" + num + "(deg|grad|rad|turn)|" + num + ")";
  var c = "\\s*,\\s*";
  var so = "\\s*";
  var s = "\\s+";
  var rgb_num_old = new RegExp(
    "^rgba?\\(\\s*" + num + c + num + c + num + "\\s*(?:,\\s*" + num_per + "\\s*)?\\)$"
  );
  var rgb_per_old = new RegExp(
    "^rgba?\\(\\s*" + per + c + per + c + per + "\\s*(?:,\\s*" + num_per + "\\s*)?\\)$"
  );
  var rgb_num_new = new RegExp(
    "^rgba?\\(\\s*" + num + s + num + s + num + "\\s*(?:\\/\\s*" + num_per + "\\s*)?\\)$"
  );
  var rgb_per_new = new RegExp(
    "^rgba?\\(\\s*" + per + s + per + s + per + "\\s*(?:\\/\\s*" + num_per + "\\s*)?\\)$"
  );
  var hsl_old = new RegExp(
    "^hsla?\\(\\s*" + hue$2 + c + per + c + per + "\\s*(?:,\\s*" + num_per + "\\s*)?\\)$"
  );
  var hsl_new = new RegExp(
    "^hsla?\\(\\s*" + hue$2 + s + per + s + per + "\\s*(?:\\/\\s*" + num_per + "\\s*)?\\)$"
  );
  var hex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
  var hwb$1 = new RegExp(
    "^hwb\\(\\s*" + hue$2 + s + per + s + per + "\\s*(?:\\/\\s*" + num_per + "\\s*)?\\)$"
  );
  var lab$1 = new RegExp(
    "^lab\\(\\s*" + num + "%?" + s + num + s + num + "\\s*(?:\\/\\s*" + num_per + "\\s*)?\\)$"
  );
  var lch$1 = new RegExp(
    "^lch\\(\\s*" + num + "%?" + s + num + s + hue$2 + "\\s*(?:\\/\\s*" + num_per + "\\s*)?\\)$"
  );
  var profiled = new RegExp(
    "^color\\(" + so + "([a-z0-9\\-]+)" + s + num_per + s + num_per + s + num_per + so + "(?:\\/" + so + num_per + so + ")?\\)$"
  );
  var parseHex = function(color2) {
    var match;
    return (match = color2.match(hex)) ? parseNumber(parseInt(match[1], 16), match[1].length) : void 0;
  };
  var parseRgb = function(color2) {
    var match, res;
    if (match = color2.match(rgb_num_old) || color2.match(rgb_num_new)) {
      res = {
        mode: "rgb",
        r: match[1] / 255,
        g: match[2] / 255,
        b: match[3] / 255
      };
    } else if (match = color2.match(rgb_per_old) || color2.match(rgb_per_new)) {
      res = {
        mode: "rgb",
        r: match[1] / 100,
        g: match[2] / 100,
        b: match[3] / 100
      };
    } else {
      return void 0;
    }
    if (match[4] !== void 0) {
      res.alpha = match[4] / 100;
    } else if (match[5] !== void 0) {
      res.alpha = +match[5];
    }
    return res;
  };
  var parseTransparent = function(c4) {
    return c4 === "transparent" ? parseNumber(0, 8) : void 0;
  };
  var lerp$1 = function(a, b, t) {
    return a + t * (b - a);
  };
  var get_classes = function(arr) {
    var classes = [];
    for (var i = 0; i < arr.length - 1; i++) {
      var a = arr[i];
      var b = arr[i + 1];
      if (a === void 0 && b === void 0) {
        classes.push(void 0);
      } else if (a !== void 0 && b !== void 0) {
        classes.push([a, b]);
      } else {
        classes.push(a !== void 0 ? [a, a] : [b, b]);
      }
    }
    return classes;
  };
  var interpolatorPiecewise = function(interpolator) {
    return function(arr) {
      var classes = get_classes(arr);
      return function(t) {
        var cls = t * classes.length;
        var idx = t >= 1 ? classes.length - 1 : Math.max(Math.floor(cls), 0);
        var pair = classes[idx];
        return pair === void 0 ? void 0 : interpolator(pair[0], pair[1], cls - idx);
      };
    };
  };
  var interpolatorLinear = interpolatorPiecewise(lerp$1);
  var fixupAlpha = function(arr) {
    var some_defined = false;
    var res = arr.map(function(v) {
      if (v !== void 0) {
        some_defined = true;
        return v;
      }
      return 1;
    });
    return some_defined ? res : arr;
  };
  var definition$p = {
    mode: "rgb",
    channels: ["r", "g", "b", "alpha"],
    parsers: [parseHex, parseRgb, parseNamed, parseTransparent, "srgb"],
    serialize: "color(srgb ",
    interpolate: {
      r: interpolatorLinear,
      g: interpolatorLinear,
      b: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var fn$3 = function(c4) {
    var abs = Math.abs(c4);
    if (abs < 0.04045) {
      return c4 / 12.92;
    }
    return (Math.sign(c4) || 1) * Math.pow((abs + 0.055) / 1.055, 2.4);
  };
  var convertRgbToLrgb = function(ref) {
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    var res = {
      mode: "lrgb",
      r: fn$3(r2),
      g: fn$3(g),
      b: fn$3(b)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var fn$2 = function(c4) {
    var abs = Math.abs(c4);
    if (abs > 31308e-7) {
      return (Math.sign(c4) || 1) * (1.055 * Math.pow(abs, 1 / 2.4) - 0.055);
    }
    return c4 * 12.92;
  };
  var convertLrgbToRgb = function(ref, mode) {
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    if (mode === void 0)
      mode = "rgb";
    var res = {
      mode,
      r: fn$2(r2),
      g: fn$2(g),
      b: fn$2(b)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var definition$o = Object.assign(
    {},
    definition$p,
    {
      mode: "lrgb",
      output: {
        rgb: convertLrgbToRgb
      },
      input: {
        rgb: convertRgbToLrgb
      },
      parsers: ["--srgb-linear"],
      serialize: "color(--srgb-linear "
    }
  );
  var linearize$2 = function(v) {
    return Math.pow(Math.abs(v), 563 / 256) * Math.sign(v);
  };
  var convertA98ToXyz65 = function(a982) {
    var r2 = linearize$2(a982.r);
    var g = linearize$2(a982.g);
    var b = linearize$2(a982.b);
    var res = {
      mode: "xyz65",
      x: 0.5766690429101305 * r2 + 0.1855582379065463 * g + 0.1882286462349947 * b,
      y: 0.29734497525053605 * r2 + 0.6273635662554661 * g + 0.07529145849399788 * b,
      z: 0.02703136138641234 * r2 + 0.07068885253582723 * g + 0.9913375368376388 * b
    };
    if (a982.alpha !== void 0) {
      res.alpha = a982.alpha;
    }
    return res;
  };
  var gamma$2 = function(v) {
    return Math.pow(Math.abs(v), 256 / 563) * Math.sign(v);
  };
  var convertXyz65ToA98 = function(ref) {
    var x = ref.x;
    var y = ref.y;
    var z = ref.z;
    var alpha = ref.alpha;
    var res = {
      mode: "a98",
      r: gamma$2(
        x * 2.0415879038107465 - y * 0.5650069742788596 - 0.34473135077832956 * z
      ),
      g: gamma$2(
        x * -0.9692436362808795 + y * 1.8759675015077202 + 0.04155505740717557 * z
      ),
      b: gamma$2(
        x * 0.013444280632031142 - y * 0.11836239223101838 + 1.0151749943912054 * z
      )
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertRgbToXyz65 = function(rgb2) {
    var ref = convertRgbToLrgb(rgb2);
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    var res = {
      mode: "xyz65",
      x: 0.4124564 * r2 + 0.3575761 * g + 0.1804375 * b,
      y: 0.2126729 * r2 + 0.7151522 * g + 0.072175 * b,
      z: 0.0193339 * r2 + 0.119192 * g + 0.9503041 * b
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz65ToRgb = function(ref) {
    var x = ref.x;
    var y = ref.y;
    var z = ref.z;
    var alpha = ref.alpha;
    var res = convertLrgbToRgb({
      r: x * 3.2404542 - y * 1.5371385 - 0.4985314 * z,
      g: x * -0.969266 + y * 1.8760108 + 0.041556 * z,
      b: x * 0.0556434 - y * 0.2040259 + 1.0572252 * z
    });
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var definition$n = Object.assign(
    {},
    definition$p,
    {
      mode: "a98",
      parsers: ["a98-rgb"],
      serialize: "color(a98-rgb ",
      input: {
        rgb: function(color2) {
          return convertXyz65ToA98(convertRgbToXyz65(color2));
        },
        xyz65: convertXyz65ToA98
      },
      output: {
        rgb: function(color2) {
          return convertXyz65ToRgb(convertA98ToXyz65(color2));
        },
        xyz65: convertA98ToXyz65
      }
    }
  );
  var convertP3ToXyz65 = function(rgb2) {
    var ref = convertRgbToLrgb(rgb2);
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    var res = {
      mode: "xyz65",
      x: 0.4865709 * r2 + 0.2656676 * g + 0.1982172 * b,
      y: 0.2289745 * r2 + 0.6917385 * g + 0.0792869 * b,
      z: 0 * r2 + 0.0451133 * g + 1.0439443 * b
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyz65ToP3 = function(ref) {
    var x = ref.x;
    var y = ref.y;
    var z = ref.z;
    var alpha = ref.alpha;
    var res = convertLrgbToRgb(
      {
        r: x * 2.4934969 - y * 0.9313836 - 0.4027107 * z,
        g: x * -0.8294889 + y * 1.762664 + 0.0236246 * z,
        b: x * 0.0358458 - y * 0.0761723 + 0.9568845 * z
      },
      "p3"
    );
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var definition$m = Object.assign(
    {},
    definition$p,
    {
      mode: "p3",
      parsers: ["display-p3"],
      serialize: "color(display-p3 ",
      input: {
        rgb: function(color2) {
          return convertXyz65ToP3(convertRgbToXyz65(color2));
        },
        xyz65: convertXyz65ToP3
      },
      output: {
        rgb: function(color2) {
          return convertXyz65ToRgb(convertP3ToXyz65(color2));
        },
        xyz65: convertP3ToXyz65
      }
    }
  );
  var gamma$1 = function(v) {
    var abs = Math.abs(v);
    if (abs >= 1 / 512) {
      return Math.sign(v) * Math.pow(abs, 1 / 1.8);
    }
    return 16 * v;
  };
  var convertXyzToProphoto = function(ref) {
    var x = ref.x;
    var y = ref.y;
    var z = ref.z;
    var alpha = ref.alpha;
    var res = {
      mode: "prophoto",
      r: gamma$1(
        x * 1.3457989731028281 - y * 0.25558010007997534 - 0.05110628506753401 * z
      ),
      g: gamma$1(
        x * -0.5446224939028347 + y * 1.5082327413132781 + 0.02053603239147973 * z
      ),
      b: gamma$1(x * 0 + y * 0 + 1.2119675456389454 * z)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var linearize$1 = function(v) {
    var abs = Math.abs(v);
    if (abs >= 16 / 512) {
      return Math.sign(v) * Math.pow(abs, 1.8);
    }
    return v / 16;
  };
  var convertProphotoToXyz = function(prophoto2) {
    var r2 = linearize$1(prophoto2.r);
    var g = linearize$1(prophoto2.g);
    var b = linearize$1(prophoto2.b);
    var res = {
      mode: "xyz65",
      x: 0.7977604896723027 * r2 + 0.13518583717574031 * g + 0.0313493495815248 * b,
      y: 0.2880711282292934 * r2 + 0.7118432178101014 * g + 8565396060525902e-20 * b,
      z: 0 * r2 + 0 * g + 0.8251046025104601 * b
    };
    if (prophoto2.alpha !== void 0) {
      res.alpha = prophoto2.alpha;
    }
    return res;
  };
  var convertXyzToRgb = function(ref) {
    var x = ref.x;
    var y = ref.y;
    var z = ref.z;
    var alpha = ref.alpha;
    var res = convertLrgbToRgb({
      r: x * 3.1338561 - y * 1.6168667 - 0.4906146 * z,
      g: x * -0.9787684 + y * 1.9161415 + 0.033454 * z,
      b: x * 0.0719453 - y * 0.2289914 + 1.4052427 * z
    });
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertRgbToXyz = function(rgb2) {
    var ref = convertRgbToLrgb(rgb2);
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    var res = {
      mode: "xyz",
      x: 0.4360747 * r2 + 0.3850649 * g + 0.1430804 * b,
      y: 0.2225045 * r2 + 0.7168786 * g + 0.0606169 * b,
      z: 0.0139322 * r2 + 0.0971045 * g + 0.7141733 * b
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var definition$l = Object.assign(
    {},
    definition$p,
    {
      mode: "prophoto",
      parsers: ["prophoto-rgb"],
      serialize: "color(prophoto-rgb ",
      input: {
        xyz: convertXyzToProphoto,
        rgb: function(color2) {
          return convertXyzToProphoto(convertRgbToXyz(color2));
        }
      },
      output: {
        xyz: convertProphotoToXyz,
        rgb: function(color2) {
          return convertXyzToRgb(convertProphotoToXyz(color2));
        }
      }
    }
  );
  var \u03B1$1 = 1.09929682680944;
  var \u03B2$1 = 0.018053968510807;
  var gamma = function(v) {
    var abs = Math.abs(v);
    if (abs > \u03B2$1) {
      return (Math.sign(v) || 1) * (\u03B1$1 * Math.pow(abs, 0.45) - (\u03B1$1 - 1));
    }
    return 4.5 * v;
  };
  var convertXyz65ToRec2020 = function(ref) {
    var x = ref.x;
    var y = ref.y;
    var z = ref.z;
    var alpha = ref.alpha;
    var res = {
      mode: "rec2020",
      r: gamma(
        x * 1.7166511879712674 - y * 0.35567078377639233 - 0.25336628137365974 * z
      ),
      g: gamma(
        x * -0.6666843518324892 + y * 1.6164812366349395 + 0.01576854581391113 * z
      ),
      b: gamma(
        x * 0.017639857445310783 - y * 0.042770613257808524 + 0.9421031212354738 * z
      )
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var \u03B1 = 1.09929682680944;
  var \u03B2 = 0.018053968510807;
  var linearize = function(v) {
    var abs = Math.abs(v);
    if (abs < \u03B2 * 4.5) {
      return v / 4.5;
    }
    return (Math.sign(v) || 1) * Math.pow((abs + \u03B1 - 1) / \u03B1, 1 / 0.45);
  };
  var convertRec2020ToXyz65 = function(rec20202) {
    var r2 = linearize(rec20202.r);
    var g = linearize(rec20202.g);
    var b = linearize(rec20202.b);
    var res = {
      mode: "xyz65",
      x: 0.6369580483012914 * r2 + 0.14461690358620832 * g + 0.1688809751641721 * b,
      y: 0.2627002120112671 * r2 + 0.6779980715188708 * g + 0.05930171646986196 * b,
      z: 0 * r2 + 0.028072693049087428 * g + 1.060985057710791 * b
    };
    if (rec20202.alpha !== void 0) {
      res.alpha = rec20202.alpha;
    }
    return res;
  };
  var definition$k = Object.assign(
    {},
    definition$p,
    {
      mode: "rec2020",
      input: {
        xyz: convertXyz65ToRec2020,
        rgb: function(color2) {
          return convertXyz65ToRec2020(convertRgbToXyz65(color2));
        }
      },
      output: {
        xyz: convertRec2020ToXyz65,
        rgb: function(color2) {
          return convertXyz65ToRgb(convertRec2020ToXyz65(color2));
        }
      },
      parsers: ["rec2020"],
      serialize: "color(rec2020 "
    }
  );
  var normalizeHue = function(hue2) {
    return (hue2 = hue2 % 360) < 0 ? hue2 + 360 : hue2;
  };
  function convertHslToRgb(ref) {
    var h = ref.h;
    var s2 = ref.s;
    var l = ref.l;
    var alpha = ref.alpha;
    h = normalizeHue(h);
    var m1 = l + s2 * (l < 0.5 ? l : 1 - l);
    var m2 = m1 - (m1 - l) * 2 * Math.abs(h / 60 % 2 - 1);
    var res;
    switch (Math.floor(h / 60)) {
      case 0:
        res = { r: m1, g: m2, b: 2 * l - m1 };
        break;
      case 1:
        res = { r: m2, g: m1, b: 2 * l - m1 };
        break;
      case 2:
        res = { r: 2 * l - m1, g: m1, b: m2 };
        break;
      case 3:
        res = { r: 2 * l - m1, g: m2, b: m1 };
        break;
      case 4:
        res = { r: m2, g: 2 * l - m1, b: m1 };
        break;
      case 5:
        res = { r: m1, g: 2 * l - m1, b: m2 };
        break;
      default:
        res = { r: 2 * l - m1, g: 2 * l - m1, b: 2 * l - m1 };
    }
    res.mode = "rgb";
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  }
  function convertRgbToHsl(ref) {
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    var M2 = Math.max(r2, g, b), m = Math.min(r2, g, b);
    var res = {
      mode: "hsl",
      s: M2 === m ? 0 : (M2 - m) / (1 - Math.abs(M2 + m - 1)),
      l: 0.5 * (M2 + m)
    };
    if (M2 - m !== 0) {
      res.h = (M2 === r2 ? (g - b) / (M2 - m) + (g < b) * 6 : M2 === g ? (b - r2) / (M2 - m) + 2 : (r2 - g) / (M2 - m) + 4) * 60;
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  }
  var hue$1 = function(val, unit) {
    switch (unit) {
      case "deg":
        return +val;
      case "rad":
        return val / Math.PI * 180;
      case "grad":
        return val / 10 * 9;
      case "turn":
        return val * 360;
    }
  };
  var parseHsl = function(color2) {
    var match = color2.match(hsl_old) || color2.match(hsl_new);
    if (!match) {
      return;
    }
    var res = {
      mode: "hsl",
      h: match[3] === void 0 ? hue$1(match[1], match[2]) : +match[3],
      s: Math.min(Math.max(0, match[4] / 100), 1),
      l: Math.min(Math.max(0, match[5] / 100), 1)
    };
    if (match[6] !== void 0) {
      res.alpha = match[6] / 100;
    } else if (match[7] !== void 0) {
      res.alpha = +match[7];
    }
    return res;
  };
  var hue = function(hues, fn2) {
    return hues.map(function(hue2, idx, arr) {
      if (hue2 === void 0) {
        return hue2;
      }
      var normalized = normalizeHue(hue2);
      if (idx === 0 || hues[idx - 1] === void 0) {
        return normalized;
      }
      return fn2(normalized - normalizeHue(arr[idx - 1]));
    }).reduce(function(acc, curr) {
      if (!acc.length || curr === void 0 || acc[acc.length - 1] === void 0) {
        acc.push(curr);
        return acc;
      }
      acc.push(curr + acc[acc.length - 1]);
      return acc;
    }, []);
  };
  var fixupHueShorter = function(arr) {
    return hue(arr, function(d) {
      return Math.abs(d) <= 180 ? d : d - 360 * Math.sign(d);
    });
  };
  var converters = {};
  var modes = {};
  var parsers = [];
  var colorProfiles = {};
  var identity2 = function(v) {
    return v;
  };
  var defineMode = function(definition2) {
    converters[definition2.mode] = Object.assign(
      converters[definition2.mode] || {},
      definition2.output
    );
    Object.keys(definition2.input || {}).forEach(function(k2) {
      if (!converters[k2]) {
        converters[k2] = {};
      }
      converters[k2][definition2.mode] = definition2.input[k2];
    });
    if (!definition2.ranges) {
      definition2.ranges = {};
    }
    if (!definition2.difference) {
      definition2.difference = {};
    }
    definition2.channels.forEach(function(channel) {
      if (definition2.ranges[channel] === void 0) {
        definition2.ranges[channel] = [0, 1];
      }
      if (!definition2.interpolate[channel]) {
        throw new Error("Missing interpolator for: " + channel);
      }
      if (typeof definition2.interpolate[channel] === "function") {
        definition2.interpolate[channel] = {
          use: definition2.interpolate[channel]
        };
      }
      if (!definition2.interpolate[channel].fixup) {
        definition2.interpolate[channel].fixup = identity2;
      }
    });
    modes[definition2.mode] = definition2;
    (definition2.parsers || []).forEach(function(parser4) {
      if (typeof parser4 === "function") {
        parsers.push(parser4);
      } else if (typeof parser4 === "string") {
        colorProfiles[parser4] = definition2.mode;
      }
    });
  };
  var getModeDefinition = function(mode) {
    return modes[mode];
  };
  var parseColorSyntax = function(color2) {
    var m = color2.match(profiled);
    if (!m) {
      return void 0;
    }
    var mode = colorProfiles[m[1]];
    if (!mode) {
      return void 0;
    }
    var res = { mode };
    var i = 2;
    getModeDefinition(mode).channels.forEach(function(ch) {
      if (m[i] !== void 0 || m[i + 1] !== void 0) {
        res[ch] = m[i] !== void 0 ? m[i] / 100 : +m[i + 1];
      }
      i += 2;
    });
    return res;
  };
  var parse3 = function(color2) {
    if (typeof color2 !== "string") {
      return void 0;
    }
    var result = void 0;
    var i = 0;
    var len = parsers.length;
    while (i < len) {
      if ((result = parsers[i++](color2)) !== void 0) {
        break;
      }
    }
    return result || parseColorSyntax(color2);
  };
  var prepare = function(color2, mode) {
    return color2 === void 0 ? void 0 : typeof color2 !== "object" ? parse3(color2) : color2.mode !== void 0 ? color2 : mode ? Object.assign({}, color2, { mode }) : void 0;
  };
  var converter = function(target_mode) {
    if (target_mode === void 0)
      target_mode = "rgb";
    return function(color2) {
      return (color2 = prepare(color2, target_mode)) !== void 0 ? (
        // if the color's mode corresponds to our target mode
        color2.mode === target_mode ? (
          // then just return the color
          color2
        ) : (
          // otherwise check to see if we have a dedicated
          // converter for the target mode
          converters[color2.mode][target_mode] ? (
            // and return its result...
            converters[color2.mode][target_mode](color2)
          ) : (
            // ...otherwise pass through RGB as an intermediary step.
            // if the target mode is RGB...
            target_mode === "rgb" ? (
              // just return the RGB
              converters[color2.mode].rgb(color2)
            ) : (
              // otherwise convert color.mode -> RGB -> target_mode
              converters.rgb[target_mode](converters[color2.mode].rgb(color2))
            )
          )
        )
      ) : void 0;
    };
  };
  var differenceHueSaturation = function(std, smp) {
    if (std.h === void 0 || smp.h === void 0 || !std.s || !smp.s) {
      return 0;
    }
    var std_h = normalizeHue(std.h);
    var smp_h = normalizeHue(smp.h);
    var dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
    return 2 * Math.sqrt(std.s * smp.s) * dH;
  };
  var differenceHueNaive = function(std, smp) {
    if (std.h === void 0 || smp.h === void 0) {
      return 0;
    }
    var std_h = normalizeHue(std.h);
    var smp_h = normalizeHue(smp.h);
    if (Math.abs(smp_h - std_h) > 180) {
      return std_h - (smp_h - 360 * Math.sign(smp_h - std_h));
    }
    return smp_h - std_h;
  };
  var differenceHueChroma = function(std, smp) {
    if (std.h === void 0 || smp.h === void 0 || !std.c || !smp.c) {
      return 0;
    }
    var std_h = normalizeHue(std.h);
    var smp_h = normalizeHue(smp.h);
    var dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
    return 2 * Math.sqrt(std.c * smp.c) * dH;
  };
  var averageAngle = function(val) {
    var sum = val.reduce(
      function(sum2, val2) {
        if (val2 !== void 0) {
          var rad = val2 * Math.PI / 180;
          sum2.sin += Math.sin(rad);
          sum2.cos += Math.cos(rad);
        }
        return sum2;
      },
      { sin: 0, cos: 0 }
    );
    return Math.atan2(sum.sin, sum.cos) * 180 / Math.PI;
  };
  var definition$j = {
    mode: "hsl",
    output: {
      rgb: convertHslToRgb
    },
    input: {
      rgb: convertRgbToHsl
    },
    channels: ["h", "s", "l", "alpha"],
    ranges: {
      h: [0, 360]
    },
    parsers: [parseHsl],
    serialize: function(c4) {
      return "hsl(" + (c4.h || 0) + " " + c4.s * 100 + "% " + c4.l * 100 + "%" + (c4.alpha < 1 ? " / " + c4.alpha : "") + ")";
    },
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      s: interpolatorLinear,
      l: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueSaturation
    },
    average: {
      h: averageAngle
    }
  };
  function convertHsvToRgb(ref) {
    var h = ref.h;
    var s2 = ref.s;
    var v = ref.v;
    var alpha = ref.alpha;
    h = normalizeHue(h);
    var f2 = Math.abs(h / 60 % 2 - 1);
    var res;
    switch (Math.floor(h / 60)) {
      case 0:
        res = { r: v, g: v * (1 - s2 * f2), b: v * (1 - s2) };
        break;
      case 1:
        res = { r: v * (1 - s2 * f2), g: v, b: v * (1 - s2) };
        break;
      case 2:
        res = { r: v * (1 - s2), g: v, b: v * (1 - s2 * f2) };
        break;
      case 3:
        res = { r: v * (1 - s2), g: v * (1 - s2 * f2), b: v };
        break;
      case 4:
        res = { r: v * (1 - s2 * f2), g: v * (1 - s2), b: v };
        break;
      case 5:
        res = { r: v, g: v * (1 - s2), b: v * (1 - s2 * f2) };
        break;
      default:
        res = { r: v * (1 - s2), g: v * (1 - s2), b: v * (1 - s2) };
    }
    res.mode = "rgb";
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  }
  function convertRgbToHsv(ref) {
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    var M2 = Math.max(r2, g, b), m = Math.min(r2, g, b);
    var res = {
      mode: "hsv",
      s: M2 === 0 ? 0 : 1 - m / M2,
      v: M2
    };
    if (M2 - m !== 0) {
      res.h = (M2 === r2 ? (g - b) / (M2 - m) + (g < b) * 6 : M2 === g ? (b - r2) / (M2 - m) + 2 : (r2 - g) / (M2 - m) + 4) * 60;
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  }
  var definition$i = {
    mode: "hsv",
    output: {
      rgb: convertHsvToRgb
    },
    parsers: ["--hsv"],
    serialize: "color(--hsv ",
    input: {
      rgb: convertRgbToHsv
    },
    channels: ["h", "s", "v", "alpha"],
    ranges: {
      h: [0, 360]
    },
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      s: interpolatorLinear,
      v: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueSaturation
    },
    average: {
      h: averageAngle
    }
  };
  function convertHsiToRgb(ref) {
    var h = ref.h;
    var s2 = ref.s;
    var i = ref.i;
    var alpha = ref.alpha;
    h = normalizeHue(h);
    var f2 = Math.abs(h / 60 % 2 - 1);
    var res;
    switch (Math.floor(h / 60)) {
      case 0:
        res = {
          r: i * (1 + s2 * (3 / (2 - f2) - 1)),
          g: i * (1 + s2 * (3 * (1 - f2) / (2 - f2) - 1)),
          b: i * (1 - s2)
        };
        break;
      case 1:
        res = {
          r: i * (1 + s2 * (3 * (1 - f2) / (2 - f2) - 1)),
          g: i * (1 + s2 * (3 / (2 - f2) - 1)),
          b: i * (1 - s2)
        };
        break;
      case 2:
        res = {
          r: i * (1 - s2),
          g: i * (1 + s2 * (3 / (2 - f2) - 1)),
          b: i * (1 + s2 * (3 * (1 - f2) / (2 - f2) - 1))
        };
        break;
      case 3:
        res = {
          r: i * (1 - s2),
          g: i * (1 + s2 * (3 * (1 - f2) / (2 - f2) - 1)),
          b: i * (1 + s2 * (3 / (2 - f2) - 1))
        };
        break;
      case 4:
        res = {
          r: i * (1 + s2 * (3 * (1 - f2) / (2 - f2) - 1)),
          g: i * (1 - s2),
          b: i * (1 + s2 * (3 / (2 - f2) - 1))
        };
        break;
      case 5:
        res = {
          r: i * (1 + s2 * (3 / (2 - f2) - 1)),
          g: i * (1 - s2),
          b: i * (1 + s2 * (3 * (1 - f2) / (2 - f2) - 1))
        };
        break;
      default:
        res = { r: i * (1 - s2), g: i * (1 - s2), b: i * (1 - s2) };
    }
    res.mode = "rgb";
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  }
  function convertRgbToHsi(ref) {
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    var M2 = Math.max(r2, g, b), m = Math.min(r2, g, b);
    var res = {
      mode: "hsi",
      s: r2 + g + b === 0 ? 0 : 1 - 3 * m / (r2 + g + b),
      i: (r2 + g + b) / 3
    };
    if (M2 - m !== 0) {
      res.h = (M2 === r2 ? (g - b) / (M2 - m) + (g < b) * 6 : M2 === g ? (b - r2) / (M2 - m) + 2 : (r2 - g) / (M2 - m) + 4) * 60;
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  }
  var definition$h = {
    mode: "hsi",
    output: {
      rgb: convertHsiToRgb
    },
    parsers: ["--hsi"],
    serialize: "color(--hsi ",
    input: {
      rgb: convertRgbToHsi
    },
    channels: ["h", "s", "i", "alpha"],
    ranges: {
      h: [0, 360]
    },
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      s: interpolatorLinear,
      i: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueSaturation
    },
    average: {
      h: averageAngle
    }
  };
  function convertHwbToRgb(ref) {
    var h = ref.h;
    var w = ref.w;
    var b = ref.b;
    var alpha = ref.alpha;
    if (w + b > 1) {
      var s2 = w + b;
      w /= s2;
      b /= s2;
    }
    return convertHsvToRgb({
      h,
      s: b === 1 ? 1 : 1 - w / (1 - b),
      v: 1 - b,
      alpha
    });
  }
  function convertRgbToHwb(rgba) {
    var hsv2 = convertRgbToHsv(rgba);
    if (hsv2 === void 0) {
      return void 0;
    }
    var res = {
      mode: "hwb",
      w: (1 - hsv2.s) * hsv2.v,
      b: 1 - hsv2.v
    };
    if (hsv2.h !== void 0) {
      res.h = hsv2.h;
    }
    if (hsv2.alpha !== void 0) {
      res.alpha = hsv2.alpha;
    }
    return res;
  }
  var parseHwb = function(color2) {
    var match = color2.match(hwb$1);
    if (!match) {
      return void 0;
    }
    var res = {
      mode: "hwb",
      h: match[3] === void 0 ? hue$1(match[1], match[2]) : +match[3],
      w: match[4] / 100,
      b: match[5] / 100
    };
    if (match[6] !== void 0) {
      res.alpha = match[6] / 100;
    } else if (match[7] !== void 0) {
      res.alpha = +match[7];
    }
    return res;
  };
  var definition$g = {
    mode: "hwb",
    output: {
      rgb: convertHwbToRgb
    },
    input: {
      rgb: convertRgbToHwb
    },
    channels: ["h", "w", "b", "alpha"],
    ranges: {
      h: [0, 360]
    },
    parsers: [parseHwb],
    serialize: function(c4) {
      return "hwb(" + (c4.h || 0) + " " + c4.w * 100 + "% " + c4.b * 100 + "%" + (c4.alpha < 1 ? " / " + c4.alpha : "") + ")";
    },
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      w: interpolatorLinear,
      b: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueNaive
    },
    average: {
      h: averageAngle
    }
  };
  var n$1 = 0.1593017578125;
  var p$1 = 134.03437499999998;
  var c1$1 = 0.8359375;
  var c2$1 = 18.8515625;
  var c3$1 = 18.6875;
  var d0$1 = 16295499532821565e-27;
  var pq = function(v) {
    var vn2 = Math.pow(v / 1e4, n$1);
    return Math.pow((c1$1 + c2$1 * vn2) / (1 + c3$1 * vn2), p$1) || 0;
  };
  var abs$1 = function(v) {
    return Math.max(v * 203, 0);
  };
  var convertXyz65ToJab = function(ref) {
    var x = ref.x;
    var y = ref.y;
    var z = ref.z;
    var alpha = ref.alpha;
    x = abs$1(x);
    y = abs$1(y);
    z = abs$1(z);
    var xp = 1.15 * x - 0.15 * z;
    var yp = 0.66 * y + 0.34 * x;
    var l = pq(0.41478972 * xp + 0.579999 * yp + 0.014648 * z);
    var m = pq(-0.20151 * xp + 1.120649 * yp + 0.0531008 * z);
    var s2 = pq(-0.0166008 * xp + 0.2648 * yp + 0.6684799 * z);
    var i = (l + m) / 2;
    var res = {
      mode: "jab",
      j: 0.44 * i / (1 - 0.56 * i) - d0$1,
      a: 3.524 * l - 4.066708 * m + 0.542708 * s2,
      b: 0.199076 * l + 1.096799 * m - 1.295875 * s2
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var n = 0.1593017578125;
  var p = 134.03437499999998;
  var c1 = 0.8359375;
  var c2 = 18.8515625;
  var c3 = 18.6875;
  var d0 = 16295499532821565e-27;
  var pq_inv = function(v) {
    var vp = Math.pow(v, 1 / p);
    return 1e4 * Math.pow((c1 - vp) / (c3 * vp - c2), 1 / n) || 0;
  };
  var rel = function(v) {
    return v / 203;
  };
  var convertJabToXyz65 = function(ref) {
    var j = ref.j;
    var a = ref.a;
    var b = ref.b;
    var alpha = ref.alpha;
    var i = (j + d0) / (0.44 + 0.56 * (j + d0));
    var l = pq_inv(i + 0.13860504 * a + 0.058047316 * b);
    var m = pq_inv(i - 0.13860504 * a - 0.058047316 * b);
    var s2 = pq_inv(i - 0.096019242 * a - 0.8118919 * b);
    var res = {
      mode: "xyz65",
      x: rel(
        1.661373024652174 * l - 0.914523081304348 * m + 0.23136208173913045 * s2
      ),
      y: rel(
        -0.3250758611844533 * l + 1.571847026732543 * m - 0.21825383453227928 * s2
      ),
      z: rel(-0.090982811 * l - 0.31272829 * m + 1.5227666 * s2)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertRgbToJab = function(rgb2) {
    var res = convertXyz65ToJab(convertRgbToXyz65(rgb2));
    if (rgb2.r === rgb2.b && rgb2.b === rgb2.g) {
      res.a = res.b = 0;
    }
    return res;
  };
  var convertJabToRgb = function(color2) {
    return convertXyz65ToRgb(convertJabToXyz65(color2));
  };
  var definition$f = {
    mode: "jab",
    channels: ["j", "a", "b", "alpha"],
    parsers: ["--jzazbz"],
    serialize: "color(--jzazbz ",
    input: {
      rgb: convertRgbToJab,
      xyz65: convertXyz65ToJab
    },
    output: {
      rgb: convertJabToRgb,
      xyz65: convertJabToXyz65
    },
    ranges: {
      j: [0, 0.222],
      a: [-0.109, 0.129],
      b: [-0.185, 0.134]
    },
    interpolate: {
      j: interpolatorLinear,
      a: interpolatorLinear,
      b: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var convertJabToJch = function(ref) {
    var j = ref.j;
    var a = ref.a;
    var b = ref.b;
    var alpha = ref.alpha;
    var c4 = Math.sqrt(a * a + b * b);
    var res = {
      mode: "jch",
      j,
      c: c4
    };
    if (c4) {
      res.h = normalizeHue(Math.atan2(b, a) * 180 / Math.PI);
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertJchToJab = function(ref) {
    var j = ref.j;
    var c4 = ref.c;
    var h = ref.h;
    var alpha = ref.alpha;
    var res = {
      mode: "jab",
      j,
      a: c4 ? c4 * Math.cos(h / 180 * Math.PI) : 0,
      b: c4 ? c4 * Math.sin(h / 180 * Math.PI) : 0
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var definition$e = {
    mode: "jch",
    parsers: ["--jzczhz"],
    serialize: "color(--jzczhz ",
    output: {
      jab: convertJchToJab,
      rgb: function(c4) {
        return convertJabToRgb(convertJchToJab(c4));
      }
    },
    input: {
      rgb: function(c4) {
        return convertJabToJch(convertRgbToJab(c4));
      },
      jab: convertJabToJch
    },
    channels: ["j", "c", "h", "alpha"],
    ranges: {
      j: [0, 0.221],
      c: [0, 0.19],
      h: [0, 360]
    },
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      c: interpolatorLinear,
      j: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueChroma
    },
    average: {
      h: averageAngle
    }
  };
  var Xn$1 = 0.96422;
  var Yn$1 = 1;
  var Zn$1 = 0.82521;
  var k$1 = Math.pow(29, 3) / Math.pow(3, 3);
  var e$1 = Math.pow(6, 3) / Math.pow(29, 3);
  var fn$1 = function(v) {
    return Math.pow(v, 3) > e$1 ? Math.pow(v, 3) : (116 * v - 16) / k$1;
  };
  var convertLabToXyz = function(ref) {
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var alpha = ref.alpha;
    var fy = (l + 16) / 116;
    var fx = a / 500 + fy;
    var fz = fy - b / 200;
    var res = {
      mode: "xyz",
      x: fn$1(fx) * Xn$1,
      y: fn$1(fy) * Yn$1,
      z: fn$1(fz) * Zn$1
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLabToRgb = function(lab2) {
    return convertXyzToRgb(convertLabToXyz(lab2));
  };
  var f$1 = function(value2) {
    return value2 > e$1 ? Math.cbrt(value2) : (k$1 * value2 + 16) / 116;
  };
  var convertXyzToLab = function(ref) {
    var x = ref.x;
    var y = ref.y;
    var z = ref.z;
    var alpha = ref.alpha;
    var f0 = f$1(x / Xn$1);
    var f1 = f$1(y / Yn$1);
    var f2 = f$1(z / Zn$1);
    var res = {
      mode: "lab",
      l: 116 * f1 - 16,
      a: 500 * (f0 - f1),
      b: 200 * (f1 - f2)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertRgbToLab = function(rgb2) {
    var res = convertXyzToLab(convertRgbToXyz(rgb2));
    if (rgb2.r === rgb2.b && rgb2.b === rgb2.g) {
      res.a = res.b = 0;
    }
    return res;
  };
  var parseLab = function(color2) {
    var match = color2.match(lab$1);
    if (!match) {
      return void 0;
    }
    var res = {
      mode: "lab",
      l: +match[1],
      a: +match[2],
      b: +match[3]
    };
    if (match[4] !== void 0) {
      res.alpha = match[4] / 100;
    } else if (match[5] !== void 0) {
      res.alpha = +match[5];
    }
    return res;
  };
  var definition$d = {
    mode: "lab",
    output: {
      xyz: convertLabToXyz,
      rgb: convertLabToRgb
    },
    input: {
      xyz: convertXyzToLab,
      rgb: convertRgbToLab
    },
    channels: ["l", "a", "b", "alpha"],
    ranges: {
      l: [0, 100],
      a: [-79.287, 93.55],
      b: [-112.029, 93.388]
    },
    parsers: [parseLab],
    serialize: function(c4) {
      return "lab(" + c4.l + "% " + c4.a + " " + c4.b + (c4.alpha < 1 ? " / " + c4.alpha : "") + ")";
    },
    interpolate: {
      l: interpolatorLinear,
      a: interpolatorLinear,
      b: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var Xn = 0.95047;
  var Yn = 1;
  var Zn = 1.08883;
  var k = Math.pow(29, 3) / Math.pow(3, 3);
  var e = Math.pow(6, 3) / Math.pow(29, 3);
  var fn = function(v) {
    return Math.pow(v, 3) > e ? Math.pow(v, 3) : (116 * v - 16) / k;
  };
  var convertLab65ToXyz65 = function(ref) {
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var alpha = ref.alpha;
    var fy = (l + 16) / 116;
    var fx = a / 500 + fy;
    var fz = fy - b / 200;
    var res = {
      mode: "xyz65",
      x: fn(fx) * Xn,
      y: fn(fy) * Yn,
      z: fn(fz) * Zn
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLab65ToRgb = function(lab2) {
    return convertXyz65ToRgb(convertLab65ToXyz65(lab2));
  };
  var f = function(value2) {
    return value2 > e ? Math.cbrt(value2) : (k * value2 + 16) / 116;
  };
  var convertXyz65ToLab65 = function(ref) {
    var x = ref.x;
    var y = ref.y;
    var z = ref.z;
    var alpha = ref.alpha;
    var f0 = f(x / Xn);
    var f1 = f(y / Yn);
    var f2 = f(z / Zn);
    var res = {
      mode: "lab65",
      l: 116 * f1 - 16,
      a: 500 * (f0 - f1),
      b: 200 * (f1 - f2)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertRgbToLab65 = function(rgb2) {
    var res = convertXyz65ToLab65(convertRgbToXyz65(rgb2));
    if (rgb2.r === rgb2.b && rgb2.b === rgb2.g) {
      res.a = res.b = 0;
    }
    return res;
  };
  var definition$c = Object.assign(
    {},
    definition$d,
    {
      mode: "lab65",
      parsers: ["--lab-d65"],
      serialize: "color(--lab-d65 ",
      output: {
        xyz65: convertLab65ToXyz65,
        rgb: convertLab65ToRgb
      },
      input: {
        xyz65: convertXyz65ToLab65,
        rgb: convertRgbToLab65
      },
      ranges: {
        l: [0, 100],
        a: [-86.182, 98.234],
        b: [-107.86, 94.477]
      }
    }
  );
  var convertLabToLch = function(ref, mode) {
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var alpha = ref.alpha;
    if (mode === void 0)
      mode = "lch";
    var c4 = Math.sqrt(a * a + b * b);
    var res = { mode, l, c: c4 };
    if (c4) {
      res.h = normalizeHue(Math.atan2(b, a) * 180 / Math.PI);
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLchToLab = function(ref, mode) {
    var l = ref.l;
    var c4 = ref.c;
    var h = ref.h;
    var alpha = ref.alpha;
    if (mode === void 0)
      mode = "lab";
    var res = {
      mode,
      l,
      a: c4 ? c4 * Math.cos(h / 180 * Math.PI) : 0,
      b: c4 ? c4 * Math.sin(h / 180 * Math.PI) : 0
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var parseLch = function(color2) {
    var match = color2.match(lch$1);
    if (!match) {
      return void 0;
    }
    var res = {
      mode: "lch",
      l: +match[1],
      c: Math.max(0, +match[2]),
      h: match[5] === void 0 ? hue$1(match[3], match[4]) : +match[5]
    };
    if (match[6] !== void 0) {
      res.alpha = match[6] / 100;
    } else if (match[7] !== void 0) {
      res.alpha = +match[7];
    }
    return res;
  };
  var definition$b = {
    mode: "lch",
    output: {
      lab: convertLchToLab,
      rgb: function(c4) {
        return convertLabToRgb(convertLchToLab(c4));
      }
    },
    input: {
      rgb: function(c4) {
        return convertLabToLch(convertRgbToLab(c4));
      },
      lab: convertLabToLch
    },
    channels: ["l", "c", "h", "alpha"],
    ranges: {
      l: [0, 100],
      c: [0, 131.207],
      h: [0, 360]
    },
    parsers: [parseLch],
    serialize: function(c4) {
      return "lch(" + c4.l + "% " + c4.c + " " + (c4.h || 0) + (c4.alpha < 1 ? " / " + c4.alpha : "") + ")";
    },
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      c: interpolatorLinear,
      l: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueChroma
    },
    average: {
      h: averageAngle
    }
  };
  var definition$a = Object.assign(
    {},
    definition$b,
    {
      mode: "lch65",
      parsers: ["--lch-d65"],
      serialize: "color(--lch-d65 ",
      output: {
        lab65: function(c4) {
          return convertLchToLab(c4, "lab65");
        },
        rgb: function(c4) {
          return convertLab65ToRgb(convertLchToLab(c4, "lab65"));
        }
      },
      input: {
        rgb: function(c4) {
          return convertLabToLch(convertRgbToLab65(c4), "lch65");
        },
        lab65: function(c4) {
          return convertLabToLch(c4, "lch65");
        }
      },
      ranges: {
        l: [0, 100],
        c: [0, 133.807],
        h: [0, 360]
      }
    }
  );
  var u_fn$1 = function(x, y, z) {
    return 4 * x / (x + 15 * y + 3 * z);
  };
  var v_fn$1 = function(x, y, z) {
    return 9 * y / (x + 15 * y + 3 * z);
  };
  var un$1 = u_fn$1(Xn$1, Yn$1, Zn$1);
  var vn$1 = v_fn$1(Xn$1, Yn$1, Zn$1);
  var l_fn = function(value2) {
    return value2 <= e$1 ? k$1 * value2 : 116 * Math.cbrt(value2) - 16;
  };
  var convertXyzToLuv = function(ref) {
    var x = ref.x;
    var y = ref.y;
    var z = ref.z;
    var alpha = ref.alpha;
    var l = l_fn(y / Yn$1);
    var u = u_fn$1(x, y, z);
    var v = v_fn$1(x, y, z);
    if (!isFinite(u) || !isFinite(v)) {
      l = u = v = 0;
    } else {
      u = 13 * l * (u - un$1);
      v = 13 * l * (v - vn$1);
    }
    var res = {
      mode: "luv",
      l,
      u,
      v
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertRgbToLuv = function(rgb2) {
    return convertXyzToLuv(convertRgbToXyz(rgb2));
  };
  var u_fn = function(x, y, z) {
    return 4 * x / (x + 15 * y + 3 * z);
  };
  var v_fn = function(x, y, z) {
    return 9 * y / (x + 15 * y + 3 * z);
  };
  var un = u_fn(Xn$1, Yn$1, Zn$1);
  var vn = v_fn(Xn$1, Yn$1, Zn$1);
  var convertLuvToXyz = function(ref) {
    var l = ref.l;
    var u = ref.u;
    var v = ref.v;
    var alpha = ref.alpha;
    var up = u / (13 * l) + un;
    var vp = v / (13 * l) + vn;
    var y = Yn$1 * (l <= 8 ? l / k$1 : Math.pow((l + 16) / 116, 3));
    var x = y * (9 * up) / (4 * vp);
    var z = y * (12 - 3 * up - 20 * vp) / (4 * vp);
    var res = { mode: "xyz", x, y, z };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLuvToRgb = function(luv2) {
    return convertXyzToRgb(convertLuvToXyz(luv2));
  };
  var definition$9 = {
    mode: "luv",
    output: {
      xyz: convertLuvToXyz,
      rgb: convertLuvToRgb
    },
    input: {
      xyz: convertXyzToLuv,
      rgb: convertRgbToLuv
    },
    channels: ["l", "u", "v", "alpha"],
    parsers: ["--luv"],
    serialize: "color(--luv ",
    ranges: {
      l: [0, 100],
      u: [-84.936, 175.042],
      v: [-125.882, 87.243]
    },
    interpolate: {
      l: interpolatorLinear,
      u: interpolatorLinear,
      v: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var convertLuvToLchuv = function(ref) {
    var l = ref.l;
    var u = ref.u;
    var v = ref.v;
    var alpha = ref.alpha;
    var c4 = Math.sqrt(u * u + v * v);
    var res = {
      mode: "lchuv",
      l,
      c: c4
    };
    if (c4) {
      res.h = normalizeHue(Math.atan2(v, u) * 180 / Math.PI);
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLchuvToLuv = function(ref) {
    var l = ref.l;
    var c4 = ref.c;
    var h = ref.h;
    var alpha = ref.alpha;
    var res = {
      mode: "luv",
      l,
      u: c4 ? c4 * Math.cos(h / 180 * Math.PI) : 0,
      v: c4 ? c4 * Math.sin(h / 180 * Math.PI) : 0
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLchuvToRgb = function(c4) {
    return convertLuvToRgb(convertLchuvToLuv(c4));
  };
  var convertRgbToLchuv = function(c4) {
    return convertLuvToLchuv(convertRgbToLuv(c4));
  };
  var definition$8 = {
    mode: "lchuv",
    output: {
      luv: convertLchuvToLuv,
      rgb: convertLchuvToRgb
    },
    input: {
      rgb: convertRgbToLchuv,
      luv: convertLuvToLchuv
    },
    channels: ["l", "c", "h", "alpha"],
    parsers: ["--lchuv"],
    serialize: "color(--lchuv ",
    ranges: {
      l: [0, 100],
      c: [0, 176.956],
      h: [0, 360]
    },
    interpolate: {
      h: { use: interpolatorLinear, fixup: fixupHueShorter },
      c: interpolatorLinear,
      l: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    },
    difference: {
      h: differenceHueChroma
    },
    average: {
      h: averageAngle
    }
  };
  var M = [-0.14861, 1.78277, -0.29227, -0.90649, 1.97294, 0];
  var degToRad = Math.PI / 180;
  var radToDeg = 180 / Math.PI;
  var DE = M[3] * M[4];
  var BE = M[1] * M[4];
  var BCAD = M[1] * M[2] - M[0] * M[3];
  var convertRgbToCubehelix = function(ref) {
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    var l = (BCAD * b + r2 * DE - g * BE) / (BCAD + DE - BE);
    var x = b - l;
    var y = (M[4] * (g - l) - M[2] * x) / M[3];
    var res = {
      mode: "cubehelix",
      l,
      s: l === 0 || l === 1 ? void 0 : Math.sqrt(x * x + y * y) / (M[4] * l * (1 - l))
    };
    if (res.s) {
      res.h = Math.atan2(y, x) * radToDeg - 120;
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertCubehelixToRgb = function(ref) {
    var h = ref.h;
    var s2 = ref.s;
    var l = ref.l;
    var alpha = ref.alpha;
    var res = { mode: "rgb" };
    h = (h === void 0 ? 0 : h + 120) * degToRad;
    var amp = s2 === void 0 ? 0 : s2 * l * (1 - l);
    var cosh = Math.cos(h);
    var sinh = Math.sin(h);
    res.r = l + amp * (M[0] * cosh + M[1] * sinh);
    res.g = l + amp * (M[2] * cosh + M[3] * sinh);
    res.b = l + amp * (M[4] * cosh + M[5] * sinh);
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var definition$7 = {
    mode: "cubehelix",
    channels: ["h", "s", "l", "alpha"],
    parsers: ["--cubehelix"],
    serialize: "color(--cubehelix ",
    ranges: {
      h: [0, 360],
      s: [0, 4.614],
      l: [0, 1]
    },
    input: {
      rgb: convertRgbToCubehelix
    },
    output: {
      rgb: convertCubehelixToRgb
    },
    interpolate: {
      h: {
        use: interpolatorLinear,
        fixup: fixupHueShorter
      },
      s: interpolatorLinear,
      l: interpolatorLinear,
      alpha: {
        use: interpolatorLinear,
        fixup: fixupAlpha
      }
    },
    difference: {
      h: differenceHueSaturation
    },
    average: {
      h: averageAngle
    }
  };
  var convertDlabToDlch = function(ref) {
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var alpha = ref.alpha;
    var c4 = Math.sqrt(a * a + b * b);
    var res = {
      mode: "dlch",
      l,
      c: c4
    };
    if (c4) {
      res.h = normalizeHue(Math.atan2(b, a) * 180 / Math.PI);
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var kE = 1;
  var kCH = 1;
  var \u03B8 = 26 / 180 * Math.PI;
  var cos\u03B8 = Math.cos(\u03B8);
  var sin\u03B8 = Math.sin(\u03B8);
  var factor = 100 / Math.log(139 / 100);
  var convertDlchToLab65 = function(ref) {
    var l = ref.l;
    var c4 = ref.c;
    var h = ref.h;
    var alpha = ref.alpha;
    var res = {
      mode: "lab65",
      l: (Math.exp(l * kE / factor) - 1) / 39e-4
    };
    if (h === void 0) {
      res.a = res.b = 0;
    } else {
      var G = (Math.exp(0.0435 * c4 * kCH * kE) - 1) / 0.075;
      var e2 = G * Math.cos(h / 180 * Math.PI - \u03B8);
      var f2 = G * Math.sin(h / 180 * Math.PI - \u03B8);
      res.a = e2 * cos\u03B8 - f2 / 0.83 * sin\u03B8;
      res.b = e2 * sin\u03B8 + f2 / 0.83 * cos\u03B8;
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertDlabToLab65 = function(c4) {
    return convertDlchToLab65(convertDlabToDlch(c4));
  };
  var convertLab65ToDlch = function(ref) {
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var alpha = ref.alpha;
    var e2 = a * cos\u03B8 + b * sin\u03B8;
    var f2 = 0.83 * (b * cos\u03B8 - a * sin\u03B8);
    var G = Math.sqrt(e2 * e2 + f2 * f2);
    var res = {
      mode: "dlch",
      l: factor / kE * Math.log(1 + 39e-4 * l),
      c: Math.log(1 + 0.075 * G) / (0.0435 * kCH * kE)
    };
    if (res.c) {
      res.h = normalizeHue((Math.atan2(f2, e2) + \u03B8) / Math.PI * 180);
    }
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertDlchToDlab = function(ref) {
    var l = ref.l;
    var c4 = ref.c;
    var h = ref.h;
    var alpha = ref.alpha;
    var res = {
      mode: "dlab",
      l,
      a: c4 === 0 ? 0 : c4 * Math.cos(h / 180 * Math.PI),
      b: c4 === 0 ? 0 : c4 * Math.sin(h / 180 * Math.PI)
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLab65ToDlab = function(c4) {
    return convertDlchToDlab(convertLab65ToDlch(c4));
  };
  var definition$6 = {
    mode: "dlab",
    parsers: ["--din99o-lab"],
    serialize: "color(--din99o-lab ",
    output: {
      lab65: convertDlabToLab65,
      rgb: function(c4) {
        return convertLab65ToRgb(convertDlabToLab65(c4));
      }
    },
    input: {
      lab65: convertLab65ToDlab,
      rgb: function(c4) {
        return convertLab65ToDlab(convertRgbToLab65(c4));
      }
    },
    channels: ["l", "a", "b", "alpha"],
    ranges: {
      l: [0, 100],
      a: [-40.09, 45.501],
      b: [-40.469, 44.344]
    },
    interpolate: {
      l: interpolatorLinear,
      a: interpolatorLinear,
      b: interpolatorLinear,
      alpha: {
        use: interpolatorLinear,
        fixup: fixupAlpha
      }
    }
  };
  var definition$5 = {
    mode: "dlch",
    parsers: ["--din99o-lch"],
    serialize: "color(--din99o-lch ",
    output: {
      lab65: convertDlchToLab65,
      dlab: convertDlchToDlab,
      rgb: function(c4) {
        return convertLab65ToRgb(convertDlchToLab65(c4));
      }
    },
    input: {
      lab65: convertLab65ToDlch,
      dlab: convertDlabToDlch,
      rgb: function(c4) {
        return convertLab65ToDlch(convertRgbToLab65(c4));
      }
    },
    channels: ["l", "c", "h", "alpha"],
    ranges: {
      l: [0, 100],
      c: [0, 51.484],
      h: [0, 360]
    },
    interpolate: {
      l: interpolatorLinear,
      c: interpolatorLinear,
      h: {
        use: interpolatorLinear,
        fixup: fixupHueShorter
      },
      alpha: {
        use: interpolatorLinear,
        fixup: fixupAlpha
      }
    },
    difference: {
      h: differenceHueChroma
    },
    average: {
      h: averageAngle
    }
  };
  var definition$4 = {
    mode: "xyz",
    parsers: ["xyz", "--xyz-d50"],
    serialize: "color(--xyz-d50 ",
    output: {
      rgb: convertXyzToRgb,
      lab: convertXyzToLab
    },
    input: {
      rgb: convertRgbToXyz,
      lab: convertLabToXyz
    },
    channels: ["x", "y", "z", "alpha"],
    ranges: {
      x: [0, 0.964],
      y: [0, 0.999],
      z: [0, 0.825]
    },
    interpolate: {
      x: interpolatorLinear,
      y: interpolatorLinear,
      z: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var convertXyz65ToXyz = function(xyz652) {
    var x = xyz652.x;
    var y = xyz652.y;
    var z = xyz652.z;
    var alpha = xyz652.alpha;
    var res = {
      mode: "xyz",
      x: 1.0478112 * x + 0.0228866 * y - 0.050127 * z,
      y: 0.0295424 * x + 0.9904844 * y - 0.0170491 * z,
      z: -92345e-7 * x + 0.0150436 * y + 0.7521316 * z
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertXyzToXyz65 = function(xyz2) {
    var x = xyz2.x;
    var y = xyz2.y;
    var z = xyz2.z;
    var alpha = xyz2.alpha;
    var res = {
      mode: "xyz65",
      x: 0.9555766 * x - 0.0230393 * y + 0.0631636 * z,
      y: -0.0282895 * x + 1.0099416 * y + 0.0210077 * z,
      z: 0.0122982 * x - 0.020483 * y + 1.3299098 * z
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var definition$3 = {
    mode: "xyz65",
    serialize: "color(--xyz-d65 ",
    output: {
      rgb: convertXyz65ToRgb,
      xyz: convertXyz65ToXyz
    },
    input: {
      rgb: convertRgbToXyz65,
      xyz: convertXyzToXyz65
    },
    ranges: {
      x: [0, 0.95],
      y: [0, 1],
      z: [0, 1.088]
    },
    channels: ["x", "y", "z", "alpha"],
    parsers: ["--xyz-d65"],
    interpolate: {
      x: interpolatorLinear,
      y: interpolatorLinear,
      z: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var convertRgbToYiq = function(rgb2) {
    var ref = convertRgbToLrgb(rgb2);
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    var res = {
      mode: "yiq",
      y: 0.29889531 * r2 + 0.58662247 * g + 0.11448223 * b,
      i: 0.59597799 * r2 - 0.2741761 * g - 0.32180189 * b,
      q: 0.21147017 * r2 - 0.52261711 * g + 0.31114694 * b
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertYiqToRgb = function(ref) {
    var y = ref.y;
    var i = ref.i;
    var q = ref.q;
    var alpha = ref.alpha;
    return convertLrgbToRgb({
      r: y + 0.95608445 * i + 0.6208885 * q,
      g: y - 0.27137664 * i - 0.6486059 * q,
      b: y - 1.10561724 * i + 1.70250126 * q,
      alpha
    });
  };
  var definition$2 = {
    mode: "yiq",
    output: {
      rgb: convertYiqToRgb
    },
    input: {
      rgb: convertRgbToYiq
    },
    channels: ["y", "i", "q", "alpha"],
    parsers: ["--yiq"],
    serialize: "color(--yiq ",
    ranges: {
      i: [-0.595, 0.595],
      q: [-0.522, 0.522]
    },
    interpolate: {
      y: interpolatorLinear,
      i: interpolatorLinear,
      q: interpolatorLinear,
      alpha: { use: interpolatorLinear, fixup: fixupAlpha }
    }
  };
  var convertOklabToLrgb = function(ref) {
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var alpha = ref.alpha;
    var L = Math.pow(l + 0.3963377774 * a + 0.2158037573 * b, 3);
    var M2 = Math.pow(l - 0.1055613458 * a - 0.0638541728 * b, 3);
    var S = Math.pow(l - 0.0894841775 * a - 1.291485548 * b, 3);
    var res = {
      mode: "lrgb",
      r: 4.0767416621 * L - 3.3077115913 * M2 + 0.2309699292 * S,
      g: -1.2684380046 * L + 2.6097574011 * M2 - 0.3413193965 * S,
      b: -0.0041960863 * L - 0.7034186147 * M2 + 1.707614701 * S
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertLrgbToOklab = function(ref) {
    var r2 = ref.r;
    var g = ref.g;
    var b = ref.b;
    var alpha = ref.alpha;
    var L = Math.cbrt(0.4122214708 * r2 + 0.5363325363 * g + 0.0514459929 * b);
    var M2 = Math.cbrt(0.2119034982 * r2 + 0.6806995451 * g + 0.1073969566 * b);
    var S = Math.cbrt(0.0883024619 * r2 + 0.2817188376 * g + 0.6299787005 * b);
    var res = {
      mode: "oklab",
      l: 0.2104542553 * L + 0.793617785 * M2 - 0.0040720468 * S,
      a: 1.9779984951 * L - 2.428592205 * M2 + 0.4505937099 * S,
      b: 0.0259040371 * L + 0.7827717662 * M2 - 0.808675766 * S
    };
    if (alpha !== void 0) {
      res.alpha = alpha;
    }
    return res;
  };
  var convertRgbToOklab = function(rgb2) {
    var res = convertLrgbToOklab(convertRgbToLrgb(rgb2));
    if (rgb2.r === rgb2.b && rgb2.b === rgb2.g) {
      res.a = res.b = 0;
    }
    return res;
  };
  var convertOklabToRgb = function(c4) {
    return convertLrgbToRgb(convertOklabToLrgb(c4));
  };
  var definition$1 = Object.assign(
    {},
    definition$d,
    {
      mode: "oklab",
      output: {
        lrgb: convertOklabToLrgb,
        rgb: convertOklabToRgb
      },
      input: {
        lrgb: convertLrgbToOklab,
        rgb: convertRgbToOklab
      },
      ranges: {
        l: [0, 0.999],
        a: [-0.233, 0.276],
        b: [-0.311, 0.198]
      },
      parsers: ["--oklab"],
      serialize: "color(--oklab "
    }
  );
  var definition = Object.assign(
    {},
    definition$b,
    {
      mode: "oklch",
      output: {
        oklab: function(c4) {
          return convertLchToLab(c4, "oklab");
        },
        rgb: function(c4) {
          return convertOklabToRgb(convertLchToLab(c4, "oklab"));
        }
      },
      input: {
        rgb: function(c4) {
          return convertLabToLch(convertRgbToOklab(c4), "oklch");
        },
        oklab: function(c4) {
          return convertLabToLch(c4, "oklch");
        }
      },
      parsers: ["--oklch"],
      serialize: "color(--oklch ",
      ranges: {
        l: [0, 0.999],
        c: [0, 0.322],
        h: [0, 360]
      }
    }
  );
  var r = function(value2, precision) {
    return Math.round(value2 * (precision = Math.pow(10, precision))) / precision;
  };
  var round = function(precision) {
    if (precision === void 0)
      precision = 4;
    return function(value2) {
      return typeof value2 === "number" ? r(value2, precision) : value2;
    };
  };
  var rgb$4 = converter("rgb");
  var hsl$1 = converter("hsl");
  var twoDecimals = round(2);
  var clamp$2 = function(value2) {
    return Math.max(0, Math.min(1, value2));
  };
  var fixup = function(value2) {
    return Math.round(clamp$2(value2) * 255);
  };
  var formatRgb = function(c4) {
    var color2 = rgb$4(c4);
    if (color2 === void 0) {
      return void 0;
    }
    var r2 = fixup(color2.r);
    var g = fixup(color2.g);
    var b = fixup(color2.b);
    if (color2.alpha === void 0 || color2.alpha === 1) {
      return "rgb(" + r2 + ", " + g + ", " + b + ")";
    } else {
      return "rgba(" + r2 + ", " + g + ", " + b + ", " + twoDecimals(clamp$2(color2.alpha)) + ")";
    }
  };
  var normalizePositions = function(arr) {
    if (arr[0] === void 0) {
      arr[0] = 0;
    }
    if (arr[arr.length - 1] === void 0) {
      arr[arr.length - 1] = 1;
    }
    var i = 1;
    var j;
    var from_idx;
    var from_pos;
    var inc;
    while (i < arr.length) {
      if (arr[i] === void 0) {
        from_idx = i;
        from_pos = arr[i - 1];
        j = i;
        while (arr[j] === void 0) {
          j++;
        }
        inc = (arr[j] - from_pos) / (j - i + 1);
        while (i < j) {
          arr[i] = from_pos + (i + 1 - from_idx) * inc;
          i++;
        }
      } else if (arr[i] < arr[i - 1]) {
        arr[i] = arr[i - 1];
      }
      i++;
    }
    return arr;
  };
  var midpoint = function(H) {
    if (H === void 0)
      H = 0.5;
    return function(t) {
      return H <= 0 ? 1 : H >= 1 ? 0 : Math.pow(t, Math.log(0.5) / Math.log(H));
    };
  };
  var mapper = function(fn2, mode, preserve_mode) {
    if (mode === void 0)
      mode = "rgb";
    if (preserve_mode === void 0)
      preserve_mode = false;
    var channels = mode ? getModeDefinition(mode).channels : null;
    var conv = mode ? converter(mode) : prepare;
    return function(color2) {
      var conv_color = conv(color2);
      var res = (channels || getModeDefinition(color2.mode).channels).reduce(
        function(res2, ch) {
          var v = fn2(conv_color[ch], ch, conv_color, mode);
          if (v !== void 0 && !isNaN(v)) {
            res2[ch] = v;
          }
          return res2;
        },
        { mode }
      );
      if (!preserve_mode) {
        return res;
      }
      var prep = prepare(color2);
      if (prep && prep.mode !== res.mode) {
        return converter(prep.mode)(res);
      }
      return res;
    };
  };
  var mapAlphaMultiply = function(v, ch, c4) {
    if (ch !== "alpha") {
      return (v || 0) * (c4.alpha !== void 0 ? c4.alpha : 1);
    }
    return v;
  };
  var mapAlphaDivide = function(v, ch, c4) {
    if (ch !== "alpha" && c4.alpha !== 0) {
      return (v || 0) / (c4.alpha !== void 0 ? c4.alpha : 1);
    }
    return v;
  };
  var isfn = function(o) {
    return typeof o === "function";
  };
  var isobj = function(o) {
    return o && typeof o === "object";
  };
  var isnum = function(o) {
    return typeof o === "number";
  };
  var interpolate_fn = function(colors, mode, overrides, premap) {
    if (mode === void 0)
      mode = "rgb";
    var def = getModeDefinition(mode);
    var conv = converter(mode);
    var conv_colors = [];
    var positions = [];
    var fns = {};
    colors.forEach(function(val) {
      if (Array.isArray(val)) {
        conv_colors.push(conv(val[0]));
        positions.push(val[1]);
      } else if (isnum(val) || isfn(val)) {
        fns[positions.length] = val;
      } else {
        conv_colors.push(conv(val));
        positions.push(void 0);
      }
    });
    normalizePositions(positions);
    var fixed = def.channels.reduce(function(res, ch) {
      var ffn;
      if (isobj(overrides) && isobj(overrides[ch]) && overrides[ch].fixup) {
        ffn = overrides[ch].fixup;
      } else if (isobj(def.interpolate[ch]) && def.interpolate[ch].fixup) {
        ffn = def.interpolate[ch].fixup;
      } else {
        ffn = function(v) {
          return v;
        };
      }
      res[ch] = ffn(conv_colors.map(function(color2) {
        return color2[ch];
      }));
      return res;
    }, {});
    if (premap) {
      var ccolors = conv_colors.map(function(color2, idx) {
        return def.channels.reduce(
          function(c4, ch) {
            c4[ch] = fixed[ch][idx];
            return c4;
          },
          { mode }
        );
      });
      fixed = def.channels.reduce(function(res, ch) {
        res[ch] = ccolors.map(function(c4) {
          var v = premap(c4[ch], ch, c4, mode);
          return isNaN(v) ? void 0 : v;
        });
        return res;
      }, {});
    }
    var interpolators = def.channels.reduce(function(res, ch) {
      var ifn;
      if (isfn(overrides)) {
        ifn = overrides;
      } else if (isobj(overrides) && isfn(overrides[ch])) {
        ifn = overrides[ch];
      } else if (isobj(overrides) && isobj(overrides[ch]) && overrides[ch].use) {
        ifn = overrides[ch].use;
      } else if (isfn(def.interpolate[ch])) {
        ifn = def.interpolate[ch];
      } else if (isobj(def.interpolate[ch])) {
        ifn = def.interpolate[ch].use;
      }
      res[ch] = ifn(fixed[ch]);
      return res;
    }, {});
    var n2 = conv_colors.length - 1;
    return function(t) {
      t = Math.min(Math.max(0, t), 1);
      if (t <= positions[0]) {
        return conv_colors[0];
      }
      if (t > positions[n2]) {
        return conv_colors[n2];
      }
      var idx = 0;
      while (positions[idx] < t) {
        idx++;
      }
      var start = positions[idx - 1];
      var delta = positions[idx] - start;
      var P = (t - start) / delta;
      var fn2 = fns[idx] || fns[0];
      if (fn2 !== void 0) {
        if (isnum(fn2)) {
          fn2 = midpoint((fn2 - start) / delta);
        }
        P = fn2(P);
      }
      var t0 = (idx - 1 + P) / n2;
      return def.channels.reduce(
        function(res, channel) {
          var val = interpolators[channel](t0);
          if (val !== void 0) {
            res[channel] = val;
          }
          return res;
        },
        { mode }
      );
    };
  };
  var interpolateWith = function(premap, postmap) {
    return function(colors, mode, overrides) {
      if (mode === void 0)
        mode = "rgb";
      var post = postmap ? mapper(postmap, mode) : void 0;
      var it = interpolate_fn(colors, mode, overrides, premap);
      return post ? function(t) {
        return post(it(t));
      } : it;
    };
  };
  var interpolateWithPremultipliedAlpha = interpolateWith(
    mapAlphaMultiply,
    mapAlphaDivide
  );
  var rgb$3 = converter("rgb");
  var rgb$2 = converter("rgb");
  var rgb$1 = converter("rgb");
  defineMode(definition$n);
  defineMode(definition$7);
  defineMode(definition$6);
  defineMode(definition$5);
  defineMode(definition$h);
  defineMode(definition$j);
  defineMode(definition$i);
  defineMode(definition$g);
  defineMode(definition$f);
  defineMode(definition$e);
  defineMode(definition$d);
  defineMode(definition$c);
  defineMode(definition$b);
  defineMode(definition$a);
  defineMode(definition$8);
  defineMode(definition$o);
  defineMode(definition$9);
  defineMode(definition$m);
  defineMode(definition$l);
  defineMode(definition$k);
  defineMode(definition$p);
  defineMode(definition$3);
  defineMode(definition$4);
  defineMode(definition$2);
  defineMode(definition$1);
  defineMode(definition);
  var a98 = converter("a98");
  var cubehelix = converter("cubehelix");
  var dlab = converter("dlab");
  var dlch = converter("dlch");
  var hsi = converter("hsi");
  var hsl = converter("hsl");
  var hsv = converter("hsv");
  var hwb = converter("hwb");
  var jab = converter("jab");
  var jch = converter("jch");
  var lab = converter("lab");
  var lab65 = converter("lab65");
  var lch = converter("lch");
  var lch65 = converter("lch65");
  var lchuv = converter("lchuv");
  var lrgb = converter("lrgb");
  var luv = converter("luv");
  var p3 = converter("p3");
  var prophoto = converter("prophoto");
  var rec2020 = converter("rec2020");
  var rgb = converter("rgb");
  var xyz = converter("xyz");
  var xyz65 = converter("xyz65");
  var yiq = converter("yiq");
  var oklab = converter("oklab");
  var oklch = converter("oklch");
  var doComplete = null;
  var extractAbbreviation = null;
  var isAbbreviationValid = null;
  function isObject22(variable) {
    return Object.prototype.toString.call(variable) === "[object Object]";
  }
  function removeMeta(obj) {
    let result = {};
    for (let key in obj) {
      if (key.substr(0, 2) === "__")
        continue;
      if (isObject22(obj[key])) {
        result[key] = removeMeta(obj[key]);
      } else {
        result[key] = obj[key];
      }
    }
    return result;
  }
  function rangesEqual(a, b) {
    return a.start.line === b.start.line && a.start.character === b.start.character && a.end.line === b.end.line && a.end.character === b.end.character;
  }
  function dedupe(arr) {
    return arr.filter((value2, index2, self2) => self2.indexOf(value2) === index2);
  }
  function dedupeByRange(arr) {
    return arr.filter((classList, classListIndex) => classListIndex === arr.findIndex((c4) => rangesEqual(c4.range, classList.range)));
  }
  function ensureArray(value2) {
    return Array.isArray(value2) ? value2 : [value2];
  }
  function flatten(arrays) {
    return [].concat.apply([], arrays);
  }
  function equal(a, b) {
    if (a === b)
      return true;
    if (a.length !== b.length)
      return false;
    let aSorted = a.concat().sort();
    let bSorted = b.concat().sort();
    for (let i = 0; i < aSorted.length; ++i) {
      if (aSorted[i] !== bSorted[i])
        return false;
    }
    return true;
  }
  function equalExact(a, b) {
    if (a === b)
      return true;
    if (a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; ++i) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  function combinations(str) {
    let fn2 = function(active, rest, a) {
      if (!active && !rest)
        return void 0;
      if (!rest) {
        a.push(active);
      } else {
        fn2(active + rest[0], rest.slice(1), a);
        fn2(active, rest.slice(1), a);
      }
      return a;
    };
    return fn2("", str, []);
  }
  function getClassNameParts(state, className) {
    let separator = state.separator;
    className = className.replace(/^\./, "");
    let parts = className.split(separator);
    if (parts.length === 1) {
      return (0, import_dlv3.default)(state.classNames.classNames, [className, "__info", "__rule"]) === true || Array.isArray((0, import_dlv3.default)(state.classNames.classNames, [className, "__info"])) ? [className] : null;
    }
    let points = combinations("123456789".substr(0, parts.length - 1)).map((x) => x.split("").map((x2) => parseInt(x2, 10)));
    let possibilities = [[className], ...points.map((p2) => {
      let result = [];
      let i = 0;
      p2.forEach((x) => {
        result.push(parts.slice(i, x).join("-"));
        i = x;
      });
      result.push(parts.slice(i).join("-"));
      return result;
    })];
    return possibilities.find((key) => {
      if ((0, import_dlv3.default)(state.classNames.classNames, [...key, "__info", "__rule"]) === true || Array.isArray((0, import_dlv3.default)(state.classNames.classNames, [...key, "__info"]))) {
        return true;
      }
      return false;
    });
  }
  function remToPx(value2, rootSize) {
    if (rootSize === void 0) {
      rootSize = 16;
    }
    if (/^-?[0-9.]+rem$/.test(value2)) {
      let number2 = parseFloat(value2.substr(0, value2.length - 3));
      if (!isNaN(number2)) {
        return `${number2 * rootSize}px`;
      }
    }
    return void 0;
  }
  function bigSign2(bigIntValue) {
    return (bigIntValue > 0n) - (bigIntValue < 0n);
  }
  function generateRules2(state, classNames) {
    let rules = state.modules.jit.generateRules.module(new Set(classNames), state.jitContext).sort((_ref, _ref2) => {
      let [a] = _ref;
      let [z] = _ref2;
      return bigSign2(a - z);
    });
    let root2 = state.modules.postcss.module.root({
      nodes: rules.map((_ref3) => {
        let [, rule2] = _ref3;
        return rule2;
      })
    });
    state.modules.jit.expandApplyAtRules.module(state.jitContext)(root2);
    let actualRules = [];
    root2.walkRules((subRule) => {
      actualRules.push(subRule);
    });
    return {
      root: root2,
      rules: actualRules
    };
  }
  async function stringifyRoot(state, root2, uri) {
    let settings = await state.editor.getConfiguration(uri);
    let clone = root2.clone();
    clone.walkAtRules("defaults", (node) => {
      node.remove();
    });
    if (settings.tailwindCSS.showPixelEquivalents) {
      clone.walkDecls((decl2) => {
        let px = remToPx(decl2.value, settings.tailwindCSS.rootFontSize);
        if (px) {
          decl2.value = `${decl2.value}/* ${px} */`;
        }
      });
    }
    return clone.toString().replace(/([^;{}\s])(\n\s*})/g, (_match, before, after) => `${before};${after}`).replace(/^(?:    )+/gm, (indent) => " ".repeat(indent.length / 4 * settings.editor.tabSize));
  }
  async function stringifyDecls(state, rule2, uri) {
    let settings = await state.editor.getConfiguration(uri);
    let result = [];
    rule2.walkDecls((_ref4) => {
      let {
        prop,
        value: value2
      } = _ref4;
      let px = settings.tailwindCSS.showPixelEquivalents ? remToPx(value2, settings.tailwindCSS.rootFontSize) : void 0;
      result.push(`${prop}: ${value2}${px ? `/* ${px} */` : ""};`);
    });
    return result.join(" ");
  }
  function replaceClassName(state, selector, find, replace2) {
    const transform = (selectors) => {
      selectors.walkClasses((className) => {
        if (className.value === find) {
          className.value = replace2;
        }
      });
    };
    return state.modules.postcssSelectorParser.module(transform).processSync(selector);
  }
  function getRuleContext(state, rule2, className) {
    let context = [replaceClassName(state, rule2.selector, className, "__placeholder__")];
    let p2 = rule2;
    while (p2.parent && p2.parent.type !== "root") {
      p2 = p2.parent;
      if (p2.type === "atrule") {
        context.unshift(`@${p2.name} ${p2.params}`);
      }
    }
    return context;
  }
  var COLOR_PROPS = ["accent-color", "caret-color", "color", "column-rule-color", "background-color", "border-color", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "fill", "outline-color", "stop-color", "stroke", "text-decoration-color"];
  function getKeywordColor(value2) {
    if (typeof value2 !== "string")
      return null;
    let lowercased = value2.toLowerCase();
    if (lowercased === "transparent") {
      return "transparent";
    }
    if (lowercased === "currentcolor") {
      return "currentColor";
    }
    return null;
  }
  var colorRegex = /* @__PURE__ */ new RegExp(`(?:^|\\s|\\(|,)(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\(\\s*(-?[\\d.]+%?(\\s*[,/]\\s*|\\s+)+){2,3}\\s*([\\d.]+%?|var\\([^)]+\\))?\\)|transparent|currentColor|${/* @__PURE__ */ Object.keys(color_name_default).join("|")})(?:$|\\s|\\)|,)`, "gi");
  function replaceColorVarsWithTheirDefaults(str) {
    return str.replace(/((?:rgb|hsl)a?\(\s*)var\([^,]+,\s*([^)]+)\)/gi, "$1$2");
  }
  function getColorsInString(str) {
    if (/(?:box|drop)-shadow/.test(str))
      return [];
    return Array.from(replaceColorVarsWithTheirDefaults(str).matchAll(colorRegex), (match) => {
      var _getKeywordColor;
      let color2 = match[1].replace(/var\([^)]+\)/, "1");
      return (_getKeywordColor = getKeywordColor(color2)) != null ? _getKeywordColor : parse3(color2);
    }).filter(Boolean);
  }
  function getColorFromDecls(decls) {
    let props = Object.keys(decls).filter((prop) => {
      if (prop === "content" && (decls[prop] === '""' || decls[prop] === "''" || decls[prop] === "var(--tw-content)")) {
        return false;
      }
      return true;
    });
    if (props.length === 0)
      return null;
    const nonCustomProps = props.filter((prop) => !prop.startsWith("--"));
    const areAllCustom = nonCustomProps.length === 0;
    if (!areAllCustom && nonCustomProps.some((prop) => !COLOR_PROPS.includes(prop))) {
      return null;
    }
    const propsToCheck = areAllCustom ? props : nonCustomProps;
    const colors = propsToCheck.flatMap((prop) => ensureArray(decls[prop]).flatMap(getColorsInString));
    const colorStrings = dedupe(colors.map((color2) => typeof color2 === "string" ? color2 : formatRgb({
      ...color2,
      alpha: void 0
    })));
    if (colorStrings.length !== 1) {
      return null;
    }
    let keyword = getKeywordColor(colorStrings[0]);
    if (keyword) {
      return keyword;
    }
    const nonKeywordColors = colors.filter((color2) => typeof color2 !== "string");
    const alphas = dedupe(nonKeywordColors.map((color2) => {
      var _color$alpha;
      return (_color$alpha = color2.alpha) != null ? _color$alpha : 1;
    }));
    if (alphas.length === 1) {
      return nonKeywordColors[0];
    }
    if (alphas.length === 2 && alphas.includes(0)) {
      return nonKeywordColors.find((color2) => {
        var _color$alpha2;
        return ((_color$alpha2 = color2.alpha) != null ? _color$alpha2 : 1) !== 0;
      });
    }
    return null;
  }
  function getColor(state, className) {
    if (state.jit) {
      if (state.classNames) {
        const item2 = (0, import_dlv3.default)(state.classNames.classNames, [className, "__info"]);
        if (item2 && item2.__rule) {
          return getColorFromDecls(removeMeta(item2));
        }
      }
      let {
        root: root2,
        rules
      } = generateRules2(state, [className]);
      if (rules.length === 0)
        return null;
      let decls = {};
      root2.walkDecls((decl2) => {
        let value2 = decls[decl2.prop];
        if (value2) {
          if (Array.isArray(value2)) {
            value2.push(decl2.value);
          } else {
            decls[decl2.prop] = [value2, decl2.value];
          }
        } else {
          decls[decl2.prop] = decl2.value;
        }
      });
      return getColorFromDecls(decls);
    }
    let parts = getClassNameParts(state, className);
    if (!parts)
      return null;
    const item = (0, import_dlv3.default)(state.classNames.classNames, [...parts, "__info"]);
    if (!item.__rule)
      return null;
    return getColorFromDecls(removeMeta(item));
  }
  function getColorFromValue(value2) {
    if (typeof value2 !== "string")
      return null;
    const trimmedValue = value2.trim();
    if (trimmedValue.toLowerCase() === "transparent") {
      return "transparent";
    }
    if (trimmedValue.toLowerCase() === "currentcolor") {
      return "currentColor";
    }
    if (!/^\s*(?:rgba?|hsla?)\s*\([^)]+\)\s*$/.test(trimmedValue) && !/^\s*#[0-9a-f]+\s*$/i.test(trimmedValue) && !Object.keys(color_name_default).includes(trimmedValue)) {
      return null;
    }
    const color2 = parse3(trimmedValue);
    return color2 != null ? color2 : null;
  }
  var toRgb = /* @__PURE__ */ converter("rgb");
  function culoriColorToVscodeColor(color2) {
    var _rgb$alpha;
    let rgb2 = toRgb(color2);
    return {
      red: rgb2.r,
      green: rgb2.g,
      blue: rgb2.b,
      alpha: (_rgb$alpha = rgb2.alpha) != null ? _rgb$alpha : 1
    };
  }
  var htmlLanguages = ["aspnetcorerazor", "astro", "astro-markdown", "blade", "django-html", "edge", "ejs", "erb", "gohtml", "GoHTML", "gohtmltmpl", "haml", "handlebars", "hbs", "html", "HTML (Eex)", "HTML (EEx)", "html-eex", "htmldjango", "jade", "leaf", "liquid", "markdown", "mdx", "mustache", "njk", "nunjucks", "phoenix-heex", "php", "razor", "slim", "surface", "twig"];
  var cssLanguages = ["css", "less", "postcss", "sass", "scss", "stylus", "sugarss", "tailwindcss"];
  var jsLanguages = ["javascript", "javascriptreact", "reason", "rescript", "typescript", "typescriptreact"];
  function isJsDoc(state, doc) {
    const userJsLanguages = Object.keys(state.editor.userLanguages).filter((lang) => jsLanguages.includes(state.editor.userLanguages[lang]));
    return [...jsLanguages, ...userJsLanguages].indexOf(doc.languageId) !== -1;
  }
  function isJsxContext(state, doc, position2) {
    let str = doc.getText({
      start: {
        line: 0,
        character: 0
      },
      end: position2
    });
    let boundaries = getLanguageBoundaries(state, doc, str);
    return boundaries ? boundaries[boundaries.length - 1].type === "jsx" : false;
  }
  function isCssDoc(state, doc) {
    const userCssLanguages = Object.keys(state.editor.userLanguages).filter((lang) => cssLanguages.includes(state.editor.userLanguages[lang]));
    return [...cssLanguages, ...userCssLanguages].indexOf(doc.languageId) !== -1;
  }
  function isCssContext(state, doc, position2) {
    if (isCssDoc(state, doc)) {
      return true;
    }
    if (isHtmlDoc(state, doc) || isVueDoc(doc) || isSvelteDoc(doc) || isJsDoc(state, doc)) {
      let str = doc.getText({
        start: {
          line: 0,
          character: 0
        },
        end: position2
      });
      let boundaries = getLanguageBoundaries(state, doc, str);
      return boundaries ? boundaries[boundaries.length - 1].type === "css" : false;
    }
    return false;
  }
  function isWithinRange(position2, range) {
    if (position2.line === range.start.line && position2.character >= range.start.character) {
      if (position2.line === range.end.line && position2.character > range.end.character) {
        return false;
      } else {
        return true;
      }
    }
    if (position2.line === range.end.line && position2.character <= range.end.character) {
      if (position2.line === range.start.line && position2.character < range.end.character) {
        return false;
      } else {
        return true;
      }
    }
    if (position2.line > range.start.line && position2.line < range.end.line) {
      return true;
    }
    return false;
  }
  var lazy = (getter) => {
    let evaluated = false;
    let _res = null;
    const res = function() {
      if (evaluated)
        return _res;
      _res = getter.apply(this, arguments);
      evaluated = true;
      return _res;
    };
    res.isLazy = true;
    return res;
  };
  var classAttributeStates = () => ({
    doubleClassList: {
      arb: {
        match: new RegExp("(?<!\\\\)\\["),
        push: "arbitrary"
      },
      lbrace: {
        match: new RegExp("(?<!\\\\)\\{"),
        push: "interpBrace"
      },
      rbrace: {
        match: new RegExp("(?<!\\\\)\\}"),
        pop: 1
      },
      end: {
        match: new RegExp('(?<!\\\\)"'),
        pop: 1
      },
      classlist: {
        match: new RegExp("[\\s\\S]"),
        lineBreaks: true
      }
    },
    singleClassList: {
      lbrace: {
        match: new RegExp("(?<!\\\\)\\{"),
        push: "interpBrace"
      },
      rbrace: {
        match: new RegExp("(?<!\\\\)\\}"),
        pop: 1
      },
      end: {
        match: new RegExp("(?<!\\\\)'"),
        pop: 1
      },
      classlist: {
        match: new RegExp("[\\s\\S]"),
        lineBreaks: true
      }
    },
    tickClassList: {
      lbrace: {
        match: new RegExp("(?<=(?<!\\\\)\\$)\\{"),
        push: "interpBrace"
      },
      rbrace: {
        match: new RegExp("(?<!\\\\)\\}"),
        pop: 1
      },
      end: {
        match: new RegExp("(?<!\\\\)`"),
        pop: 1
      },
      classlist: {
        match: new RegExp("[\\s\\S]"),
        lineBreaks: true
      }
    },
    interpBrace: {
      startSingle: {
        match: new RegExp("(?<!\\\\)'"),
        push: "singleClassList"
      },
      startDouble: {
        match: new RegExp('(?<!\\\\)"'),
        push: "doubleClassList"
      },
      startTick: {
        match: new RegExp("(?<!\\\\)`"),
        push: "tickClassList"
      },
      lbrace: {
        match: new RegExp("(?<!\\\\)\\{"),
        push: "interpBrace"
      },
      rbrace: {
        match: new RegExp("(?<!\\\\)\\}"),
        pop: 1
      },
      text: {
        match: new RegExp("[\\s\\S]"),
        lineBreaks: true
      }
    },
    interpSingle: {
      startDouble: {
        match: new RegExp('(?<!\\\\)"'),
        push: "doubleClassList"
      },
      startTick: {
        match: new RegExp("(?<!\\\\)`"),
        push: "tickClassList"
      },
      single: {
        match: new RegExp("(?<!\\\\)'"),
        pop: 1
      },
      text: {
        match: new RegExp("[\\s\\S]"),
        lineBreaks: true
      }
    },
    interpDouble: {
      startSingle: {
        match: new RegExp("(?<!\\\\)'"),
        push: "singleClassList"
      },
      startTick: {
        match: new RegExp("(?<!\\\\)`"),
        push: "tickClassList"
      },
      double: {
        match: new RegExp('(?<!\\\\)"'),
        pop: 1
      },
      text: {
        match: new RegExp("[\\s\\S]"),
        lineBreaks: true
      }
    },
    arbitrary: {
      arb: {
        match: new RegExp("(?<!\\\\)\\]"),
        pop: 1
      },
      space: {
        match: /\s/,
        pop: 1,
        lineBreaks: true
      },
      arb2: {
        match: new RegExp("[\\s\\S]"),
        lineBreaks: true
      }
    }
  });
  var simpleClassAttributeStates = {
    main: {
      start: {
        match: '"',
        push: "doubleClassList"
      }
    },
    doubleClassList: {
      end: {
        match: '"',
        pop: 1
      },
      classlist: {
        match: /[\s\S]/,
        lineBreaks: true
      }
    }
  };
  var getClassAttributeLexer = /* @__PURE__ */ lazy(() => {
    let supportsNegativeLookbehind = true;
    try {
      new RegExp("(?<!)");
    } catch (_) {
      supportsNegativeLookbehind = false;
    }
    if (supportsNegativeLookbehind) {
      return import_moo.default.states({
        main: {
          start1: {
            match: '"',
            push: "doubleClassList"
          },
          start2: {
            match: "'",
            push: "singleClassList"
          },
          start3: {
            match: "{",
            push: "interpBrace"
          }
        },
        ...classAttributeStates()
      });
    }
    return import_moo.default.states(simpleClassAttributeStates);
  });
  var getComputedClassAttributeLexer = /* @__PURE__ */ lazy(() => {
    let supportsNegativeLookbehind = true;
    try {
      new RegExp("(?<!)");
    } catch (_) {
      supportsNegativeLookbehind = false;
    }
    if (supportsNegativeLookbehind) {
      return import_moo.default.states({
        main: {
          lbrace: {
            match: "{",
            push: "interpBrace"
          },
          single: {
            match: "'",
            push: "interpSingle"
          },
          double: {
            match: '"',
            push: "interpDouble"
          }
        },
        ...classAttributeStates()
      });
    }
    return import_moo.default.states(simpleClassAttributeStates);
  });
  function resolveRange(range, relativeTo) {
    return {
      start: {
        line: ((relativeTo == null ? void 0 : relativeTo.start.line) || 0) + range.start.line,
        character: (range.end.line === 0 ? (relativeTo == null ? void 0 : relativeTo.start.character) || 0 : 0) + range.start.character
      },
      end: {
        line: ((relativeTo == null ? void 0 : relativeTo.start.line) || 0) + range.end.line,
        character: (range.end.line === 0 ? (relativeTo == null ? void 0 : relativeTo.start.character) || 0 : 0) + range.end.character
      }
    };
  }
  function getTextWithoutComments(docOrText, type, range) {
    let text2 = typeof docOrText === "string" ? docOrText : docOrText.getText(range);
    if (type === "js" || type === "jsx") {
      return getJsWithoutComments(text2);
    }
    if (type === "css") {
      return text2.replace(/\/\*.*?\*\//gs, replace);
    }
    return text2.replace(/<!--.*?-->/gs, replace);
  }
  function replace(match) {
    return match.replace(/./gs, (char) => char === "\n" ? "\n" : " ");
  }
  var jsLexer;
  function getJsWithoutComments(text2) {
    if (!jsLexer) {
      jsLexer = import_moo.default.states({
        main: {
          commentLine: /\/\/.*?$/,
          commentBlock: {
            match: /\/\*[^]*?\*\//,
            lineBreaks: true
          },
          stringDouble: /"(?:[^"\\]|\\.)*"/,
          stringSingle: /'(?:[^'\\]|\\.)*'/,
          stringBacktick: /`(?:[^`\\]|\\.)*`/,
          other: {
            match: /[^]/,
            lineBreaks: true
          }
        }
      });
    }
    let str = "";
    jsLexer.reset(text2);
    for (let token of jsLexer) {
      if (token.type === "commentLine") {
        str += " ".repeat(token.value.length);
      } else if (token.type === "commentBlock") {
        str += token.value.replace(/./g, " ");
      } else {
        str += token.value;
      }
    }
    return str;
  }
  function findAll(re, str) {
    let match;
    let matches = [];
    while ((match = re.exec(str)) !== null) {
      matches.push({
        ...match
      });
    }
    return matches;
  }
  function findLast(re, str) {
    const matches = findAll(re, str);
    if (matches.length === 0) {
      return null;
    }
    return matches[matches.length - 1];
  }
  function getClassNamesInClassList(_ref) {
    let {
      classList,
      range,
      important
    } = _ref;
    const parts = classList.split(/(\s+)/);
    const names = [];
    let index2 = 0;
    for (let i = 0; i < parts.length; i++) {
      if (i % 2 === 0) {
        const start = indexToPosition(classList, index2);
        const end = indexToPosition(classList, index2 + parts[i].length);
        names.push({
          className: parts[i],
          classList: {
            classList,
            range,
            important
          },
          relativeRange: {
            start,
            end
          },
          range: {
            start: {
              line: range.start.line + start.line,
              character: (end.line === 0 ? range.start.character : 0) + start.character
            },
            end: {
              line: range.start.line + end.line,
              character: (end.line === 0 ? range.start.character : 0) + end.character
            }
          }
        });
      }
      index2 += parts[i].length;
    }
    return names;
  }
  async function findClassNamesInRange(state, doc, range, mode, includeCustom) {
    if (includeCustom === void 0) {
      includeCustom = true;
    }
    const classLists = await findClassListsInRange(state, doc, range, mode, includeCustom);
    return flatten(classLists.map(getClassNamesInClassList));
  }
  function findClassListsInCssRange(doc, range) {
    const text2 = getTextWithoutComments(doc, "css", range);
    const matches = findAll(/(@apply\s+)(?<classList>[^;}]+?)(?<important>\s*!important)?\s*[;}]/g, text2);
    const globalStart = range ? range.start : {
      line: 0,
      character: 0
    };
    return matches.map((match) => {
      const start = indexToPosition(text2, match.index + match[1].length);
      const end = indexToPosition(text2, match.index + match[1].length + match.groups.classList.length);
      return {
        classList: match.groups.classList,
        important: Boolean(match.groups.important),
        range: {
          start: {
            line: globalStart.line + start.line,
            character: (end.line === 0 ? globalStart.character : 0) + start.character
          },
          end: {
            line: globalStart.line + end.line,
            character: (end.line === 0 ? globalStart.character : 0) + end.character
          }
        }
      };
    });
  }
  async function findCustomClassLists(state, doc, range) {
    const settings = await state.editor.getConfiguration(doc.uri);
    const regexes = settings.tailwindCSS.experimental.classRegex;
    if (!Array.isArray(regexes) || regexes.length === 0)
      return [];
    const text2 = doc.getText(range);
    const result = [];
    for (let i = 0; i < regexes.length; i++) {
      try {
        let [containerRegexString, classRegexString] = Array.isArray(regexes[i]) ? regexes[i] : [regexes[i]];
        let containerRegex = new import_becke_ch_regex_s0_0_v1_base_pl_lib.default(containerRegexString, "g");
        let containerMatch;
        while ((containerMatch = containerRegex.exec(text2)) !== null) {
          const searchStart = doc.offsetAt((range == null ? void 0 : range.start) || {
            line: 0,
            character: 0
          });
          const matchStart = searchStart + containerMatch.index[1];
          const matchEnd = matchStart + containerMatch[1].length;
          if (classRegexString) {
            let classRegex = new import_becke_ch_regex_s0_0_v1_base_pl_lib.default(classRegexString, "g");
            let classMatch;
            while ((classMatch = classRegex.exec(containerMatch[1])) !== null) {
              const classMatchStart = matchStart + classMatch.index[1];
              const classMatchEnd = classMatchStart + classMatch[1].length;
              result.push({
                classList: classMatch[1],
                range: {
                  start: doc.positionAt(classMatchStart),
                  end: doc.positionAt(classMatchEnd)
                }
              });
            }
          } else {
            result.push({
              classList: containerMatch[1],
              range: {
                start: doc.positionAt(matchStart),
                end: doc.positionAt(matchEnd)
              }
            });
          }
        }
      } catch (_) {
      }
    }
    return result;
  }
  function matchClassAttributes(text2, attributes) {
    const attrs = attributes.filter((x) => typeof x === "string").flatMap((a) => [a, `\\[${a}\\]`]);
    const re = /(?:\s|:|\()(ATTRS)\s*=\s*['"`{]/;
    return findAll(new RegExp(re.source.replace("ATTRS", attrs.join("|")), "gi"), text2);
  }
  async function findClassListsInHtmlRange(state, doc, type, range) {
    const text2 = getTextWithoutComments(doc, type, range);
    const matches = matchClassAttributes(text2, (await state.editor.getConfiguration(doc.uri)).tailwindCSS.classAttributes);
    const result = [];
    matches.forEach((match) => {
      const subtext = text2.substr(match.index + match[0].length - 1);
      let lexer = match[0][0] === ":" || match[1].startsWith("[") && match[1].endsWith("]") ? getComputedClassAttributeLexer() : getClassAttributeLexer();
      lexer.reset(subtext);
      let classLists = [];
      let currentClassList;
      try {
        for (let token of lexer) {
          if (token.type === "classlist" || token.type.startsWith("arb")) {
            if (currentClassList) {
              currentClassList.value += token.value;
            } else {
              currentClassList = {
                value: token.value,
                offset: token.offset
              };
            }
          } else {
            if (currentClassList) {
              classLists.push({
                value: currentClassList.value,
                offset: currentClassList.offset
              });
            }
            currentClassList = void 0;
          }
        }
      } catch (_) {
      }
      if (currentClassList) {
        classLists.push({
          value: currentClassList.value,
          offset: currentClassList.offset
        });
      }
      result.push(...classLists.map((_ref2) => {
        let {
          value: value2,
          offset
        } = _ref2;
        if (value2.trim() === "") {
          return null;
        }
        const before = value2.match(/^\s*/);
        const beforeOffset = before === null ? 0 : before[0].length;
        const after = value2.match(/\s*$/);
        const afterOffset = after === null ? 0 : -after[0].length;
        const start = indexToPosition(text2, match.index + match[0].length - 1 + offset + beforeOffset);
        const end = indexToPosition(text2, match.index + match[0].length - 1 + offset + value2.length + afterOffset);
        return {
          classList: value2.substr(beforeOffset, value2.length + afterOffset),
          range: {
            start: {
              line: ((range == null ? void 0 : range.start.line) || 0) + start.line,
              character: (end.line === 0 ? (range == null ? void 0 : range.start.character) || 0 : 0) + start.character
            },
            end: {
              line: ((range == null ? void 0 : range.start.line) || 0) + end.line,
              character: (end.line === 0 ? (range == null ? void 0 : range.start.character) || 0 : 0) + end.character
            }
          }
        };
      }).filter((x) => x !== null));
    });
    return result;
  }
  async function findClassListsInRange(state, doc, range, mode, includeCustom) {
    if (includeCustom === void 0) {
      includeCustom = true;
    }
    let classLists;
    if (mode === "css") {
      classLists = findClassListsInCssRange(doc, range);
    } else {
      classLists = await findClassListsInHtmlRange(state, doc, mode, range);
    }
    return dedupeByRange([...classLists, ...includeCustom ? await findCustomClassLists(state, doc, range) : []]);
  }
  async function findClassListsInDocument(state, doc) {
    if (isCssDoc(state, doc)) {
      return findClassListsInCssRange(doc);
    }
    let boundaries = getLanguageBoundaries(state, doc);
    if (!boundaries)
      return [];
    return dedupeByRange(flatten([...await Promise.all(boundaries.filter((b) => b.type === "html" || b.type === "jsx").map((_ref3) => {
      let {
        type,
        range
      } = _ref3;
      return findClassListsInHtmlRange(state, doc, type === "html" ? "html" : "jsx", range);
    })), ...boundaries.filter((b) => b.type === "css").map((_ref4) => {
      let {
        range
      } = _ref4;
      return findClassListsInCssRange(doc, range);
    }), await findCustomClassLists(state, doc)]));
  }
  function findHelperFunctionsInDocument(state, doc) {
    if (isCssDoc(state, doc)) {
      return findHelperFunctionsInRange(doc);
    }
    let boundaries = getLanguageBoundaries(state, doc);
    if (!boundaries)
      return [];
    return flatten(boundaries.filter((b) => b.type === "css").map((_ref5) => {
      let {
        range
      } = _ref5;
      return findHelperFunctionsInRange(doc, range);
    }));
  }
  function findHelperFunctionsInRange(doc, range) {
    const text2 = getTextWithoutComments(doc, "css", range);
    let matches = findAll(/(?<prefix>[\s:;/*(){}])(?<helper>config|theme)(?<innerPrefix>\(\s*)(?<path>[^)]*?)\s*\)/g, text2);
    return matches.map((match) => {
      let quotesBefore = "";
      let path = match.groups.path.replace(/['"]+$/, "").replace(/^['"]+/, (m) => {
        quotesBefore = m;
        return "";
      });
      let matches2 = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
      if (matches2) {
        path = matches2[1];
      }
      path = path.replace(/['"]*\s*$/, "");
      let startIndex = match.index + match.groups.prefix.length + match.groups.helper.length + match.groups.innerPrefix.length;
      return {
        helper: match.groups.helper === "theme" ? "theme" : "config",
        path,
        ranges: {
          full: resolveRange({
            start: indexToPosition(text2, startIndex),
            end: indexToPosition(text2, startIndex + match.groups.path.length)
          }, range),
          path: resolveRange({
            start: indexToPosition(text2, startIndex + quotesBefore.length),
            end: indexToPosition(text2, startIndex + quotesBefore.length + path.length)
          }, range)
        }
      };
    });
  }
  function indexToPosition(str, index2) {
    const {
      line,
      col
    } = (0, import_line_column.default)(str + "\n", index2);
    return {
      line: line - 1,
      character: col - 1
    };
  }
  async function findClassNameAtPosition(state, doc, position2) {
    let classNames = [];
    const positionOffset = doc.offsetAt(position2);
    const searchRange = {
      start: doc.positionAt(Math.max(0, positionOffset - 1e3)),
      end: doc.positionAt(positionOffset + 1e3)
    };
    if (isCssContext(state, doc, position2)) {
      classNames = await findClassNamesInRange(state, doc, searchRange, "css");
    } else if (isHtmlContext(state, doc, position2)) {
      classNames = await findClassNamesInRange(state, doc, searchRange, "html");
    } else if (isJsxContext(state, doc, position2)) {
      classNames = await findClassNamesInRange(state, doc, searchRange, "jsx");
    }
    if (classNames.length === 0) {
      return null;
    }
    const className = classNames.find((_ref6) => {
      let {
        range
      } = _ref6;
      return isWithinRange(position2, range);
    });
    if (!className)
      return null;
    return className;
  }
  var htmlScriptTypes = [
    // https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html#option-1-use-script-tag
    "text/html",
    // https://vuejs.org/guide/essentials/component-basics.html#dom-template-parsing-caveats
    "text/x-template",
    // https://github.com/tailwindlabs/tailwindcss-intellisense/issues/722
    "text/x-handlebars-template"
  ];
  var text = {
    text: {
      match: /[^]/,
      lineBreaks: true
    }
  };
  var states = {
    main: {
      cssBlockStart: {
        match: /<style(?=[>\s])/,
        push: "cssBlock"
      },
      jsBlockStart: {
        match: "<script",
        push: "jsBlock"
      },
      ...text
    },
    cssBlock: {
      styleStart: {
        match: ">",
        next: "style"
      },
      cssBlockEnd: {
        match: "/>",
        pop: 1
      },
      attrStartDouble: {
        match: '"',
        push: "attrDouble"
      },
      attrStartSingle: {
        match: "'",
        push: "attrSingle"
      },
      interp: {
        match: "{",
        push: "interp"
      },
      ...text
    },
    jsBlock: {
      scriptStart: {
        match: ">",
        next: "script"
      },
      jsBlockEnd: {
        match: "/>",
        pop: 1
      },
      langAttrStartDouble: {
        match: 'lang="',
        push: "langAttrDouble"
      },
      langAttrStartSingle: {
        match: "lang='",
        push: "langAttrSingle"
      },
      typeAttrStartDouble: {
        match: 'type="',
        push: "typeAttrDouble"
      },
      typeAttrStartSingle: {
        match: "type='",
        push: "typeAttrSingle"
      },
      attrStartDouble: {
        match: '"',
        push: "attrDouble"
      },
      attrStartSingle: {
        match: "'",
        push: "attrSingle"
      },
      interp: {
        match: "{",
        push: "interp"
      },
      ...text
    },
    interp: {
      interp: {
        match: "{",
        push: "interp"
      },
      end: {
        match: "}",
        pop: 1
      },
      ...text
    },
    langAttrDouble: {
      langAttrEnd: {
        match: '"',
        pop: 1
      },
      lang: {
        match: /[^"]+/,
        lineBreaks: true
      }
    },
    langAttrSingle: {
      langAttrEnd: {
        match: "'",
        pop: 1
      },
      lang: {
        match: /[^']+/,
        lineBreaks: true
      }
    },
    typeAttrDouble: {
      langAttrEnd: {
        match: '"',
        pop: 1
      },
      type: {
        match: /[^"]+/,
        lineBreaks: true
      }
    },
    typeAttrSingle: {
      langAttrEnd: {
        match: "'",
        pop: 1
      },
      type: {
        match: /[^']+/,
        lineBreaks: true
      }
    },
    attrDouble: {
      attrEnd: {
        match: '"',
        pop: 1
      },
      ...text
    },
    attrSingle: {
      attrEnd: {
        match: "'",
        pop: 1
      },
      ...text
    },
    style: {
      cssBlockEnd: {
        match: "</style>",
        pop: 1
      },
      ...text
    },
    script: {
      jsBlockEnd: {
        match: "<\/script>",
        pop: 1
      },
      ...text
    }
  };
  var vueStates = {
    ...states,
    main: {
      htmlBlockStart: {
        match: "<template",
        push: "htmlBlock"
      },
      ...states.main
    },
    htmlBlock: {
      htmlStart: {
        match: ">",
        next: "html"
      },
      htmlBlockEnd: {
        match: "/>",
        pop: 1
      },
      attrStartDouble: {
        match: '"',
        push: "attrDouble"
      },
      attrStartSingle: {
        match: "'",
        push: "attrSingle"
      },
      interp: {
        match: "{",
        push: "interp"
      },
      ...text
    },
    html: {
      htmlBlockEnd: {
        match: "</template>",
        pop: 1
      },
      nestedBlockStart: {
        match: "<template",
        push: "nestedBlock"
      },
      ...text
    },
    nestedBlock: {
      nestedStart: {
        match: ">",
        next: "nested"
      },
      nestedBlockEnd: {
        match: "/>",
        pop: 1
      },
      ...text
    },
    nested: {
      nestedBlockEnd: {
        match: "</template>",
        pop: 1
      },
      nestedBlockStart: {
        match: "<template",
        push: "nestedBlock"
      },
      ...text
    }
  };
  var defaultLexer = /* @__PURE__ */ import_moo.default.states(states);
  var vueLexer = /* @__PURE__ */ import_moo.default.states(vueStates);
  var cache2 = /* @__PURE__ */ new import_tmp_cache.default({
    max: 25,
    maxAge: 1e3
  });
  function getLanguageBoundaries(state, doc, text2) {
    if (text2 === void 0) {
      text2 = doc.getText();
    }
    let cacheKey = `${doc.languageId}:${text2}`;
    let cachedBoundaries = cache2.get(cacheKey);
    if (cachedBoundaries !== void 0) {
      return cachedBoundaries;
    }
    let isJs = isJsDoc(state, doc);
    let defaultType = isVueDoc(doc) ? "none" : isHtmlDoc(state, doc) || isSvelteDoc(doc) ? "html" : isJs ? "jsx" : null;
    if (defaultType === null) {
      cache2.set(cacheKey, null);
      return null;
    }
    text2 = getTextWithoutComments(text2, isJs ? "js" : "html");
    let lexer = defaultType === "none" ? vueLexer : defaultLexer;
    lexer.reset(text2);
    let type = defaultType;
    let boundaries = [{
      type: defaultType,
      range: {
        start: {
          line: 0,
          character: 0
        },
        end: void 0
      }
    }];
    let offset = 0;
    try {
      for (let token of lexer) {
        if (!token.type.startsWith("nested")) {
          if (token.type.endsWith("BlockStart")) {
            let position2 = indexToPosition(text2, offset);
            if (!boundaries[boundaries.length - 1].range.end) {
              boundaries[boundaries.length - 1].range.end = position2;
            }
            type = token.type.replace(/BlockStart$/, "");
            boundaries.push({
              type,
              range: {
                start: position2,
                end: void 0
              }
            });
          } else if (token.type.endsWith("BlockEnd")) {
            let position2 = indexToPosition(text2, offset);
            boundaries[boundaries.length - 1].range.end = position2;
            boundaries.push({
              type: defaultType,
              range: {
                start: position2,
                end: void 0
              }
            });
          } else if (token.type === "lang") {
            boundaries[boundaries.length - 1].type = token.text;
          } else if (token.type === "type" && htmlScriptTypes.includes(token.text)) {
            boundaries[boundaries.length - 1].type = "html";
          }
        }
        offset += token.text.length;
      }
    } catch {
      cache2.set(cacheKey, null);
      return null;
    }
    if (!boundaries[boundaries.length - 1].range.end) {
      boundaries[boundaries.length - 1].range.end = indexToPosition(text2, offset);
    }
    cache2.set(cacheKey, boundaries);
    return boundaries;
  }
  function isHtmlDoc(state, doc) {
    const userHtmlLanguages = Object.keys(state.editor.userLanguages).filter((lang) => htmlLanguages.includes(state.editor.userLanguages[lang]));
    return [...htmlLanguages, ...userHtmlLanguages].indexOf(doc.languageId) !== -1;
  }
  function isVueDoc(doc) {
    return doc.languageId === "vue";
  }
  function isSvelteDoc(doc) {
    return doc.languageId === "svelte";
  }
  function isHtmlContext(state, doc, position2) {
    let str = doc.getText({
      start: {
        line: 0,
        character: 0
      },
      end: position2
    });
    let boundaries = getLanguageBoundaries(state, doc, str);
    return boundaries ? boundaries[boundaries.length - 1].type === "html" : false;
  }
  function stringifyConfigValue(x) {
    if (isObject22(x))
      return `${Object.keys(x).length} values`;
    if (typeof x === "function")
      return "\u0192";
    return stringifyObject(x, {
      inlineCharacterLimit: Infinity,
      singleQuotes: false,
      transform: (obj, prop, originalResult) => {
        if (typeof obj[prop] === "function") {
          return "\u0192";
        }
        return originalResult;
      }
    });
  }
  function stringifyCss(className, obj, settings) {
    if (obj.__rule !== true && !Array.isArray(obj))
      return null;
    if (Array.isArray(obj)) {
      const rules = obj.map((x) => stringifyCss(className, x, settings)).filter(Boolean);
      if (rules.length === 0)
        return null;
      return rules.join("\n\n");
    }
    let css = ``;
    const indent = " ".repeat(settings.editor.tabSize);
    const context = (0, import_dlv3.default)(obj, "__context", []);
    const props = Object.keys(removeMeta(obj));
    if (props.length === 0)
      return null;
    for (let i = 0; i < context.length; i++) {
      css += `${indent.repeat(i)}${context[i]} {
`;
    }
    const indentStr = indent.repeat(context.length);
    const decls = props.reduce((acc, curr, i) => {
      const propStr = ensureArray(obj[curr]).map((val) => {
        const px = settings.tailwindCSS.showPixelEquivalents ? remToPx(val, settings.tailwindCSS.rootFontSize) : void 0;
        return `${indentStr + indent}${curr}: ${val}${px ? `/* ${px} */` : ""};`;
      }).join("\n");
      return `${acc}${i === 0 ? "" : "\n"}${propStr}`;
    }, "");
    css += `${indentStr}${augmentClassName(className, obj)} {
${decls}
${indentStr}}`;
    for (let i = context.length - 1; i >= 0; i--) {
      css += `${indent.repeat(i)}
}`;
    }
    return css;
  }
  function augmentClassName(className, obj) {
    const pseudo = obj.__pseudo.join("");
    const scope = obj.__scope ? `${obj.__scope} ` : "";
    return `${scope}.${(0, import_css.default)(className)}${pseudo}`;
  }
  function isRawScreen(screen) {
    return isObject22(screen) && screen.raw !== void 0;
  }
  function stringifyScreen(screen) {
    if (!screen)
      return void 0;
    if (typeof screen === "string")
      return `@media (min-width: ${screen})`;
    if (isRawScreen(screen)) {
      return `@media ${screen.raw}`;
    }
    let str = (Array.isArray(screen) ? screen : [screen]).map((range) => {
      return [typeof range.min === "string" ? `(min-width: ${range.min})` : null, typeof range.max === "string" ? `(max-width: ${range.max})` : null].filter(Boolean).join(" and ");
    }).join(", ");
    return str ? `@media ${str}` : void 0;
  }
  function isValidLocationForEmmetAbbreviation(document3, abbreviationRange) {
    const startAngle = "<";
    const endAngle = ">";
    const escape2 = "\\";
    const question = "?";
    let start = {
      line: 0,
      character: 0
    };
    let textToBackTrack = document3.getText({
      start: {
        line: start.line,
        character: start.character
      },
      end: {
        line: abbreviationRange.start.line,
        character: abbreviationRange.start.character
      }
    });
    if (textToBackTrack.length > 500) {
      textToBackTrack = textToBackTrack.substr(textToBackTrack.length - 500);
    }
    if (!textToBackTrack.trim()) {
      return true;
    }
    let valid = true;
    let foundSpace = false;
    let i = textToBackTrack.length - 1;
    if (textToBackTrack[i] === startAngle) {
      return false;
    }
    while (i >= 0) {
      const char = textToBackTrack[i];
      i--;
      if (!foundSpace && /\s/.test(char)) {
        foundSpace = true;
        continue;
      }
      if (char === question && textToBackTrack[i] === startAngle) {
        i--;
        continue;
      }
      if (/\s/.test(char) && textToBackTrack[i] === startAngle) {
        i--;
        continue;
      }
      if (char !== startAngle && char !== endAngle) {
        continue;
      }
      if (i >= 0 && textToBackTrack[i] === escape2) {
        i--;
        continue;
      }
      if (char === endAngle) {
        if (i >= 0 && textToBackTrack[i] === "=") {
          continue;
        } else {
          break;
        }
      }
      if (char === startAngle) {
        valid = !foundSpace;
        break;
      }
    }
    return valid;
  }
  function naturalExpand(value2, total) {
    let length2 = typeof total === "number" ? total.toString().length : 8;
    return ("0".repeat(length2) + value2).slice(-length2);
  }
  function gte(v1, v2) {
    if (v1.startsWith("0.0.0-insiders")) {
      return true;
    }
    return (0, import_gte.default)(v1, v2);
  }
  function docsUrl(version2, paths) {
    let major = 0;
    let url2 = "https://tailwindcss-v0.netlify.app/docs/";
    if (gte(version2, "0.99.0")) {
      major = 1;
      url2 = "https://v1.tailwindcss.com/docs/";
    }
    if (gte(version2, "1.99.0")) {
      major = 2;
      url2 = "https://tailwindcss.com/docs/";
    }
    const path = Array.isArray(paths) ? paths[major] || paths[paths.length - 1] : paths;
    return `${url2}${path}`;
  }
  function getClassNameMeta(state, classNameOrParts) {
    const parts = Array.isArray(classNameOrParts) ? classNameOrParts : getClassNameParts(state, classNameOrParts);
    if (!parts)
      return null;
    const info = (0, import_dlv3.default)(state.classNames.classNames, [...parts, "__info"]);
    if (Array.isArray(info)) {
      return info.map((i) => ({
        source: i.__source,
        pseudo: i.__pseudo,
        scope: i.__scope,
        context: i.__context
      }));
    }
    return {
      source: info.__source,
      pseudo: info.__pseudo,
      scope: info.__scope,
      context: info.__context
    };
  }
  function flagEnabled2(state, flag) {
    if (state.featureFlags.future.includes(flag)) {
      return state.config.future === "all" || (0, import_dlv3.default)(state.config, ["future", flag], false);
    }
    if (state.featureFlags.experimental.includes(flag)) {
      return state.config.experimental === "all" || (0, import_dlv3.default)(state.config, ["experimental", flag], false);
    }
    return false;
  }
  function validateApply(state, classNameOrParts) {
    if (state.jit) {
      return {
        isApplyable: true
      };
    }
    const meta = getClassNameMeta(state, classNameOrParts);
    if (!meta)
      return null;
    if (gte(state.version, "2.0.0-alpha.1") || flagEnabled2(state, "applyComplexClasses")) {
      return {
        isApplyable: true
      };
    }
    const className = Array.isArray(classNameOrParts) ? classNameOrParts.join(state.separator) : classNameOrParts;
    let reason;
    if (Array.isArray(meta)) {
      reason = `'@apply' cannot be used with '${className}' because it is included in multiple rulesets.`;
    } else if (meta.source !== "utilities") {
      reason = `'@apply' cannot be used with '${className}' because it is not a utility.`;
    } else if (meta.context && meta.context.length > 0) {
      if (meta.context.length === 1) {
        reason = `'@apply' cannot be used with '${className}' because it is nested inside of an at-rule ('${meta.context[0]}').`;
      } else {
        reason = `'@apply' cannot be used with '${className}' because it is nested inside of at-rules (${meta.context.map((c4) => `'${c4}'`).join(", ")}).`;
      }
    } else if (meta.pseudo && meta.pseudo.length > 0) {
      if (meta.pseudo.length === 1) {
        reason = `'@apply' cannot be used with '${className}' because its definition includes a pseudo-selector ('${meta.pseudo[0]}')`;
      } else {
        reason = `'@apply' cannot be used with '${className}' because its definition includes pseudo-selectors (${meta.pseudo.map((p2) => `'${p2}'`).join(", ")}).`;
      }
    }
    if (reason) {
      return {
        isApplyable: false,
        reason
      };
    }
    return {
      isApplyable: true
    };
  }
  function getVariantsFromClassName(state, className) {
    let allVariants = state.variants.flatMap((variant) => {
      if (variant.values.length) {
        return variant.values.map((value2) => value2 === "DEFAULT" ? variant.name : `${variant.name}${variant.hasDash ? "-" : ""}${value2}`);
      }
      return [variant.name];
    });
    let variants = /* @__PURE__ */ new Set();
    let offset = 0;
    let parts = splitAtTopLevelOnly2(className, state.separator);
    if (parts.length < 2) {
      return {
        variants: Array.from(variants),
        offset
      };
    }
    parts = parts.filter(Boolean);
    for (let part of parts) {
      if (allVariants.includes(part) || state.jit && (part.includes("[") && part.endsWith("]") || part.includes("/")) && generateRules2(state, [`${part}${state.separator}[color:red]`]).rules.length > 0) {
        variants.add(part);
        offset += part.length + state.separator.length;
        continue;
      }
      break;
    }
    return {
      variants: Array.from(variants),
      offset
    };
  }
  function splitAtTopLevelOnly2(input, separator) {
    let stack = [];
    let parts = [];
    let lastPos = 0;
    for (let idx = 0; idx < input.length; idx++) {
      let char = input[idx];
      if (stack.length === 0 && char === separator[0]) {
        if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
          parts.push(input.slice(lastPos, idx));
          lastPos = idx + separator.length;
        }
      }
      if (char === "(" || char === "[" || char === "{") {
        stack.push(char);
      } else if (char === ")" && stack[stack.length - 1] === "(" || char === "]" && stack[stack.length - 1] === "[" || char === "}" && stack[stack.length - 1] === "{") {
        stack.pop();
      }
    }
    parts.push(input.slice(lastPos));
    return parts;
  }
  var isUtil = (className) => Array.isArray(className.__info) ? className.__info.some((x) => x.__source === "utilities") : className.__info.__source === "utilities";
  function completionsFromClassList(state, classList, classListRange, filter, context) {
    var _state$completionItem5;
    let classNames = classList.split(/[\s+]/);
    const partialClassName = classNames[classNames.length - 1];
    let sep2 = state.separator;
    let parts = partialClassName.split(sep2);
    let subset;
    let subsetKey = [];
    let isSubset = false;
    let replacementRange = {
      ...classListRange,
      start: {
        ...classListRange.start,
        character: classListRange.end.character - partialClassName.length
      }
    };
    if (state.jit) {
      var _state$completionItem3;
      let {
        variants: existingVariants,
        offset
      } = getVariantsFromClassName(state, partialClassName);
      if (context && (context.triggerKind === 1 || context.triggerKind === 2 && context.triggerCharacter === "/") && partialClassName.includes("/")) {
        let modifiers;
        let beforeSlash = partialClassName.split("/").slice(0, -1).join("/");
        if (state.classListContainsMetadata) {
          var _state$classList$find, _state$classList$find2;
          let baseClassName = beforeSlash.slice(offset);
          modifiers = (_state$classList$find = state.classList.find((cls) => Array.isArray(cls) && cls[0] === baseClassName)) == null ? void 0 : (_state$classList$find2 = _state$classList$find[1]) == null ? void 0 : _state$classList$find2.modifiers;
        } else {
          let testClass = beforeSlash + "/[0]";
          let {
            rules
          } = generateRules2(state, [testClass]);
          if (rules.length > 0) {
            let opacities = (0, import_dlv3.default)(state.config, "theme.opacity", {});
            if (!isObject22(opacities)) {
              opacities = {};
            }
            modifiers = Object.keys(opacities);
          }
        }
        if (modifiers) {
          return withDefaults({
            isIncomplete: false,
            items: modifiers.map((modifier, index2) => {
              let className = `${beforeSlash}/${modifier}`;
              let kind = 21;
              let documentation;
              const color2 = getColor(state, className);
              if (color2 !== null) {
                var _color$alpha;
                kind = 16;
                if (typeof color2 !== "string" && ((_color$alpha = color2.alpha) != null ? _color$alpha : 1) !== 0) {
                  documentation = formatRgb(color2);
                }
              }
              return {
                label: className,
                ...documentation ? {
                  documentation
                } : {},
                kind,
                sortText: naturalExpand(index2)
              };
            })
          }, {
            range: replacementRange,
            data: state.completionItemData
          }, state.editor.capabilities.itemDefaults);
        }
      }
      replacementRange.start.character += offset;
      let important = partialClassName.substr(offset).startsWith("!");
      if (important) {
        replacementRange.start.character += 1;
      }
      let items = [];
      if (!important) {
        let variantItem = function(item) {
          var _state$completionItem;
          return {
            kind: 9,
            data: {
              ...(_state$completionItem = state.completionItemData) != null ? _state$completionItem : {},
              _type: "variant"
            },
            command: item.insertTextFormat === 2 ? void 0 : {
              title: "",
              command: "editor.action.triggerSuggest"
            },
            sortText: "-" + naturalExpand(variantOrder++),
            ...item
          };
        };
        let variantOrder = 0;
        items.push(...state.variants.flatMap((variant) => {
          let items2 = [];
          if (variant.isArbitrary) {
            items2.push(variantItem({
              label: `${variant.name}${variant.hasDash ? "-" : ""}[]${sep2}`,
              insertTextFormat: 2,
              textEditText: `${variant.name}${variant.hasDash ? "-" : ""}[\${1}]${sep2}\${0}`
            }));
          } else if (!existingVariants.includes(variant.name)) {
            let shouldSortVariants = !gte(state.version, "2.99.0");
            let resultingVariants = [...existingVariants, variant.name];
            if (shouldSortVariants) {
              let allVariants = state.variants.map((_ref) => {
                let {
                  name
                } = _ref;
                return name;
              });
              resultingVariants = resultingVariants.sort((a, b) => allVariants.indexOf(b) - allVariants.indexOf(a));
            }
            items2.push(variantItem({
              label: `${variant.name}${sep2}`,
              detail: variant.selectors().join(", "),
              textEditText: resultingVariants[resultingVariants.length - 1] + sep2,
              additionalTextEdits: shouldSortVariants && resultingVariants.length > 1 ? [{
                newText: resultingVariants.slice(0, resultingVariants.length - 1).join(sep2) + sep2,
                range: {
                  start: {
                    ...classListRange.start,
                    character: classListRange.end.character - partialClassName.length
                  },
                  end: {
                    ...replacementRange.start,
                    character: replacementRange.start.character
                  }
                }
              }] : []
            }));
          }
          if (variant.values.length) {
            items2.push(...variant.values.filter((value2) => !existingVariants.includes(`${variant.name}-${value2}`)).map((value2) => variantItem({
              label: value2 === "DEFAULT" ? `${variant.name}${sep2}` : `${variant.name}${variant.hasDash ? "-" : ""}${value2}${sep2}`,
              detail: variant.selectors({
                value: value2
              }).join(", ")
            })));
          }
          return items2;
        }));
      }
      if (state.classList) {
        var _state$completionItem2;
        return withDefaults({
          isIncomplete: false,
          items: items.concat(state.classList.map((_ref2, index2) => {
            let [className, {
              color: color2
            }] = _ref2;
            let kind = color2 ? 16 : 21;
            let documentation;
            if (color2 && typeof color2 !== "string") {
              documentation = formatRgb(color2);
            }
            return {
              label: className,
              kind,
              ...documentation ? {
                documentation
              } : {},
              sortText: naturalExpand(index2, state.classList.length)
            };
          }))
        }, {
          data: {
            ...(_state$completionItem2 = state.completionItemData) != null ? _state$completionItem2 : {},
            ...important ? {
              important
            } : {},
            variants: existingVariants
          },
          range: replacementRange
        }, state.editor.capabilities.itemDefaults);
      }
      return withDefaults({
        isIncomplete: false,
        items: items.concat(Object.keys(state.classNames.classNames).filter((className) => {
          let item = state.classNames.classNames[className];
          if (existingVariants.length === 0) {
            return item.__info;
          }
          return item.__info && isUtil(item);
        }).map((className, index2, classNames2) => {
          let kind = 21;
          let documentation;
          const color2 = getColor(state, className);
          if (color2 !== null) {
            var _color$alpha2;
            kind = 16;
            if (typeof color2 !== "string" && ((_color$alpha2 = color2.alpha) != null ? _color$alpha2 : 1) !== 0) {
              documentation = formatRgb(color2);
            }
          }
          return {
            label: className,
            kind,
            ...documentation ? {
              documentation
            } : {},
            sortText: naturalExpand(index2, classNames2.length)
          };
        })).filter((item) => {
          if (item === null) {
            return false;
          }
          if (filter && !filter(item)) {
            return false;
          }
          return true;
        })
      }, {
        range: replacementRange,
        data: {
          ...(_state$completionItem3 = state.completionItemData) != null ? _state$completionItem3 : {},
          variants: existingVariants,
          ...important ? {
            important
          } : {}
        }
      }, state.editor.capabilities.itemDefaults);
    }
    for (let i = parts.length - 1; i > 0; i--) {
      let keys = parts.slice(0, i).filter(Boolean);
      subset = (0, import_dlv3.default)(state.classNames.classNames, keys);
      if (typeof subset !== "undefined" && typeof (0, import_dlv3.default)(subset, ["__info", "__rule"]) === "undefined") {
        isSubset = true;
        subsetKey = keys;
        replacementRange = {
          ...replacementRange,
          start: {
            ...replacementRange.start,
            character: replacementRange.start.character + keys.join(sep2).length + sep2.length
          }
        };
        break;
      }
    }
    return withDefaults({
      isIncomplete: false,
      items: Object.keys(isSubset ? subset : state.classNames.classNames).filter((k2) => k2 !== "__info").filter((className) => isContextItem(state, [...subsetKey, className])).map((className, index2, classNames2) => {
        var _state$completionItem4;
        return {
          label: className + sep2,
          kind: 9,
          command: {
            title: "",
            command: "editor.action.triggerSuggest"
          },
          sortText: "-" + naturalExpand(index2, classNames2.length),
          data: {
            ...(_state$completionItem4 = state.completionItemData) != null ? _state$completionItem4 : {},
            className,
            variants: subsetKey
          }
        };
      }).concat(Object.keys(isSubset ? subset : state.classNames.classNames).filter((className) => (0, import_dlv3.default)(state.classNames.classNames, [...subsetKey, className, "__info"])).map((className, index2, classNames2) => {
        let kind = 21;
        let documentation;
        const color2 = getColor(state, className);
        if (color2 !== null) {
          var _color$alpha3;
          kind = 16;
          if (typeof color2 !== "string" && ((_color$alpha3 = color2.alpha) != null ? _color$alpha3 : 1) !== 0) {
            documentation = formatRgb(color2);
          }
        }
        return {
          label: className,
          kind,
          ...documentation ? {
            documentation
          } : {},
          sortText: naturalExpand(index2, classNames2.length)
        };
      })).filter((item) => {
        if (item === null) {
          return false;
        }
        if (filter && !filter(item)) {
          return false;
        }
        return true;
      })
    }, {
      range: replacementRange,
      data: {
        ...(_state$completionItem5 = state.completionItemData) != null ? _state$completionItem5 : {},
        variants: subsetKey
      }
    }, state.editor.capabilities.itemDefaults);
  }
  async function provideClassAttributeCompletions(state, document3, position2, context) {
    let str = document3.getText({
      start: document3.positionAt(Math.max(0, document3.offsetAt(position2) - 1e3)),
      end: position2
    });
    let matches = matchClassAttributes(str, (await state.editor.getConfiguration(document3.uri)).tailwindCSS.classAttributes);
    if (matches.length === 0) {
      return null;
    }
    let match = matches[matches.length - 1];
    const lexer = match[0][0] === ":" || match[1].startsWith("[") && match[1].endsWith("]") ? getComputedClassAttributeLexer() : getClassAttributeLexer();
    lexer.reset(str.substr(match.index + match[0].length - 1));
    try {
      let tokens = Array.from(lexer);
      let last = tokens[tokens.length - 1];
      if (last.type.startsWith("start") || last.type === "classlist" || last.type.startsWith("arb")) {
        let classList = "";
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i].type === "classlist" || tokens[i].type.startsWith("arb")) {
            classList = tokens[i].value + classList;
          } else {
            break;
          }
        }
        return completionsFromClassList(state, classList, {
          start: {
            line: position2.line,
            character: position2.character - classList.length
          },
          end: position2
        }, void 0, context);
      }
    } catch (_) {
    }
    return null;
  }
  async function provideCustomClassNameCompletions(state, document3, position2, context) {
    const settings = await state.editor.getConfiguration(document3.uri);
    const regexes = settings.tailwindCSS.experimental.classRegex;
    if (regexes.length === 0)
      return null;
    const positionOffset = document3.offsetAt(position2);
    const searchRange = {
      start: document3.positionAt(Math.max(0, positionOffset - 1e3)),
      end: document3.positionAt(positionOffset + 1e3)
    };
    let str = document3.getText(searchRange);
    for (let i = 0; i < regexes.length; i++) {
      try {
        let [containerRegexString, classRegexString] = Array.isArray(regexes[i]) ? regexes[i] : [regexes[i]];
        let containerRegex = new import_becke_ch_regex_s0_0_v1_base_pl_lib.default(containerRegexString, "g");
        let containerMatch;
        while ((containerMatch = containerRegex.exec(str)) !== null) {
          const searchStart = document3.offsetAt(searchRange.start);
          const matchStart = searchStart + containerMatch.index[1];
          const matchEnd = matchStart + containerMatch[1].length;
          const cursor = document3.offsetAt(position2);
          if (cursor >= matchStart && cursor <= matchEnd) {
            let classList;
            if (classRegexString) {
              let classRegex = new import_becke_ch_regex_s0_0_v1_base_pl_lib.default(classRegexString, "g");
              let classMatch;
              while ((classMatch = classRegex.exec(containerMatch[1])) !== null) {
                const classMatchStart = matchStart + classMatch.index[1];
                const classMatchEnd = classMatchStart + classMatch[1].length;
                if (cursor >= classMatchStart && cursor <= classMatchEnd) {
                  classList = classMatch[1].substr(0, cursor - classMatchStart);
                }
              }
              if (typeof classList === "undefined") {
                throw Error();
              }
            } else {
              classList = containerMatch[1].substr(0, cursor - matchStart);
            }
            return completionsFromClassList(state, classList, {
              start: {
                line: position2.line,
                character: position2.character - classList.length
              },
              end: position2
            }, void 0, context);
          }
        }
      } catch (_) {
      }
    }
    return null;
  }
  function provideAtApplyCompletions(state, document3, position2, context) {
    let str = document3.getText({
      start: {
        line: Math.max(position2.line - 30, 0),
        character: 0
      },
      end: position2
    });
    const match = findLast(/@apply\s+(?<classList>[^;}]*)$/gi, str);
    if (match === null) {
      return null;
    }
    const classList = match.groups.classList;
    return completionsFromClassList(state, classList, {
      start: {
        line: position2.line,
        character: position2.character - classList.length
      },
      end: position2
    }, (item) => {
      var _item$data$variants, _item$data, _item$data$className, _item$data2;
      if (item.kind === 9) {
        return gte(state.version, "2.0.0-alpha.1") || flagEnabled2(state, "applyComplexClasses");
      }
      let variants = (_item$data$variants = (_item$data = item.data) == null ? void 0 : _item$data.variants) != null ? _item$data$variants : [];
      let className = (_item$data$className = (_item$data2 = item.data) == null ? void 0 : _item$data2.className) != null ? _item$data$className : item.label;
      let validated = validateApply(state, [...variants, className]);
      return validated !== null && validated.isApplyable === true;
    }, context);
  }
  var NUMBER_REGEX = /^(\d+\.?|\d*\.\d+)$/;
  function isNumber(str) {
    return NUMBER_REGEX.test(str);
  }
  async function provideClassNameCompletions(state, document3, position2, context) {
    if (isCssContext(state, document3, position2)) {
      return provideAtApplyCompletions(state, document3, position2, context);
    }
    if (isHtmlContext(state, document3, position2) || isJsxContext(state, document3, position2)) {
      return provideClassAttributeCompletions(state, document3, position2, context);
    }
    return null;
  }
  function provideCssHelperCompletions(state, document3, position2) {
    var _state$completionItem6;
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let text2 = document3.getText({
      start: {
        line: position2.line,
        character: 0
      },
      // read one extra character so we can see if it's a ] later
      end: {
        line: position2.line,
        character: position2.character + 1
      }
    });
    const match = text2.substr(0, text2.length - 1).match(/[\s:;/*(){}](?<helper>config|theme)\(\s*['"]?(?<path>[^)'"]*)$/);
    if (match === null) {
      return null;
    }
    let alpha;
    let path = match.groups.path.replace(/^['"]+/g, "");
    let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]*))$/);
    if (matches) {
      path = matches[1];
      alpha = matches[2];
    }
    if (alpha !== void 0) {
      return null;
    }
    let base = match.groups.helper === "config" ? state.config : (0, import_dlv3.default)(state.config, "theme", {});
    let parts = path.split(/([\[\].]+)/);
    let keys = parts.filter((_, i) => i % 2 === 0);
    let separators = parts.filter((_, i) => i % 2 !== 0);
    function totalLength(arr) {
      return arr.reduce((acc, cur) => acc + cur.length, 0);
    }
    let obj;
    let offset = keys[keys.length - 1].length;
    let separator = separators.length ? separators[separators.length - 1] : null;
    if (keys.length === 1) {
      obj = base;
    } else {
      for (let i = keys.length - 1; i > 0; i--) {
        let o = (0, import_dlv3.default)(base, keys.slice(0, i));
        if (isObject22(o)) {
          obj = o;
          offset = totalLength(parts.slice(i * 2));
          separator = separators[i - 1];
          break;
        }
      }
    }
    if (!obj)
      return null;
    let editRange = {
      start: {
        line: position2.line,
        character: position2.character - offset
      },
      end: position2
    };
    return withDefaults({
      isIncomplete: false,
      items: Object.keys(obj).sort((a, z) => {
        let aIsNumber = isNumber(a);
        let zIsNumber = isNumber(z);
        if (aIsNumber && !zIsNumber) {
          return -1;
        }
        if (!aIsNumber && zIsNumber) {
          return 1;
        }
        if (aIsNumber && zIsNumber) {
          return parseFloat(a) - parseFloat(z);
        }
        return 0;
      }).map((item, index2, items) => {
        var _color$alpha4;
        let color2 = getColorFromValue(obj[item]);
        const replaceDot = item.indexOf(".") !== -1 && separator && separator.endsWith(".");
        const insertClosingBrace = text2.charAt(text2.length - 1) !== "]" && (replaceDot || separator && separator.endsWith("["));
        const detail = stringifyConfigValue(obj[item]);
        return {
          label: item,
          sortText: naturalExpand(index2, items.length),
          commitCharacters: [!item.includes(".") && ".", !item.includes("[") && "["].filter(Boolean),
          kind: color2 ? 16 : isObject22(obj[item]) ? 9 : 10,
          // VS Code bug causes some values to not display in some cases
          detail: detail === "0" || detail === "transparent" ? `${detail} ` : detail,
          ...color2 && typeof color2 !== "string" && ((_color$alpha4 = color2.alpha) != null ? _color$alpha4 : 1) !== 0 ? {
            documentation: formatRgb(color2)
          } : {},
          ...insertClosingBrace ? {
            textEditText: `${item}]`
          } : {},
          additionalTextEdits: replaceDot ? [{
            newText: "[",
            range: {
              start: {
                ...editRange.start,
                character: editRange.start.character - 1
              },
              end: editRange.start
            }
          }] : []
        };
      })
    }, {
      range: editRange,
      data: {
        ...(_state$completionItem6 = state.completionItemData) != null ? _state$completionItem6 : {},
        _type: "helper"
      }
    }, state.editor.capabilities.itemDefaults);
  }
  function provideTailwindDirectiveCompletions(state, document3, position2) {
    var _state$completionItem7;
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let text2 = document3.getText({
      start: {
        line: position2.line,
        character: 0
      },
      end: position2
    });
    const match = text2.match(/^\s*@tailwind\s+(?<partial>[^\s]*)$/i);
    if (match === null)
      return null;
    let items = [gte(state.version, "1.0.0-beta.1") ? {
      label: "base",
      documentation: {
        kind: "markdown",
        value: `This injects Tailwind\u2019s base styles and any base styles registered by plugins.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#tailwind")})`
      }
    } : {
      label: "preflight",
      documentation: {
        kind: "markdown",
        value: `This injects Tailwind\u2019s base styles, which is a combination of Normalize.css and some additional base styles.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#tailwind")})`
      }
    }, {
      label: "components",
      documentation: {
        kind: "markdown",
        value: `This injects Tailwind\u2019s component classes and any component classes registered by plugins.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#tailwind")})`
      }
    }, {
      label: "utilities",
      documentation: {
        kind: "markdown",
        value: `This injects Tailwind\u2019s utility classes and any utility classes registered by plugins.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#tailwind")})`
      }
    }, state.jit && gte(state.version, "2.1.99") ? {
      label: "variants",
      documentation: {
        kind: "markdown",
        value: `Use this directive to control where Tailwind injects the utility variants.

This directive is considered an advanced escape hatch and it is recommended to omit it whenever possible. If omitted, Tailwind will append these classes to the very end of your stylesheet by default.

[Tailwind CSS Documentation](${docsUrl(state.version, "just-in-time-mode#variants-are-inserted-at-tailwind-variants")})`
      }
    } : {
      label: "screens",
      documentation: {
        kind: "markdown",
        value: `Use this directive to control where Tailwind injects the responsive variations of each utility.

If omitted, Tailwind will append these classes to the very end of your stylesheet by default.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#tailwind")})`
      }
    }];
    return withDefaults({
      isIncomplete: false,
      items: items.map((item) => ({
        ...item,
        kind: 21
      }))
    }, {
      data: {
        ...(_state$completionItem7 = state.completionItemData) != null ? _state$completionItem7 : {},
        _type: "@tailwind"
      },
      range: {
        start: {
          line: position2.line,
          character: position2.character - match.groups.partial.length
        },
        end: position2
      }
    }, state.editor.capabilities.itemDefaults);
  }
  function provideVariantsDirectiveCompletions(state, document3, position2) {
    var _state$completionItem8;
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    if (gte(state.version, "2.99.0")) {
      return null;
    }
    let text2 = document3.getText({
      start: {
        line: position2.line,
        character: 0
      },
      end: position2
    });
    const match = text2.match(/^\s*@variants\s+(?<partial>[^}]*)$/i);
    if (match === null)
      return null;
    const parts = match.groups.partial.split(/\s*,\s*/);
    if (/\s+/.test(parts[parts.length - 1]))
      return null;
    let possibleVariants = state.variants.flatMap((variant) => {
      if (variant.values.length) {
        return variant.values.map((value2) => value2 === "DEFAULT" ? variant.name : `${variant.name}${variant.hasDash ? "-" : ""}${value2}`);
      }
      return [variant.name];
    });
    const existingVariants = parts.slice(0, parts.length - 1);
    if (state.jit) {
      possibleVariants.unshift("responsive");
      possibleVariants = possibleVariants.filter((v) => !state.screens.includes(v));
    }
    return withDefaults({
      isIncomplete: false,
      items: possibleVariants.filter((v) => existingVariants.indexOf(v) === -1).map((variant, index2, variants) => ({
        // TODO: detail
        label: variant,
        kind: 21,
        sortText: naturalExpand(index2, variants.length)
      }))
    }, {
      data: {
        ...(_state$completionItem8 = state.completionItemData) != null ? _state$completionItem8 : {},
        _type: "variant"
      },
      range: {
        start: {
          line: position2.line,
          character: position2.character - parts[parts.length - 1].length
        },
        end: position2
      }
    }, state.editor.capabilities.itemDefaults);
  }
  function provideLayerDirectiveCompletions(state, document3, position2) {
    var _state$completionItem9;
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let text2 = document3.getText({
      start: {
        line: position2.line,
        character: 0
      },
      end: position2
    });
    const match = text2.match(/^\s*@layer\s+(?<partial>[^\s]*)$/i);
    if (match === null)
      return null;
    return withDefaults({
      isIncomplete: false,
      items: ["base", "components", "utilities"].map((layer, index2, layers) => ({
        label: layer,
        kind: 21,
        sortText: naturalExpand(index2, layers.length)
      }))
    }, {
      data: {
        ...(_state$completionItem9 = state.completionItemData) != null ? _state$completionItem9 : {},
        _type: "layer"
      },
      range: {
        start: {
          line: position2.line,
          character: position2.character - match.groups.partial.length
        },
        end: position2
      }
    }, state.editor.capabilities.itemDefaults);
  }
  function withDefaults(completionList, defaults3, supportedDefaults) {
    let defaultData = supportedDefaults.includes("data");
    let defaultRange = supportedDefaults.includes("editRange");
    return {
      ...completionList,
      ...defaultData || defaultRange ? {
        itemDefaults: {
          ...defaultData && defaults3.data ? {
            data: defaults3.data
          } : {},
          ...defaultRange && defaults3.range ? {
            editRange: defaults3.range
          } : {}
        }
      } : {},
      items: defaultData && defaultRange ? completionList.items : completionList.items.map((_ref3) => {
        let {
          textEditText,
          ...item
        } = _ref3;
        return {
          ...item,
          ...defaultData || !defaults3.data || item.data ? {} : {
            data: defaults3.data
          },
          ...defaultRange || !defaults3.range ? textEditText ? {
            textEditText
          } : {} : {
            textEdit: {
              newText: textEditText != null ? textEditText : item.label,
              range: defaults3.range
            }
          }
        };
      })
    };
  }
  function provideScreenDirectiveCompletions(state, document3, position2) {
    var _state$completionItem10;
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let text2 = document3.getText({
      start: {
        line: position2.line,
        character: 0
      },
      end: position2
    });
    const match = text2.match(/^\s*@screen\s+(?<partial>[^\s]*)$/i);
    if (match === null)
      return null;
    const screens = (0, import_dlv3.default)(state.config, ["screens"], (0, import_dlv3.default)(state.config, ["theme", "screens"], {}));
    if (!isObject22(screens))
      return null;
    return withDefaults({
      isIncomplete: false,
      items: Object.keys(screens).map((screen, index2) => ({
        label: screen,
        kind: 21,
        sortText: naturalExpand(index2)
      }))
    }, {
      data: {
        ...(_state$completionItem10 = state.completionItemData) != null ? _state$completionItem10 : {},
        _type: "screen"
      },
      range: {
        start: {
          line: position2.line,
          character: position2.character - match.groups.partial.length
        },
        end: position2
      }
    }, state.editor.capabilities.itemDefaults);
  }
  function provideCssDirectiveCompletions(state, document3, position2) {
    var _state$completionItem11;
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let text2 = document3.getText({
      start: {
        line: position2.line,
        character: 0
      },
      end: position2
    });
    const match = text2.match(/^\s*@(?<partial>[a-z]*)$/i);
    if (match === null)
      return null;
    const items = [{
      label: "@tailwind",
      documentation: {
        kind: "markdown",
        value: `Use the \`@tailwind\` directive to insert Tailwind\u2019s \`base\`, \`components\`, \`utilities\` and \`${state.jit && gte(state.version, "2.1.99") ? "variants" : "screens"}\` styles into your CSS.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#tailwind")})`
      }
    }, {
      label: "@screen",
      documentation: {
        kind: "markdown",
        value: `The \`@screen\` directive allows you to create media queries that reference your breakpoints by name instead of duplicating their values in your own CSS.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#screen")})`
      }
    }, {
      label: "@apply",
      documentation: {
        kind: "markdown",
        value: `Use \`@apply\` to inline any existing utility classes into your own custom CSS.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#apply")})`
      }
    }, ...gte(state.version, "1.8.0") ? [{
      label: "@layer",
      documentation: {
        kind: "markdown",
        value: `Use the \`@layer\` directive to tell Tailwind which "bucket" a set of custom styles belong to. Valid layers are \`base\`, \`components\`, and \`utilities\`.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#layer")})`
      }
    }] : [], ...gte(state.version, "2.99.0") ? [] : [{
      label: "@variants",
      documentation: {
        kind: "markdown",
        value: `You can generate \`responsive\`, \`hover\`, \`focus\`, \`active\`, and other variants of your own utilities by wrapping their definitions in the \`@variants\` directive.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#variants")})`
      }
    }, {
      label: "@responsive",
      documentation: {
        kind: "markdown",
        value: `You can generate responsive variants of your own classes by wrapping their definitions in the \`@responsive\` directive.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#responsive")})`
      }
    }], ...gte(state.version, "3.2.0") ? [{
      label: "@config",
      documentation: {
        kind: "markdown",
        value: `Use the \`@config\` directive to specify which config file Tailwind should use when compiling that CSS file.

[Tailwind CSS Documentation](${docsUrl(state.version, "functions-and-directives/#config")})`
      }
    }] : []];
    return withDefaults({
      isIncomplete: false,
      items: items.map((item) => ({
        ...item,
        kind: 14
      }))
    }, {
      data: {
        ...(_state$completionItem11 = state.completionItemData) != null ? _state$completionItem11 : {},
        _type: "directive"
      },
      range: {
        start: {
          line: position2.line,
          character: position2.character - match.groups.partial.length - 1
        },
        end: position2
      }
    }, state.editor.capabilities.itemDefaults);
  }
  async function provideConfigDirectiveCompletions(state, document3, position2) {
    var _state$completionItem12;
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    if (!gte(state.version, "3.2.0")) {
      return null;
    }
    let text2 = document3.getText({
      start: {
        line: position2.line,
        character: 0
      },
      end: position2
    });
    let match = text2.match(/@config\s*(?<partial>'[^']*|"[^"]*)$/);
    if (!match) {
      return null;
    }
    let partial = match.groups.partial.slice(1);
    let valueBeforeLastSlash = partial.substring(0, partial.lastIndexOf("/"));
    let valueAfterLastSlash = partial.substring(partial.lastIndexOf("/") + 1);
    return withDefaults({
      isIncomplete: false,
      items: (await state.editor.readDirectory(document3, valueBeforeLastSlash || ".")).filter((_ref4) => {
        let [name, type] = _ref4;
        return type.isDirectory || /\.c?js$/.test(name);
      }).map((_ref5) => {
        let [name, type] = _ref5;
        return {
          label: type.isDirectory ? name + "/" : name,
          kind: type.isDirectory ? 19 : 17,
          command: type.isDirectory ? {
            command: "editor.action.triggerSuggest",
            title: ""
          } : void 0
        };
      })
    }, {
      data: {
        ...(_state$completionItem12 = state.completionItemData) != null ? _state$completionItem12 : {},
        _type: "filesystem"
      },
      range: {
        start: {
          line: position2.line,
          character: position2.character - valueAfterLastSlash.length
        },
        end: position2
      }
    }, state.editor.capabilities.itemDefaults);
  }
  async function provideEmmetCompletions(state, document3, position2) {
    let settings = await state.editor.getConfiguration(document3.uri);
    if (settings.tailwindCSS.emmetCompletions !== true)
      return null;
    const isHtml = !isJsDoc(state, document3) && isHtmlContext(state, document3, position2);
    const isJs = isJsDoc(state, document3) || isJsxContext(state, document3, position2);
    const syntax = isHtml ? "html" : isJs ? "jsx" : null;
    if (syntax === null) {
      return null;
    }
    const extractAbbreviationResults = extractAbbreviation(document3, position2, true);
    if (!extractAbbreviationResults || !isAbbreviationValid(syntax, extractAbbreviationResults.abbreviation)) {
      return null;
    }
    if (!isValidLocationForEmmetAbbreviation(document3, extractAbbreviationResults.abbreviationRange)) {
      return null;
    }
    if (isJs) {
      const abbreviation = extractAbbreviationResults.abbreviation;
      if (abbreviation.startsWith("this.")) {
        return null;
      }
      const symbols = await state.editor.getDocumentSymbols(document3.uri);
      if (symbols && symbols.find((symbol) => abbreviation === symbol.name || abbreviation.startsWith(symbol.name + ".") && !/>|\*|\+/.test(abbreviation))) {
        return null;
      }
    }
    const emmetItems = doComplete(document3, position2, syntax, {});
    if (!emmetItems || !emmetItems.items || emmetItems.items.length !== 1) {
      return null;
    }
    if (emmetItems.items[0].label === "widows: ;") {
      return null;
    }
    const parts = emmetItems.items[0].label.split(".");
    if (parts.length < 2)
      return null;
    return completionsFromClassList(state, parts[parts.length - 1], {
      start: {
        line: position2.line,
        character: position2.character - parts[parts.length - 1].length
      },
      end: position2
    });
  }
  async function doComplete2(state, document3, position2, context) {
    if (state === null)
      return {
        items: [],
        isIncomplete: false
      };
    const result = await provideClassNameCompletions(state, document3, position2, context) || provideCssHelperCompletions(state, document3, position2) || provideCssDirectiveCompletions(state, document3, position2) || provideScreenDirectiveCompletions(state, document3, position2) || provideVariantsDirectiveCompletions(state, document3, position2) || provideTailwindDirectiveCompletions(state, document3, position2) || provideLayerDirectiveCompletions(state, document3, position2) || await provideConfigDirectiveCompletions(state, document3, position2) || await provideCustomClassNameCompletions(state, document3, position2, context);
    if (result)
      return result;
    return provideEmmetCompletions(state, document3, position2);
  }
  async function resolveCompletionItem(state, item) {
    var _item$data3, _item$data4, _item$data$className2, _item$data5, _item$data6, _item$data$variants2, _item$data7;
    if (["helper", "directive", "variant", "layer", "@tailwind", "filesystem"].includes((_item$data3 = item.data) == null ? void 0 : _item$data3._type)) {
      return item;
    }
    if (((_item$data4 = item.data) == null ? void 0 : _item$data4._type) === "screen") {
      let screens = (0, import_dlv3.default)(state.config, ["theme", "screens"], (0, import_dlv3.default)(state.config, ["screens"], {}));
      if (!isObject22(screens))
        screens = {};
      item.detail = stringifyScreen(screens[item.label]);
      return item;
    }
    let className = (_item$data$className2 = (_item$data5 = item.data) == null ? void 0 : _item$data5.className) != null ? _item$data$className2 : item.label;
    if ((_item$data6 = item.data) != null && _item$data6.important) {
      className = `!${className}`;
    }
    let variants = (_item$data$variants2 = (_item$data7 = item.data) == null ? void 0 : _item$data7.variants) != null ? _item$data$variants2 : [];
    if (state.jit) {
      if (item.kind === 9)
        return item;
      if (item.detail && item.documentation)
        return item;
      let {
        root: root2,
        rules: rules2
      } = generateRules2(state, [[...variants, className].join(state.separator)]);
      if (rules2.length === 0)
        return item;
      if (!item.detail) {
        if (rules2.length === 1) {
          item.detail = await stringifyDecls(state, rules2[0]);
        } else {
          item.detail = `${rules2.length} rules`;
        }
      }
      if (!item.documentation) {
        item.documentation = {
          kind: "markdown",
          value: ["```css", await stringifyRoot(state, root2), "```"].join("\n")
        };
      }
      return item;
    }
    const rules = (0, import_dlv3.default)(state.classNames.classNames, [...variants, className, "__info"]);
    if (item.kind === 9) {
      item.detail = state.classNames.context[className].join(", ");
    } else {
      item.detail = await getCssDetail(state, rules);
      if (!item.documentation) {
        const settings = await state.editor.getConfiguration();
        const css = stringifyCss([...variants, className].join(":"), rules, settings);
        if (css) {
          item.documentation = {
            kind: "markdown",
            value: ["```css", css, "```"].join("\n")
          };
        }
      }
    }
    return item;
  }
  function isContextItem(state, keys) {
    const item = (0, import_dlv3.default)(state.classNames.classNames, [keys]);
    if (!isObject22(item)) {
      return false;
    }
    if (!state.classNames.context[keys[keys.length - 1]]) {
      return false;
    }
    if (Object.keys(item).filter((x) => x !== "__info").length > 0) {
      return true;
    }
    return isObject22(item.__info) && !item.__info.__rule;
  }
  function stringifyDecls$1(obj, settings) {
    let props = Object.keys(obj);
    let nonCustomProps = props.filter((prop) => !prop.startsWith("--"));
    if (props.length !== nonCustomProps.length && nonCustomProps.length !== 0) {
      props = nonCustomProps;
    }
    return props.map((prop) => ensureArray(obj[prop]).map((value2) => {
      const px = settings.tailwindCSS.showPixelEquivalents ? remToPx(value2, settings.tailwindCSS.rootFontSize) : void 0;
      return `${prop}: ${value2}${px ? `/* ${px} */` : ""};`;
    }).join(" ")).join(" ");
  }
  async function getCssDetail(state, className) {
    if (Array.isArray(className)) {
      return `${className.length} rules`;
    }
    if (className.__rule === true) {
      const settings = await state.editor.getConfiguration();
      return stringifyDecls$1(removeMeta(className), settings);
    }
    return null;
  }
  var DiagnosticKind;
  (function(DiagnosticKind2) {
    DiagnosticKind2["CssConflict"] = "cssConflict";
    DiagnosticKind2["InvalidApply"] = "invalidApply";
    DiagnosticKind2["InvalidScreen"] = "invalidScreen";
    DiagnosticKind2["InvalidVariant"] = "invalidVariant";
    DiagnosticKind2["InvalidConfigPath"] = "invalidConfigPath";
    DiagnosticKind2["InvalidTailwindDirective"] = "invalidTailwindDirective";
    DiagnosticKind2["RecommendedVariantOrder"] = "recommendedVariantOrder";
  })(DiagnosticKind || (DiagnosticKind = {}));
  function joinWithAnd(strings) {
    return strings.reduce((acc, cur, i) => {
      if (i === 0) {
        return cur;
      }
      if (strings.length > 1 && i === strings.length - 1) {
        return `${acc} and ${cur}`;
      }
      return `${acc}, ${cur}`;
    }, "");
  }
  function getClassNameDecls(state, className) {
    const parts = getClassNameParts(state, className);
    if (!parts)
      return null;
    const info = (0, import_dlv3.default)(state.classNames.classNames, [...parts, "__info"]);
    if (Array.isArray(info)) {
      return info.map(removeMeta);
    }
    return removeMeta(info);
  }
  async function getCssConflictDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.cssConflict;
    if (severity === "ignore")
      return [];
    let diagnostics = [];
    const classLists = await findClassListsInDocument(state, document3);
    classLists.forEach((classList) => {
      const classNames = getClassNamesInClassList(classList);
      classNames.forEach((className, index2) => {
        if (state.jit) {
          let {
            rules
          } = generateRules2(state, [className.className]);
          if (rules.length === 0) {
            return;
          }
          let info = rules.map((rule2) => {
            let properties2 = [];
            rule2.walkDecls((_ref) => {
              let {
                prop
              } = _ref;
              properties2.push(prop);
            });
            let context = getRuleContext(state, rule2, className.className);
            return {
              context,
              properties: properties2
            };
          });
          let otherClassNames2 = classNames.filter((_className, i) => i !== index2);
          let conflictingClassNames2 = otherClassNames2.filter((otherClassName) => {
            let {
              rules: otherRules
            } = generateRules2(state, [otherClassName.className]);
            if (otherRules.length !== rules.length) {
              return false;
            }
            for (let i = 0; i < otherRules.length; i++) {
              let rule2 = otherRules[i];
              let properties2 = [];
              rule2.walkDecls((_ref2) => {
                let {
                  prop
                } = _ref2;
                properties2.push(prop);
              });
              if (!equal(info[i].properties, properties2)) {
                return false;
              }
              let context = getRuleContext(state, rule2, otherClassName.className);
              if (!equal(info[i].context, context)) {
                return false;
              }
            }
            return true;
          });
          if (conflictingClassNames2.length === 0)
            return;
          diagnostics.push({
            code: DiagnosticKind.CssConflict,
            className,
            otherClassNames: conflictingClassNames2,
            range: className.range,
            severity: severity === "error" ? 1 : 2,
            message: `'${className.className}' applies the same CSS properties as ${joinWithAnd(conflictingClassNames2.map((conflictingClassName) => `'${conflictingClassName.className}'`))}.`,
            relatedInformation: conflictingClassNames2.map((conflictingClassName) => {
              return {
                message: conflictingClassName.className,
                location: {
                  uri: document3.uri,
                  range: conflictingClassName.range
                }
              };
            })
          });
          return;
        }
        let decls = getClassNameDecls(state, className.className);
        if (!decls)
          return;
        let properties = Object.keys(decls);
        let meta = getClassNameMeta(state, className.className);
        let otherClassNames = classNames.filter((_className, i) => i !== index2);
        let conflictingClassNames = otherClassNames.filter((otherClassName) => {
          let otherDecls = getClassNameDecls(state, otherClassName.className);
          if (!otherDecls)
            return false;
          let otherMeta = getClassNameMeta(state, otherClassName.className);
          return equal(properties, Object.keys(otherDecls)) && !Array.isArray(meta) && !Array.isArray(otherMeta) && equal(meta.context, otherMeta.context) && equal(meta.pseudo, otherMeta.pseudo) && meta.scope === otherMeta.scope;
        });
        if (conflictingClassNames.length === 0)
          return;
        diagnostics.push({
          code: DiagnosticKind.CssConflict,
          className,
          otherClassNames: conflictingClassNames,
          range: className.range,
          severity: severity === "error" ? 1 : 2,
          message: `'${className.className}' applies the same CSS ${properties.length === 1 ? "property" : "properties"} as ${joinWithAnd(conflictingClassNames.map((conflictingClassName) => `'${conflictingClassName.className}'`))}.`,
          relatedInformation: conflictingClassNames.map((conflictingClassName) => {
            return {
              message: conflictingClassName.className,
              location: {
                uri: document3.uri,
                range: conflictingClassName.range
              }
            };
          })
        });
      });
    });
    return diagnostics;
  }
  async function getInvalidApplyDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.invalidApply;
    if (severity === "ignore")
      return [];
    const classNames = await findClassNamesInRange(state, document3, void 0, "css", false);
    let diagnostics = classNames.map((className) => {
      let result = validateApply(state, className.className);
      if (result === null || result.isApplyable === true) {
        return null;
      }
      return {
        code: DiagnosticKind.InvalidApply,
        severity: severity === "error" ? 1 : 2,
        range: className.range,
        message: result.reason,
        className
      };
    });
    return diagnostics.filter(Boolean);
  }
  function closest(input, options) {
    return options.concat([]).sort((a, b) => (0, import_sift_string.default)(input, a) - (0, import_sift_string.default)(input, b))[0];
  }
  function absoluteRange(range, reference) {
    return {
      start: {
        line: ((reference == null ? void 0 : reference.start.line) || 0) + range.start.line,
        character: (range.end.line === 0 ? (reference == null ? void 0 : reference.start.character) || 0 : 0) + range.start.character
      },
      end: {
        line: ((reference == null ? void 0 : reference.start.line) || 0) + range.end.line,
        character: (range.end.line === 0 ? (reference == null ? void 0 : reference.start.character) || 0 : 0) + range.end.character
      }
    };
  }
  function getInvalidScreenDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.invalidScreen;
    if (severity === "ignore")
      return [];
    let diagnostics = [];
    let ranges = [];
    if (isCssDoc(state, document3)) {
      ranges.push(void 0);
    } else {
      let boundaries = getLanguageBoundaries(state, document3);
      if (!boundaries)
        return [];
      ranges.push(...boundaries.filter((b) => b.type === "css").map((_ref) => {
        let {
          range
        } = _ref;
        return range;
      }));
    }
    ranges.forEach((range) => {
      let text2 = getTextWithoutComments(document3, "css", range);
      let matches = findAll(/(?:\s|^)@screen\s+(?<screen>[^\s{]+)/g, text2);
      matches.forEach((match) => {
        if (state.screens.includes(match.groups.screen)) {
          return null;
        }
        let message = `The screen '${match.groups.screen}' does not exist in your theme config.`;
        let suggestions = [];
        let suggestion = closest(match.groups.screen, state.screens);
        if (suggestion) {
          suggestions.push(suggestion);
          message += ` Did you mean '${suggestion}'?`;
        }
        diagnostics.push({
          code: DiagnosticKind.InvalidScreen,
          range: absoluteRange({
            start: indexToPosition(text2, match.index + match[0].length - match.groups.screen.length),
            end: indexToPosition(text2, match.index + match[0].length)
          }, range),
          severity: severity === "error" ? 1 : 2,
          message,
          suggestions
        });
      });
    });
    return diagnostics;
  }
  function getInvalidVariantDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.invalidVariant;
    if (severity === "ignore")
      return [];
    if (gte(state.version, "2.99.0")) {
      return [];
    }
    let diagnostics = [];
    let ranges = [];
    if (isCssDoc(state, document3)) {
      ranges.push(void 0);
    } else {
      let boundaries = getLanguageBoundaries(state, document3);
      if (!boundaries)
        return [];
      ranges.push(...boundaries.filter((b) => b.type === "css").map((_ref) => {
        let {
          range
        } = _ref;
        return range;
      }));
    }
    let possibleVariants = state.variants.flatMap((variant) => {
      if (variant.values.length) {
        return variant.values.map((value2) => value2 === "DEFAULT" ? variant.name : `${variant.name}${variant.hasDash ? "-" : ""}${value2}`);
      }
      return [variant.name];
    });
    if (state.jit) {
      possibleVariants.unshift("responsive");
      possibleVariants = possibleVariants.filter((v) => !state.screens.includes(v));
    }
    ranges.forEach((range) => {
      let text2 = getTextWithoutComments(document3, "css", range);
      let matches = findAll(/(?:\s|^)@variants\s+(?<variants>[^{]+)/g, text2);
      matches.forEach((match) => {
        let variants = match.groups.variants.split(/(\s*,\s*)/);
        let listStartIndex = match.index + match[0].length - match.groups.variants.length;
        for (let i = 0; i < variants.length; i += 2) {
          let variant = variants[i].trim();
          if (possibleVariants.includes(variant)) {
            continue;
          }
          let message = `The variant '${variant}' does not exist.`;
          let suggestions = [];
          let suggestion = closest(variant, possibleVariants);
          if (suggestion) {
            suggestions.push(suggestion);
            message += ` Did you mean '${suggestion}'?`;
          }
          let variantStartIndex = listStartIndex + variants.slice(0, i).join("").length;
          diagnostics.push({
            code: DiagnosticKind.InvalidVariant,
            range: absoluteRange({
              start: indexToPosition(text2, variantStartIndex),
              end: indexToPosition(text2, variantStartIndex + variant.length)
            }, range),
            severity: severity === "error" ? 1 : 2,
            message,
            suggestions
          });
        }
      });
    });
    return diagnostics;
  }
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  function stringToPath(string) {
    let result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, (match, number2, quote, subString) => {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
    });
    return result;
  }
  function pathToString2(path) {
    if (typeof path === "string")
      return path;
    return path.reduce((acc, cur, i) => {
      if (i === 0)
        return cur;
      if (cur.includes("."))
        return `${acc}[${cur}]`;
      return `${acc}.${cur}`;
    }, "");
  }
  function validateConfigPath(state, path, base) {
    if (base === void 0) {
      base = [];
    }
    let keys = Array.isArray(path) ? path : stringToPath(path);
    let value2 = (0, import_dlv3.default)(state.config, [...base, ...keys]);
    let suggestions = [];
    function findAlternativePath() {
      let points = combinations("123456789".substr(0, keys.length - 1)).map((x) => x.split("").map((x2) => parseInt(x2, 10)));
      let possibilities = points.map((p2) => {
        let result = [];
        let i = 0;
        p2.forEach((x) => {
          result.push(keys.slice(i, x).join("."));
          i = x;
        });
        result.push(keys.slice(i).join("."));
        return result;
      }).slice(1);
      return possibilities.find((possibility) => validateConfigPath(state, possibility, base).isValid);
    }
    if (typeof value2 === "undefined") {
      let reason = `'${pathToString2(path)}' does not exist in your theme config.`;
      let parentPath = [...base, ...keys.slice(0, keys.length - 1)];
      let parentValue = (0, import_dlv3.default)(state.config, parentPath);
      if (isObject22(parentValue)) {
        let closestValidKey = closest(keys[keys.length - 1], Object.keys(parentValue).filter((key) => validateConfigPath(state, [...parentPath, key]).isValid));
        if (closestValidKey) {
          suggestions.push(pathToString2([...keys.slice(0, keys.length - 1), closestValidKey]));
          reason += ` Did you mean '${suggestions[0]}'?`;
        }
      } else {
        let altPath = findAlternativePath();
        if (altPath) {
          return {
            isValid: false,
            reason: `${reason} Did you mean '${pathToString2(altPath)}'?`,
            suggestions: [pathToString2(altPath)]
          };
        }
      }
      return {
        isValid: false,
        reason,
        suggestions
      };
    }
    if (!(typeof value2 === "string" || typeof value2 === "number" || value2 instanceof String || value2 instanceof Number || Array.isArray(value2) || typeof value2 === "function")) {
      let reason = `'${pathToString2(path)}' was found but does not resolve to a valid theme value.`;
      if (isObject22(value2)) {
        let validKeys = Object.keys(value2).filter((key) => validateConfigPath(state, [...keys, key], base).isValid);
        if (validKeys.length) {
          suggestions.push(...validKeys.map((validKey) => pathToString2([...keys, validKey])));
          reason += ` Did you mean something like '${suggestions[0]}'?`;
        }
      }
      return {
        isValid: false,
        reason,
        suggestions
      };
    }
    let isValid = true;
    for (let i = keys.length - 1; i >= 0; i--) {
      let key = keys[i];
      let parentValue = (0, import_dlv3.default)(state.config, [...base, ...keys.slice(0, i)]);
      if (/^[0-9]+$/.test(key)) {
        if (!isObject22(parentValue) && !Array.isArray(parentValue)) {
          isValid = false;
          break;
        }
      } else if (!isObject22(parentValue)) {
        isValid = false;
        break;
      }
    }
    if (!isValid) {
      let reason = `'${pathToString2(path)}' does not exist in your theme config.`;
      let altPath = findAlternativePath();
      if (altPath) {
        return {
          isValid: false,
          reason: `${reason} Did you mean '${pathToString2(altPath)}'?`,
          suggestions: [pathToString2(altPath)]
        };
      }
      return {
        isValid: false,
        reason,
        suggestions: []
      };
    }
    return {
      isValid: true,
      value: value2
    };
  }
  function getInvalidConfigPathDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.invalidConfigPath;
    if (severity === "ignore")
      return [];
    let diagnostics = [];
    findHelperFunctionsInDocument(state, document3).forEach((helperFn) => {
      let base = helperFn.helper === "theme" ? ["theme"] : [];
      let result = validateConfigPath(state, helperFn.path, base);
      if (result.isValid === true) {
        return;
      }
      diagnostics.push({
        code: DiagnosticKind.InvalidConfigPath,
        range: helperFn.ranges.path,
        severity: severity === "error" ? 1 : 2,
        message: result.reason,
        suggestions: result.suggestions
      });
    });
    return diagnostics;
  }
  function getInvalidTailwindDirectiveDiagnostics(state, document3, settings) {
    let severity = settings.tailwindCSS.lint.invalidTailwindDirective;
    if (severity === "ignore")
      return [];
    let diagnostics = [];
    let ranges = [];
    if (isCssDoc(state, document3)) {
      ranges.push(void 0);
    } else {
      let boundaries = getLanguageBoundaries(state, document3);
      if (!boundaries)
        return [];
      ranges.push(...boundaries.filter((b) => b.type === "css").map((_ref) => {
        let {
          range
        } = _ref;
        return range;
      }));
    }
    let notSemicolonLanguages = ["sass", "sugarss", "stylus"];
    let regex;
    if (notSemicolonLanguages.includes(document3.languageId) || state.editor && notSemicolonLanguages.includes(state.editor.userLanguages[document3.languageId])) {
      regex = /(?:\s|^)@tailwind\s+(?<value>[^\r\n]+)/g;
    } else {
      regex = /(?:\s|^)@tailwind\s+(?<value>[^;]+)/g;
    }
    let hasVariantsDirective = state.jit && gte(state.version, "2.1.99");
    ranges.forEach((range) => {
      let text2 = getTextWithoutComments(document3, "css", range);
      let matches = findAll(regex, text2);
      let valid = ["utilities", "components", "screens", gte(state.version, "1.0.0-beta.1") ? "base" : "preflight", hasVariantsDirective && "variants"].filter(Boolean);
      let suggestable = valid;
      if (hasVariantsDirective) {
        suggestable = suggestable.filter((value2) => value2 !== "screens");
      }
      matches.forEach((match) => {
        if (valid.includes(match.groups.value)) {
          return null;
        }
        let message = `'${match.groups.value}' is not a valid value.`;
        let suggestions = [];
        if (match.groups.value === "preflight") {
          suggestions.push("base");
          message += ` Did you mean 'base'?`;
        } else {
          let suggestion = closest(match.groups.value, suggestable);
          if (suggestion) {
            suggestions.push(suggestion);
            message += ` Did you mean '${suggestion}'?`;
          }
        }
        diagnostics.push({
          code: DiagnosticKind.InvalidTailwindDirective,
          range: absoluteRange({
            start: indexToPosition(text2, match.index + match[0].length - match.groups.value.length),
            end: indexToPosition(text2, match.index + match[0].length)
          }, range),
          severity: severity === "error" ? 1 : 2,
          message,
          suggestions
        });
      });
    });
    return diagnostics;
  }
  async function getRecommendedVariantOrderDiagnostics(state, document3, settings) {
    if (!state.jit)
      return [];
    if (gte(state.version, "2.99.0"))
      return [];
    let severity = settings.tailwindCSS.lint.recommendedVariantOrder;
    if (severity === "ignore")
      return [];
    let diagnostics = [];
    const classLists = await findClassListsInDocument(state, document3);
    classLists.forEach((classList) => {
      const classNames = getClassNamesInClassList(classList);
      classNames.forEach((className) => {
        let {
          rules
        } = generateRules2(state, [className.className]);
        if (rules.length === 0) {
          return;
        }
        let {
          variants,
          offset
        } = getVariantsFromClassName(state, className.className);
        let sortedVariants = [...variants].sort((a, b) => bigSign2(state.jitContext.variantOrder.get(b) - state.jitContext.variantOrder.get(a)));
        if (!equalExact(variants, sortedVariants)) {
          diagnostics.push({
            code: DiagnosticKind.RecommendedVariantOrder,
            suggestions: [[...sortedVariants, className.className.substr(offset)].join(state.separator)],
            range: className.range,
            severity: severity === "error" ? 1 : 2,
            message: "Variants are not in the recommended order, which may cause unexpected CSS output."
          });
        }
      });
    });
    return diagnostics;
  }
  async function doValidate(state, document3, only) {
    if (only === void 0) {
      only = [DiagnosticKind.CssConflict, DiagnosticKind.InvalidApply, DiagnosticKind.InvalidScreen, DiagnosticKind.InvalidVariant, DiagnosticKind.InvalidConfigPath, DiagnosticKind.InvalidTailwindDirective, DiagnosticKind.RecommendedVariantOrder];
    }
    const settings = await state.editor.getConfiguration(document3.uri);
    return settings.tailwindCSS.validate ? [...only.includes(DiagnosticKind.CssConflict) ? await getCssConflictDiagnostics(state, document3, settings) : [], ...only.includes(DiagnosticKind.InvalidApply) ? await getInvalidApplyDiagnostics(state, document3, settings) : [], ...only.includes(DiagnosticKind.InvalidScreen) ? getInvalidScreenDiagnostics(state, document3, settings) : [], ...only.includes(DiagnosticKind.InvalidVariant) ? getInvalidVariantDiagnostics(state, document3, settings) : [], ...only.includes(DiagnosticKind.InvalidConfigPath) ? getInvalidConfigPathDiagnostics(state, document3, settings) : [], ...only.includes(DiagnosticKind.InvalidTailwindDirective) ? getInvalidTailwindDirectiveDiagnostics(state, document3, settings) : [], ...only.includes(DiagnosticKind.RecommendedVariantOrder) ? await getRecommendedVariantOrderDiagnostics(state, document3, settings) : []] : [];
  }
  async function doHover(state, document3, position2) {
    return await provideClassNameHover(state, document3, position2) || provideCssHelperHover(state, document3, position2);
  }
  function provideCssHelperHover(state, document3, position2) {
    if (!isCssContext(state, document3, position2)) {
      return null;
    }
    let helperFns = findHelperFunctionsInRange(document3, {
      start: {
        line: position2.line,
        character: 0
      },
      end: {
        line: position2.line + 1,
        character: 0
      }
    });
    for (let helperFn of helperFns) {
      if (isWithinRange(position2, helperFn.ranges.path)) {
        let validated = validateConfigPath(state, helperFn.path, helperFn.helper === "theme" ? ["theme"] : []);
        let value2 = validated.isValid ? stringifyConfigValue(validated.value) : null;
        if (value2 === null) {
          return null;
        }
        return {
          contents: {
            kind: "markdown",
            value: ["```plaintext", value2, "```"].join("\n")
          },
          range: helperFn.ranges.path
        };
      }
    }
    return null;
  }
  async function provideClassNameHover(state, document3, position2) {
    let className = await findClassNameAtPosition(state, document3, position2);
    if (className === null)
      return null;
    if (state.jit) {
      let {
        root: root2,
        rules
      } = generateRules2(state, [className.className]);
      if (rules.length === 0) {
        return null;
      }
      return {
        contents: {
          language: "css",
          value: await stringifyRoot(state, root2, document3.uri)
        },
        range: className.range
      };
    }
    const parts = getClassNameParts(state, className.className);
    if (!parts)
      return null;
    if (isCssContext(state, document3, position2)) {
      let validated = validateApply(state, parts);
      if (validated === null || validated.isApplyable === false) {
        return null;
      }
    }
    const settings = await state.editor.getConfiguration(document3.uri);
    const css = stringifyCss(className.className, (0, import_dlv3.default)(state.classNames.classNames, [...parts, "__info"]), settings);
    if (!css)
      return null;
    return {
      contents: {
        language: "css",
        value: css
      },
      range: className.range
    };
  }
  async function getDocumentColors(state, document3) {
    let colors = [];
    if (!state.enabled)
      return colors;
    let settings = await state.editor.getConfiguration(document3.uri);
    if (settings.tailwindCSS.colorDecorators === false)
      return colors;
    let classLists = await findClassListsInDocument(state, document3);
    classLists.forEach((classList) => {
      let classNames = getClassNamesInClassList(classList);
      classNames.forEach((className) => {
        var _color$alpha;
        let color2 = getColor(state, className.className);
        if (color2 === null || typeof color2 === "string" || ((_color$alpha = color2.alpha) != null ? _color$alpha : 1) === 0) {
          return;
        }
        colors.push({
          range: className.range,
          color: culoriColorToVscodeColor(color2)
        });
      });
    });
    let helperFns = findHelperFunctionsInDocument(state, document3);
    helperFns.forEach((fn2) => {
      var _color$alpha2;
      let keys = stringToPath(fn2.path);
      let base = fn2.helper === "theme" ? ["theme"] : [];
      let value2 = (0, import_dlv3.default)(state.config, [...base, ...keys]);
      let color2 = getColorFromValue(value2);
      if (color2 && typeof color2 !== "string" && ((_color$alpha2 = color2.alpha) != null ? _color$alpha2 : 1) !== 0) {
        colors.push({
          range: fn2.ranges.path,
          color: culoriColorToVscodeColor(color2)
        });
      }
    });
    return dedupeByRange(colors);
  }
  async function stateFromConfig(configPromise) {
    const preparedTailwindConfig = await configPromise;
    const config = resolveConfig2(preparedTailwindConfig);
    const jitContext = createContext(config);
    const state = {
      version: "3.0.0",
      config,
      enabled: true,
      modules: {
        postcss: {
          // @ts-expect-error https://github.com/postcss/postcss/pull/1815
          module: postcss_default,
          version: ""
        },
        postcssSelectorParser: { module: import_postcss_selector_parser.default },
        jit: {
          createContext: { module: createContext },
          expandApplyAtRules: { module: expandApplyAtRules },
          generateRules: { module: generateRules }
        }
      },
      classNames: {
        classNames: {},
        context: {}
      },
      jit: true,
      jitContext,
      separator: config.separator,
      screens: config.theme?.screens ? Object.keys(config.theme.screens) : [],
      variants: jitContext.getVariants(),
      editor: {
        userLanguages: {},
        capabilities: {
          configuration: true,
          diagnosticRelatedInformation: true,
          itemDefaults: []
        },
        // eslint-disable-next-line require-await
        async getConfiguration() {
          return {
            editor: { tabSize: 2 },
            // Default values are based on
            // https://github.com/tailwindlabs/tailwindcss-intellisense/blob/v0.9.1/packages/tailwindcss-language-server/src/server.ts#L259-L287
            tailwindCSS: {
              emmetCompletions: false,
              classAttributes: ["class", "className", "ngClass"],
              codeActions: true,
              hovers: true,
              suggestions: true,
              validate: true,
              colorDecorators: true,
              rootFontSize: 16,
              lint: {
                cssConflict: "warning",
                invalidApply: "error",
                invalidScreen: "error",
                invalidVariant: "error",
                invalidConfigPath: "error",
                invalidTailwindDirective: "error",
                recommendedVariantOrder: "warning"
              },
              showPixelEquivalents: true,
              includeLanguages: {},
              files: {
                // Upstream defines these values, but we dont need them.
                exclude: []
              },
              experimental: {
                classRegex: [],
                // Upstream types are wrong
                configFile: {}
              }
            }
          };
        }
        // This option takes some properties that we dont have nor need.
      }
    };
    state.classList = jitContext.getClassList().filter((className) => className !== "*").map((className) => [className, { color: getColor(state, className) }]);
    return state;
  }
  function initialize3(tailwindWorkerOptions) {
    initialize2((ctx, options) => {
      const preparedTailwindConfig = tailwindWorkerOptions?.prepareTailwindConfig?.(options.tailwindConfig) ?? options.tailwindConfig ?? {};
      if (typeof preparedTailwindConfig !== "object") {
        throw new TypeError(
          `Expected tailwindConfig to resolve to an object, but got: ${JSON.stringify(
            preparedTailwindConfig
          )}`
        );
      }
      const statePromise = stateFromConfig(preparedTailwindConfig);
      const getTextDocument = (uri, languageId) => {
        const models = ctx.getMirrorModels();
        for (const model of models) {
          if (String(model.uri) === uri) {
            return TextDocument.create(uri, languageId, model.version, model.getValue());
          }
        }
      };
      return {
        async doComplete(uri, languageId, position2, context) {
          const textDocument = getTextDocument(uri, languageId);
          if (!textDocument) {
            return;
          }
          return doComplete2(await statePromise, textDocument, position2, context);
        },
        async doHover(uri, languageId, position2) {
          const textDocument = getTextDocument(uri, languageId);
          if (!textDocument) {
            return;
          }
          return doHover(await statePromise, textDocument, position2);
        },
        async doValidate(uri, languageId) {
          const textDocument = getTextDocument(uri, languageId);
          if (!textDocument) {
            return [];
          }
          return doValidate(await statePromise, textDocument);
        },
        async generateStylesFromContent(css, content) {
          const { config } = await statePromise;
          const tailwind = processTailwindFeatures(
            (processOptions) => () => processOptions.createContext(config, content)
          );
          const processor = postcss_default([tailwind]);
          const result = await processor.process(css);
          return result.css;
        },
        async getDocumentColors(uri, languageId) {
          const textDocument = getTextDocument(uri, languageId);
          if (!textDocument) {
            return [];
          }
          return getDocumentColors(await statePromise, textDocument);
        },
        async resolveCompletionItem(item) {
          return resolveCompletionItem(await statePromise, item);
        }
      };
    });
  }
  initialize3();
})();
/*! Bundled license information:

cssesc/cssesc.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

line-column/lib/line-column.js:
  (**
   * line-column - Convert efficiently index to/from line-column in a string
   * @module  lineColumn
   * @license MIT
   *)

css.escape/css.escape.js:
  (*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license *)
*/
